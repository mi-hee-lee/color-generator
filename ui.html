<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Generator</title>
    <style>
        /* CSS Variables - Design System */
        :root {
            /* Colors */
            --basicwhite: #ffffff;
            --basicblack: #000000;
            --basicblack-3: #666666;
            --basicblack-8: #333333;
            --basicgray: #f0f0f0;
            --specialblack-1: #e0e0e0;
            --specialblue-3: #e3f2fd;
            --accentblue: #007aff;
            
            /* Primary Color Scale */
            --primary-50: #eff6ff;
            --primary-100: #dbeafe;
            --primary-200: #bfdbfe;
            --primary-300: #93c5fd;
            --primary-400: #60a5fa;
            --primary-500: #3b82f6;
            --primary-600: #2563eb;
            --primary-700: #1d4ed8;
            --primary-800: #1e40af;
            --primary-900: #1e3a8a;
            
            /* Ruler v2 Colors */
            --ruler-v2-scale-custom-theme-150: #dbeafe;
            --ruler-v2-scale-custom-theme-500: #3b82f6;
            --ruler-v2-scale-gray-50: #f9fafb;
            --ruler-v2-scale-gray-800: #1f2937;
            --ruler-v2-scale-gray-950: #030712;
            --ruler-v2-semantic-border-line-selected: #3b82f6;
            --ruler-v2-semantic-fill-primary: #3b82f6;
            --ruler-v2-semantic-fill-surface-contents: #f1f5f9;
            
            /* Typography */
            --body-1-regular-font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            --body-1-regular-font-size: 12px;
            --body-1-regular-font-weight: 400;
            --body-1-regular-line-height: 16px;
            
            --body-1-semi-bold-font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            --body-1-semi-bold-font-size: 12px;
            --body-1-semi-bold-font-weight: 600;
            --body-1-semi-bold-line-height: 16px;
            
            --heading-2-semi-bold-font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            --heading-2-semi-bold-font-size: 14px;
            --heading-2-semi-bold-font-weight: 600;
            --heading-2-semi-bold-line-height: 20px;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: var(--body-1-regular-font-family);
            background: #f5f5f5;
            color: var(--basicblack-8);
            font-size: var(--body-1-regular-font-size);
            line-height: var(--body-1-regular-line-height);
            overflow-x: hidden;
        }

        .container {
            padding: 16px;
            width: 100%;
            max-width: 100%;
            background: var(--basicwhite);
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            margin: 0;
            box-sizing: border-box;
            overflow: hidden;
        }

        .tab-navigation {
            display: flex;
            align-items: flex-start;
            gap: 4px;
            padding: 4px;
            position: relative;
            background-color: var(--basicgray);
            border-radius: 12px;
            margin-bottom: 12px;
            width: 100%;
            box-sizing: border-box;
        }
        
        .tab-navigation::before {
            content: '';
            position: absolute;
            top: 4px;
            left: 4px;
            width: calc((100% - 16px) / 3);
            height: calc(100% - 8px);
            background-color: var(--basicwhite);
            border-radius: 8px;
            box-shadow: 0px 2px 8px -4px rgba(0, 0, 0, 0.2);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1;
        }

        .tab-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 8px 16px;
            position: relative;
            flex: 1;
            border: none;
            background: transparent;
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-family: var(--body-1-semi-bold-font-family);
            font-size: 10px;
            font-weight: 500;
            color: var(--basicblack-3);
            white-space: nowrap;
            transform: scale(1);
            z-index: 2;
        }

        .tab-btn.active {
            background-color: transparent;
            color: var(--basicblack);
            transform: scale(1.02);
        }
        
        /* 두 번째 탭 활성화 */
        .tab-navigation.second-active::before {
            transform: translateX(calc(100% + 4px));
        }
        
        /* 세 번째 탭 활성화 */
        .tab-navigation.third-active::before {
            transform: translateX(calc(200% + 8px));
        }
        
        .tab-btn:hover:not(.active) {
            background-color: rgba(255, 255, 255, 0.5);
            transform: scale(1.01);
        }
        
        .tab-btn:active {
            transform: scale(0.98);
        }

        .tab-content {
            display: none;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
            overflow: hidden;
        }

        .tab-content.active {
            display: block;
            animation: fadeIn 0.3s ease-in;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
            overflow: hidden;
        }
        

        .section {
            background: var(--basicwhite);
            border-radius: 8px;
            border: 0.5px solid #00000010;
            padding: 12px;
            margin-bottom: 10px;
            box-shadow: 0 6px 4px rgba(0,0,0,0.04);
            box-sizing: border-box;
            width: 100%;
            max-width: 100%;
            overflow: hidden;
        }

        .section-title {
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 8px;
            color: #333;
        }

        .color-input-group {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            width: 100%;
            box-sizing: border-box;
        }

        .color-picker {
            
            
            margin-right: 8px;
            
            
            cursor: pointer;
            background: none;
            flex: auto;
            text-transform: uppercase;

            width: 40px;
            padding: 2px 2px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 11px;
            margin-bottom: 8px;
            background: white;



        }

        .hex-input {
            flex: auto;
            text-transform: uppercase;

            width: 100%;
            padding: 6px 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 11px;
            margin-bottom: 8px;
            background: white;
        }

        .mode-buttons {
            display: flex;
            gap: 4px;
            margin-bottom: 8px;
        }

        .mode-btn {
            flex: 1;
            padding: 6px 8px;
            border: 1px solid var(--specialblack-1);
            border-radius: 4px;
            background: var(--basicwhite);
            color: var(--basicblack-3);
            font-size: 10px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .mode-btn.active {
            background: var(--basicblack);
            color: var(--basicwhite);
            border-color: var(--basicblack);
        }

        .action-btn {
            width: 100%;
            padding: 0px 12px;
            height: 32px;
            border: none;
            border-radius: 3px;
            font-family: var(--body-1-semi-bold-font-family);
            font-size: var(--body-1-semi-bold-font-size);
            font-weight: var(--body-1-semi-bold-font-weight);
            cursor: pointer;
            transition: background-color 0.2s;
            margin-top: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .btn-primary {
            background: var(--basicblack);
            color: var(--basicwhite);
        }

        .btn-primary:hover {
            background: var(--basicblack);
        }

        .btn-secondary {
            background: var(--basicgray);
            color: var(--basicblack);
        }

        .btn-secondary:hover {
            background: var(--basicgray);
            color: var(--basicblack);
        }

        .btn-success {
            background: var(--accentblue);
            color: var(--basicwhite)
        }

        .btn-success:hover {
            background: var(--accentblue);
            color: var(--basicwhite)
        }

        .color-grid {
            display: flex;
            flex-direction: column;
            gap: 3px;
            max-height: 300px;
            overflow-y: auto;
        }

        .color-row {
            display: flex;
            border-radius: 4px;
            overflow: hidden;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
            font-size: 9px;
        }

        .color-row.closest {
            border: 1.5px solid #000000;
        }

        .color-swatch {
            width: 28px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 8px;
            color: white;
            text-shadow: 0 0 2px rgba(0,0,0,0.3);
        }

        .color-info {
            flex: 1;
            background: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 6px;
        }

        .color-hex {
            font-family: 'Monaco', monospace;
            font-size: 9px;
            cursor: pointer;
            padding: 1px 3px;
            border-radius: 2px;
            transition: all 0.2s;
        }

        .color-hex:hover {
            background: #f0f8ff;
            transform: scale(1.05);
        }

        .success-message {
            background: #d4edda;
            color: #155724;
            padding: 6px;
            border-radius: 4px;
            font-size: 10px;
            text-align: center;
            margin-top: 6px;
            display: none;
        }

        .success-message.show {
            display: block;
        }

        /* 톤 매칭 스타일 */
        .reference-display {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: linear-gradient(145deg, #e8f5e8, #d4f4d4);
            border-radius: 6px;
            margin-bottom: 8px;
        }

        .reference-color {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .reference-info {
            flex: 1;
        }

        .reference-info h4 {
            font-size: 11px;
            color: #28a745;
            margin-bottom: 2px;
        }

        .reference-info p {
            font-size: 9px;
            color: #155724;
            margin: 0;
        }

        .tone-input-area {

            background: #f8f9fa;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            box-sizing: border-box;
            width: 100%;
            max-width: 100%;
            overflow: hidden;


        }
        
        .button-group {
            display: flex;
            gap: 6px;
            margin-top: 8px;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
        }
        
        .button-group .action-btn {
            flex: 1;
            min-width: 0;
            white-space: nowrap;
            max-width: calc(50% - 3px);
        }

        .tone-suggestions {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
            margin-top: 8px;
        }

        .tone-suggestion {
            background: white;
            border-radius: 6px;
            padding: 8px;
            text-align: center;
            transition: all 0.2s ease;
            cursor: pointer;
            border: 1px solid #e0e0e0;
        }

        .tone-suggestion:hover {
            border-color: #000;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .tone-color-display {
            width: 40px;
            height: 24px;
            border-radius: 4px;
            margin: 0 auto 6px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.15);
        }

        .tone-suggestion-title {
            font-weight: 600;
            font-size: 10px;
            color: #333;
            margin-bottom: 3px;
        }

        .tone-suggestion-hex {
            font-family: 'Monaco', monospace;
            font-size: 9px;
            font-weight: 600;
            margin-bottom: 3px;
        }

        .tone-suggestion-desc {
            font-size: 8px;
            color: #666;
            line-height: 1.2;
        }

        .info-box {
            background: #f0f0f0;
            border: 1px solid #c7c7c7;
            border-radius: 4px;
            padding: 12px;
            margin-top: 8px;
        }

        .info-box h5 {
            color: #000000;
            font-size: 10px;
            margin-bottom: 4px;
        }

        .info-box p {
            font-size: 9px;
            color: #888;
            margin: 0;
            line-height: 1.3;
        }

        /* Custom Theme Wizard 스타일 */
        .wizard-progress {
            margin-top: 20px;
            margin-bottom: 20px;
            padding: 0 4px;
        }

        .simple-progress-bar {
            display: flex;
            height: 4px;
            background: var(--specialblack-1);
            border-radius: 2px;
            overflow: hidden;
        }

        .progress-segment {
            flex: 1;
            background: var(--specialblack-1);
            margin-right: 2px;
            border-radius: 2px;
            position: relative;
            overflow: hidden;
        }
        
        .progress-segment::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: var(--accentblue);
            transition: left 0.6s ease-out;
        }

        .progress-segment:last-child {
            margin-right: 0;
        }

        .progress-segment.active::before {
            left: 0;
        }

        .progress-segment.completed::before {
            left: 0;
            transition: none;
        }

        .wizard-step {
            display: none;
            animation: fadeIn 0.3s ease-in;
        }

        .wizard-step.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .step-header {
            text-align: left;
            margin-bottom: 20px;
            padding: 0px 8px 0px 8px;
        }

        .step-header .step-title {
            font-size: 14px;
            color: #1a202c;
            margin-bottom: 4px;
            font-weight: 600;
            background: #1a202c;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .step-header p {
            font-size: 12px;
            color: #888;
            margin: 0;
        }

        .step-content {
            margin-bottom: 24px;
        }

        .input-group {
            margin-bottom: 16px;
        }

        .input-group label {
            display: block;
            font-size: 11px;
            font-weight: 500;
            color: #333;
            margin-bottom: 4px;
        }

        .color-preview {
            margin-top: 6px;
        }

        .preview-swatch {
            width: 40px;
            height: 20px;
            border-radius: 3px;
            background: #667eea;
            border: 1px solid #ccc;
        }

        .token-preview {
            background: #f5f5f5;
            border-radius: 4px;
            padding: 12px;
        }

        .token-item {
            display: block;
            margin-bottom: 8px;
            padding: 0;
            border: none;
        }

        .token-item:last-child {
            margin-bottom: 0;
        }

        .token-label {
            font-size: 11px;
            color: #333;
            font-weight: 500;
            margin-bottom: 2px;
        }

        .token-value {
            font-size: 11px;
            font-family: 'Monaco', monospace;
            color: #667eea;
            background: transparent;
            padding: 0;
            border-radius: 0;
            display: block;
        }

        .mode-cards {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 40px 12px;
            margin-bottom: 30px;
            padding:8px;
            width: 100%;
            justify-content: center;
            padding-bottom: 20px;
        }


        .mode-card {
            background: var(--basicwhite);
            border: 1px solid #00000010;
            border-radius: 6px;
            box-sizing: border-box;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            position: relative;
            width: 100%;
            height: 168px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 10px;
            overflow: visible;
        }

        .mode-card:hover {
            border-color: var(--accentblue);
            box-shadow: 0 4px 12px rgba(0, 122, 255, 0.15);
            transform: translateY(-1px);
        }

        .mode-card.selected {
            outline: 2px solid var(--accentblue);
            outline-offset: 2px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .card-checkbox {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 24px;
            height: 24px;
            border-radius: 14px;
            background: #ffffff80;
            border: 1px solid #00000010;
            box-sizing: border-box;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2px;
            transition: all 0.2s;
            z-index: 10;
        }

        .mode-card.selected .card-checkbox {
            background: #1f1f1f;
            border: 2px solid #000;
        }

        .checkbox-icon {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .checkbox-icon.unselected {
            opacity: 0.0;
        }

        .mode-card.selected .checkbox-icon.unselected {
            display: none;
        }
        
        /* 새로운 아이콘 구조 CSS */
        .mode-card .selected-icon {
            display: none !important;
        }
        .mode-card .unselected-icon {
            display: none !important;
        }
        .mode-card.selected .selected-icon {
            display: block !important;
        }
        .mode-card.selected .unselected-icon {
            display: none !important;
        }
        
        /* accent-on-bg-off 모드 배경색 적용 */
        .mode-card[data-mode="accent-on-bg-off"] {
            background: #e8edff;
        }
        
        /* accent-off-bg-on 모드 배경색 적용 */
        .mode-card[data-mode="accent-off-bg-on"] {
            background: #667eea;
        }
        .mode-card[data-mode="accent-off-bg-on"] .preview-frame {
            
        }
        .mode-card[data-mode="accent-off-bg-on"] .card-label {
            color: white;
        }
        
        /* accent-on-bg-black 모드 배경색 적용 */
        .mode-card[data-mode="accent-on-bg-black"] {
            background: #1f1f1f;
        }
        .mode-card[data-mode="accent-on-bg-black"] .preview-frame {
            background: none !important;
        }
        .mode-card[data-mode="accent-on-bg-black"] .card-label,
        .mode-card[data-mode="accent-on-bg-black"] .card-sub-label {
            color: white;
        }

        .card-preview {
            
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            width: 100%;
        }

        .preview-frame {
            width: 100%;
            height: 100%;
            
            border-radius: 3px;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            box-sizing: border-box;
        }


        .frame-header {
            font-size: 8px;
            font-weight: 600;
            color: #333;
            text-align: left;
            padding: 8px 6px 12px 6px;
            width : 100%;
            
            display: flex;
            justify-content: flex-start;
            align-items: center;
        }
        .frame-header svg path {
            fill: #000000;
            transition: fill 0.3s ease;
        }

        .frame-header.white {
            color: white;
        }


        .preview-frame.black-bg .frame-header {
            color: white;
            background: transparent;
            border-bottom-color: rgba(255,255,255,0.2);
        }

        .frame-content-area {
            justify-content: center;
            
            grid-template-columns: 1fr 1fr;
            flex: 1;
            align-items: stretch;
            width:100%;
        }

        .content-block {
            flex: 1;
            height:48px;
            margin-bottom: 8px;
            background: #f8f9fa;
            border-radius: 4px;
        }

        .content-block.light {
            background: #f8f9fa;
        }

        .content-block.white {
            background: rgba(255,255,255,0.8);
        }


        .preview-frame.black-bg .content-block.white {
            background: rgba(255,255,255,0.8);
        }

        .frame-button {
            background: #bcc8ff;
            border-radius: 4px;
            width: calc(100% - 16px);
            height: 26px;
            position: absolute;
            bottom: 0px;
            left: 10px;
            right: 10px;
            transition: background-color 0.3s ease;
        }

        .frame-button.accent {
            background: #667eea;
        }

        .frame-button.dark {
            background: #333;
        }

        .card-footer {
            position: absolute;
            bottom: -30px;
            left: 0;
            right: 0;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            line-height: 1.2;
            min-height: 20px;
        }

        .card-label {
            font-size: 8px;
            font-weight: 400;
            color: #333;
            transition: color 0.3s ease;
            text-align: center;
            width: 100%;
        }

        .card-description {
            font-size: 9px;
            color: #777;
            line-height: 1.2;
        }

        /* 색상 분류 정보 스타일 */
        .color-classification-info {
            margin-top: 8px;
            background: #f8f9fa;
            border-radius: 6px;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: row;

            padding: 12px;
        }

        .classification-result {
            
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: all 0.3s ease;
        }

        .classification-result.light {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .classification-result.dark {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .classification-details {
            font-size: 10px;
            color: #666;
            text-align: center;
        }

        .classification-reasons {
            font-size: 9px;
            color: #888;
            font-style: italic;
            line-height: 1.2;
        }

        .color-classification-info.light {
            border-left-color: #ffc107;
            background: #fff9e6;
        }

        .color-classification-info.dark {
            border-left-color: #17a2b8;
            background: #e6f7ff;
        }

        .step-actions {
            display: flex;
            justify-content: space-between;
            gap: 8px;
            padding-top: 12px;
        }

        .step-actions button {
            flex: 1;
            height: 32px;
            font-size: 11px;
        }

        .theme-preview {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 12px;
        }

        .theme-mode-preview {
            background: white;
            border-radius: 6px;
            padding: 8px;
            border: 1px solid #e0e0e0;
        }

        .theme-mode-title {
            font-size: 10px;
            font-weight: 600;
            margin-bottom: 6px;
            text-align: center;
        }

        .theme-semantic-list {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .semantic-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 8px;
        }

        .semantic-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            border: 1px solid rgba(0,0,0,0.1);
        }

        .semantic-name {
            flex: 1;
            font-family: 'Monaco', monospace;
            color: #666;
        }

        .theme-name-input {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 11px;
            margin-bottom: 8px;
            background: white;
        }

        .theme-name-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
        }

        /* Radio Button 스타일 */
        .radio-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 8px;
            background: rgba(255,255,255,0.5);
            border-radius: 4px;
            margin-bottom: 8px;
        }

        .radio-option {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            padding: 8px;
            background: white;
            border-radius: 4px;
            border: 1px solid #e0e0e0;
            cursor: pointer;
            transition: all 0.2s;
        }

        .radio-option:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .radio-option input[type="radio"] {
            margin-top: 2px;
        }

        .radio-option.selected {
            border-color: #667eea;
            background: #f0f4ff;
            border-width: 2px;
        }

        .radio-content {
            flex: 1;
        }

        .radio-label {
            font-size: 10px;
            font-weight: 600;
            color: #333;
            margin-bottom: 2px;
            display: block;
        }

        .radio-hint {
            font-size: 8px;
            color: #666;
            line-height: 1.3;
        }

        .step-indicator {
            display: inline-block;
            padding: 4px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: 600;
            margin-left: 6px;
        }

        .step-light {
            background: #fff3cd;
            color: #856404;
        }

        .step-medium {
            background: #e2e3e5;
            color: #41464b;
        }

        .step-dark {
            background: #343a40;
            color: #f8f9fa;
        }

        .classification-badge {
            display: inline-block;
            margin-right : 8px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: 600;
            
        }

        .classification-light {
            background: #cfe2ff;
            color: #084298;
            border: 1px solid #b6d4fe;
        }

        .classification-medium {
            background: #fff3cd;
            color: #664d03;
            border: 1px solid #ffecb5;
        }

        .classification-dark {
            background: #f8d7da;
            color: #842029;
            border: 1px solid #f5c2c7;
        }

        .warning-box {
            background: #fff7dd;
            border: 1px solid #ffeaa7;
            border-radius: 4px;
            padding: 8px 20px;
            margin-bottom: 8px;
        }

        .warning-box p {
            font-size: 9px;
            color: #856404;
            margin: 0;
        }

        /* 아코디언 스타일 추가 */
        .accordion-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 12px;
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 12px;
        }

        .accordion-header:hover {
            background: #e9ecef;
            border-color: #667eea;
        }

        .accordion-header.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .accordion-icon {
            font-size: 14px;
            transition: transform 0.2s;
        }

        .accordion-header.active .accordion-icon {
            transform: rotate(180deg);
        }

        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .accordion-content.expanded {
            max-height: 2000px;
            transition: max-height 0.5s ease-in;
        }

        .accordion-body {
            padding: 12px;
            border: 1px solid #e0e0e0;
            border-top: none;
            border-radius: 0 0 6px 6px;
            background: white;
        }

        #tuningSlider {
            width: 100%;
            -webkit-appearance: none;
            height: 4px;
            border-radius: 2px;
            background: #e0e0e0;
            outline: none;
        }

        #tuningSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }

        #tuningSlider:disabled {
            opacity: 0.5;
        }

        #tuningStatus {
            padding: 2px 6px;
            border-radius: 3px;
            background: #f0f0f0;
        }

        #tuningStatus.auto {
            background: #e8f5e8;
            color: #28a745;
        }

        /* 색상 복사 애니메이션 */
        @keyframes copyFlash {
            0% { 
                background: #4CAF50; 
                color: white;
                transform: scale(1.1);
            }
            100% { 
                background: transparent; 
                transform: scale(1);
            }
        }

        .color-hex.copied {
            animation: copyFlash 0.5s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- 탭 네비게이션 -->
        <div class="tab-navigation">
            <button class="tab-btn active" id="customThemeTab">
                Custom Theme
            </button>
            <button class="tab-btn" id="generatorTab">
                Scale Generator
            </button>
            <button class="tab-btn" id="toneMatchingTab">
                Tone Matching
            </button>
        </div>

        <!-- Custom Theme 탭 -->
        <div id="customThemeContent" class="tab-content active">
            <!-- 프로그레스 바 -->
            <div class="wizard-progress">
                <div class="simple-progress-bar">
                    <div class="progress-segment active" data-step="1"></div>
                    <div class="progress-segment" data-step="3"></div>
                </div>
            </div>

            <!-- Step 1: Key Color 선택 -->
            <div id="wizardStep1" class="wizard-step active">
                <div class="step-header">
                    <div class="step-title">Step 1. Key Color 선택</div>
                    <p>선택한 Key Color를 기반으로 완전한 semantic 토큰 시스템을 생성합니다.</p>
                </div>
                
                <div class="step-content">
                    <div class="input-group">
                        <label>테마 이름</label>
                        <input type="text" id="wizardThemeNameInput" class="theme-name-input" 
                               placeholder="예: custom-theme" value="custom-theme">
                    </div>
                    
                    <div class="input-group">
                        <label>Key Color</label>
                        <div class="color-input-group">
                            <input type="color" id="wizardThemeBaseColor" class="color-picker" value="#667eea">
                            <input type="text" id="wizardThemeBaseHex" class="hex-input" value="#667EEA">
                        </div>
                        
                        <!-- 컬러 분류 표시 -->
                        <div style="margin-top: 12px; display: flex; align-items: center; gap: 8px;">
                            <span id="wizardStepIndicator" class="step-indicator">Step: 500</span>
                            <span id="wizardClassificationBadge" class="classification-badge classification-medium">중간</span>
                        </div>
                        <div id="wizardStepClassificationInfo" class="color-classification-info" style="margin-top: 8px; display: none;">
                            <span id="wizardStepClassificationText">입력 색상이 Step 500에 해당합니다. 중간 범위(400-600)로 분류되어 Mode별로 다른 매핑이 적용됩니다.</span>
                        </div>
                    </div>
                </div>
                
                <div class="step-actions">
                    <button class="action-btn btn-success" onclick="goToStep(3)">다음</button>
                </div>
            </div>


            <!-- Step 3: Mode 선택 및 적용 -->
            <div id="wizardStep3" class="wizard-step">
                <div class="step-header">
                    <div class="step-title">Step 2. Mode 선택</div>
                    <p>선택한 Frame에 Theme을 적용합니다.</p>
                </div>
                
                <div class="step-content">
                    <div class="mode-selection">
                        <div class="mode-cards">
                            <!-- Mode 1: forground 중심 -->
                            <div class="mode-card selected" data-mode="accent-on-bg-off">
                                <div class="card-checkbox">
                                    <svg class="checkbox-icon selected-icon" width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <path d="M4.0332 10.0227L8.69951 15.0004L15.9589 5.03613" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                    </svg>
                                    <svg class="checkbox-icon unselected-icon" width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" style="display: none;">
                                        <circle cx="10" cy="10" r="8" stroke="#ddd" stroke-width="2" fill="none"/>
                                    </svg>
                                </div>
                                <div class="card-preview">
                                    <div class="preview-frame">
                                        <div class="frame-header">
                                            <svg width="48" height="14" viewBox="0 0 60 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                                                <path fill-rule="evenodd" clip-rule="evenodd" d="M18.3088 0.55957C15.5807 0.55957 13.3688 2.70342 13.3688 5.34814C13.3688 7.92637 15.5253 10.0165 18.1852 10.0165C18.2997 10.0165 18.4097 10.0021 18.5197 9.98764C18.5724 9.98073 18.6251 9.97381 18.6783 9.96847L14.9751 15.1993H17.4012L22.4563 7.88935C22.973 7.14237 23.2492 6.25583 23.2492 5.34814C23.2492 2.70342 21.0375 0.55957 18.3088 0.55957ZM18.3088 8.30514C16.6757 8.30514 15.3518 6.98118 15.3518 5.34814C15.3518 3.71478 16.6757 2.39081 18.3088 2.39081C19.9418 2.39081 21.2658 3.71478 21.2658 5.34814C21.2658 6.98118 19.9418 8.30514 18.3088 8.30514Z" />
                                                <path d="M39.3951 4.05236C38.3724 3.02899 36.9648 2.39064 35.4071 2.39064C32.2922 2.39064 29.7579 4.92496 29.7579 8.03979C29.7579 11.1546 32.2922 13.6888 35.4071 13.6888C36.9648 13.6888 38.3724 13.0506 39.3951 12.0271L40.7388 13.3707C39.362 14.6942 37.4839 15.5183 35.4071 15.5183C31.1984 15.5183 27.7743 12.1633 27.7743 8.03979C27.7743 3.91633 31.1984 0.561317 35.4071 0.561317C37.4839 0.561317 39.362 1.38521 40.7388 2.70885L39.3951 4.05236Z" />
                                                <path d="M52.6666 7.91318L57.6453 0.879978H59.8262V15.1995H57.8408V3.90107L52.6666 11.3855L47.492 3.90107V15.1995H45.5068V0.879978H47.6878L52.6666 7.91318Z" />
                                                <path d="M4.5399 0.559586C7.0473 0.559586 9.07995 2.52526 9.07995 4.94999C9.07995 6.0115 8.67185 7.03231 7.94025 7.80124L2.64392 13.3682H9.07995V15.1993H0V13.3682L6.43603 6.60338C6.86032 6.15747 7.09681 5.56558 7.09681 4.94999C7.09681 3.53662 5.95214 2.39083 4.5399 2.39083C3.12781 2.39083 1.98298 3.53662 1.98298 4.94999H0C0 2.52526 2.03249 0.559586 4.5399 0.559586Z" />
                                            </svg>
                                        </div>
                                        <div class="frame-content-area">
                                            <div class="content-block light"></div>
                                            <div class="content-block light"></div>
                                        </div>
  
                                        <div class="frame-button accent"></div>
                                    </div>
                                </div>
                                <div class="card-footer">
                                    <div class="card-label">forground 중심</div>
                                </div>
                            </div>
       
                            <!-- Mode 3: background 중심 -->
                            <div class="mode-card" data-mode="accent-off-bg-on">
                                <div class="card-checkbox">
                                    <svg class="checkbox-icon selected-icon" width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" style="display: none;">
                                        <path d="M4.0332 10.0227L8.69951 15.0004L15.9589 5.03613" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                    </svg>
                                    <svg class="checkbox-icon unselected-icon" width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <circle cx="10" cy="10" r="8" stroke="#ddd" stroke-width="2" fill="none"/>
                                    </svg>
                                </div>
                                <div class="card-preview">
                                    <div class="preview-frame">
                                        <div class="frame-header">
                                            <svg width="48" height="14" viewBox="0 0 60 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                                                <path fill-rule="evenodd" clip-rule="evenodd" d="M18.3088 0.55957C15.5807 0.55957 13.3688 2.70342 13.3688 5.34814C13.3688 7.92637 15.5253 10.0165 18.1852 10.0165C18.2997 10.0165 18.4097 10.0021 18.5197 9.98764C18.5724 9.98073 18.6251 9.97381 18.6783 9.96847L14.9751 15.1993H17.4012L22.4563 7.88935C22.973 7.14237 23.2492 6.25583 23.2492 5.34814C23.2492 2.70342 21.0375 0.55957 18.3088 0.55957ZM18.3088 8.30514C16.6757 8.30514 15.3518 6.98118 15.3518 5.34814C15.3518 3.71478 16.6757 2.39081 18.3088 2.39081C19.9418 2.39081 21.2658 3.71478 21.2658 5.34814C21.2658 6.98118 19.9418 8.30514 18.3088 8.30514Z" />
                                                <path d="M39.3951 4.05236C38.3724 3.02899 36.9648 2.39064 35.4071 2.39064C32.2922 2.39064 29.7579 4.92496 29.7579 8.03979C29.7579 11.1546 32.2922 13.6888 35.4071 13.6888C36.9648 13.6888 38.3724 13.0506 39.3951 12.0271L40.7388 13.3707C39.362 14.6942 37.4839 15.5183 35.4071 15.5183C31.1984 15.5183 27.7743 12.1633 27.7743 8.03979C27.7743 3.91633 31.1984 0.561317 35.4071 0.561317C37.4839 0.561317 39.362 1.38521 40.7388 2.70885L39.3951 4.05236Z" />
                                                <path d="M52.6666 7.91318L57.6453 0.879978H59.8262V15.1995H57.8408V3.90107L52.6666 11.3855L47.492 3.90107V15.1995H45.5068V0.879978H47.6878L52.6666 7.91318Z" />
                                                <path d="M4.5399 0.559586C7.0473 0.559586 9.07995 2.52526 9.07995 4.94999C9.07995 6.0115 8.67185 7.03231 7.94025 7.80124L2.64392 13.3682H9.07995V15.1993H0V13.3682L6.43603 6.60338C6.86032 6.15747 7.09681 5.56558 7.09681 4.94999C7.09681 3.53662 5.95214 2.39083 4.5399 2.39083C3.12781 2.39083 1.98298 3.53662 1.98298 4.94999H0C0 2.52526 2.03249 0.559586 4.5399 0.559586Z" />
                                            </svg>
                                        </div>
                                        <div class="frame-content-area">
                                            <div class="content-block white"></div>
                                            <div class="content-block white"></div>
                                        </div>
                                        <div class="frame-button dark"></div>
                                    </div>
                                </div>
                                <div class="card-footer">
                                    <div class="card-label">background 중심</div>
                                </div>
                            </div>
                            
                            <!-- Mode 2: forground 중심 white bg -->
                            <div class="mode-card" data-mode="accent-on-bg-fixed">
                                <div class="card-checkbox">
                                    <svg class="checkbox-icon selected-icon" width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" style="display: none;">
                                        <path d="M4.0332 10.0227L8.69951 15.0004L15.9589 5.03613" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                    </svg>
                                    <svg class="checkbox-icon unselected-icon" width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <circle cx="10" cy="10" r="8" stroke="#ddd" stroke-width="2" fill="none"/>
                                    </svg>
                                </div>
                                <div class="card-preview">
                                    <div class="preview-frame white-bg">
                                        <div class="frame-header">
                                            <svg width="48" height="14" viewBox="0 0 60 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                                                <path fill-rule="evenodd" clip-rule="evenodd" d="M18.3088 0.55957C15.5807 0.55957 13.3688 2.70342 13.3688 5.34814C13.3688 7.92637 15.5253 10.0165 18.1852 10.0165C18.2997 10.0165 18.4097 10.0021 18.5197 9.98764C18.5724 9.98073 18.6251 9.97381 18.6783 9.96847L14.9751 15.1993H17.4012L22.4563 7.88935C22.973 7.14237 23.2492 6.25583 23.2492 5.34814C23.2492 2.70342 21.0375 0.55957 18.3088 0.55957ZM18.3088 8.30514C16.6757 8.30514 15.3518 6.98118 15.3518 5.34814C15.3518 3.71478 16.6757 2.39081 18.3088 2.39081C19.9418 2.39081 21.2658 3.71478 21.2658 5.34814C21.2658 6.98118 19.9418 8.30514 18.3088 8.30514Z" />
                                                <path d="M39.3951 4.05236C38.3724 3.02899 36.9648 2.39064 35.4071 2.39064C32.2922 2.39064 29.7579 4.92496 29.7579 8.03979C29.7579 11.1546 32.2922 13.6888 35.4071 13.6888C36.9648 13.6888 38.3724 13.0506 39.3951 12.0271L40.7388 13.3707C39.362 14.6942 37.4839 15.5183 35.4071 15.5183C31.1984 15.5183 27.7743 12.1633 27.7743 8.03979C27.7743 3.91633 31.1984 0.561317 35.4071 0.561317C37.4839 0.561317 39.362 1.38521 40.7388 2.70885L39.3951 4.05236Z" />
                                                <path d="M52.6666 7.91318L57.6453 0.879978H59.8262V15.1995H57.8408V3.90107L52.6666 11.3855L47.492 3.90107V15.1995H45.5068V0.879978H47.6878L52.6666 7.91318Z" />
                                                <path d="M4.5399 0.559586C7.0473 0.559586 9.07995 2.52526 9.07995 4.94999C9.07995 6.0115 8.67185 7.03231 7.94025 7.80124L2.64392 13.3682H9.07995V15.1993H0V13.3682L6.43603 6.60338C6.86032 6.15747 7.09681 5.56558 7.09681 4.94999C7.09681 3.53662 5.95214 2.39083 4.5399 2.39083C3.12781 2.39083 1.98298 3.53662 1.98298 4.94999H0C0 2.52526 2.03249 0.559586 4.5399 0.559586Z" />
                                            </svg>
                                        </div>
                                        <div class="frame-content-area">
                                            <div class="content-block light"></div>
                                            <div class="content-block light"></div>
                                        </div>
                                        <div class="frame-button accent"></div>
                                    </div>
                                </div>
                                <div class="card-footer">
                                    <div class="card-label">forground 중심 <br> white bg</div>
                                </div>
                            </div>
                            
                            <!-- Mode 4: forground 중심 black bg -->
                            <div class="mode-card" data-mode="accent-on-bg-black">
                                <div class="card-checkbox">
                                    <svg class="checkbox-icon selected-icon" width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" style="display: none;">
                                        <path d="M4.0332 10.0227L8.69951 15.0004L15.9589 5.03613" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                    </svg>
                                    <svg class="checkbox-icon unselected-icon" width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <circle cx="10" cy="10" r="8" stroke="#ddd" stroke-width="2" fill="none"/>
                                    </svg>
                                </div>
                                <div class="card-preview">
                                    <div class="preview-frame black-bg">
                                        <div class="frame-header">
                                            <svg width="48" height="14" viewBox="0 0 60 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                                                <path fill-rule="evenodd" clip-rule="evenodd" d="M18.3088 0.55957C15.5807 0.55957 13.3688 2.70342 13.3688 5.34814C13.3688 7.92637 15.5253 10.0165 18.1852 10.0165C18.2997 10.0165 18.4097 10.0021 18.5197 9.98764C18.5724 9.98073 18.6251 9.97381 18.6783 9.96847L14.9751 15.1993H17.4012L22.4563 7.88935C22.973 7.14237 23.2492 6.25583 23.2492 5.34814C23.2492 2.70342 21.0375 0.55957 18.3088 0.55957ZM18.3088 8.30514C16.6757 8.30514 15.3518 6.98118 15.3518 5.34814C15.3518 3.71478 16.6757 2.39081 18.3088 2.39081C19.9418 2.39081 21.2658 3.71478 21.2658 5.34814C21.2658 6.98118 19.9418 8.30514 18.3088 8.30514Z" />
                                                <path d="M39.3951 4.05236C38.3724 3.02899 36.9648 2.39064 35.4071 2.39064C32.2922 2.39064 29.7579 4.92496 29.7579 8.03979C29.7579 11.1546 32.2922 13.6888 35.4071 13.6888C36.9648 13.6888 38.3724 13.0506 39.3951 12.0271L40.7388 13.3707C39.362 14.6942 37.4839 15.5183 35.4071 15.5183C31.1984 15.5183 27.7743 12.1633 27.7743 8.03979C27.7743 3.91633 31.1984 0.561317 35.4071 0.561317C37.4839 0.561317 39.362 1.38521 40.7388 2.70885L39.3951 4.05236Z" />
                                                <path d="M52.6666 7.91318L57.6453 0.879978H59.8262V15.1995H57.8408V3.90107L52.6666 11.3855L47.492 3.90107V15.1995H45.5068V0.879978H47.6878L52.6666 7.91318Z" />
                                                <path d="M4.5399 0.559586C7.0473 0.559586 9.07995 2.52526 9.07995 4.94999C9.07995 6.0115 8.67185 7.03231 7.94025 7.80124L2.64392 13.3682H9.07995V15.1993H0V13.3682L6.43603 6.60338C6.86032 6.15747 7.09681 5.56558 7.09681 4.94999C7.09681 3.53662 5.95214 2.39083 4.5399 2.39083C3.12781 2.39083 1.98298 3.53662 1.98298 4.94999H0C0 2.52526 2.03249 0.559586 4.5399 0.559586Z" />
                                            </svg>
                                        </div>
                                        <div class="frame-content-area">
                                            <div class="content-block white"></div>
                                            <div class="content-block white"></div>
                                        </div>
                                        <div class="frame-button accent"></div>
                                    </div>
                                </div>
                                <div class="card-footer">
                                    <div class="card-label">forground 중심<br> black bg</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Mapping 정보보기 컨트롤 -->
                <div class="mapping-info-controls" style="margin: 8px; padding: 12px; border: 1px solid #00000010; border-radius: 8px; background: #f8f9fa;">
                    <div style="display: flex; gap: 6px; align-items: center; flex-direction: column; ">
                        <button 
                            id="showMappingBtn" 
                            onclick="showMappingInfo()" 
                            style="padding: 8px 16px; background: #000; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 10px;">
                            선택된 Frame의 Mapping 정보보기
                        </button>
                        <span id="mappingStatus" style="font-size: 10px; color: #666; margin-left: 8px;">Frame을 선택하고 버튼을 눌러주세요</span>
                    </div>
                </div>
                
                <div class="step-actions">
                    <button class="action-btn btn-secondary" onclick="goToStep(1)">이전</button>
                    <button class="action-btn btn-success" onclick="applyCustomTheme()">custom theme 적용하기</button>
                </div>
            </div>
        </div>

        <!-- Scale Generator 탭 부분 수정 -->
        <div id="generatorContent" class="tab-content">
            <div class="section">
                <div class="section-title">Base Color Input</div>
                <div class="color-input-group">
                    <input type="color" id="baseColor" class="color-picker" value="#667eea">
                    <input type="text" id="hexInput" class="hex-input" value="#667EEA">
                </div>
                
                <!-- 컬러 분류 표시 -->
                <div style="margin-top: 12px; display: flex; align-items: center; gap: 8px;">
                    <span id="stepIndicator" class="step-indicator">Step: 500</span>
                    <span id="classificationBadge" class="classification-badge classification-medium">중간</span>
                </div>
                <div id="stepClassificationInfo" class="color-classification-info" style="margin-top: 8px; display: none;">
                    <span id="stepClassificationText">입력 색상이 Step 500에 해당합니다. 중간 범위(400-600)로 분류되어 Mode별로 다른 매핑이 적용됩니다.</span>
                </div>
            </div>

            <!-- Base Color Input 섹션 다음에 추가 -->
            <div class="section" style="display: none;">
                <div class="section-title">Fine Tuning</div>
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <div style="display: flex; gap: 8px;">
                        <label style="font-size: 11px;">Auto Mode</label>
                        <input type="checkbox" id="autoTuning">
                    </div>
                    <span id="tuningStatus" style="font-size: 10px; color: #666;">Manual: 0</span>
                </div>
                <div style="display: flex; gap: 8px; align-items: center;">
                    <input type="range" id="tuningSlider" min="-10" max="10" value="0" style="flex: 1;">
                    <span id="tuningValue" style="min-width: 30px; text-align: center;">0</span>
                </div>
            </div>

            <div class="section">
                <div class="section-title">Background Mode</div>
                <div class="mode-buttons">
                    <button class="mode-btn active" onclick="setMode('light')">Light Mode</button>
                    <button class="mode-btn" onclick="setMode('dark')">Dark Mode</button>
                </div>
            </div>

            <div class="section">
                <div class="section-title">Variable Name</div>
                <input type="text" id="variableName" class="hex-input" placeholder="예: primary, brand, blue" style="width: 100%;">
                <p style="font-size: 9px; color: #666; margin-top: 4px;">
                    변수 이름 형식: {name}-50, {name}-100, {name}-200...
                </p>
            </div>

            <div class="section">
                <div class="section-title">Generated Color Palette</div>
                <div class="color-grid" id="colorResults">
                    <!-- 색상들이 여기에 표시됩니다 -->
                </div>
            </div>

            <!-- 액션 버튼들 추가 -->
            <div class="action-buttons" style="display: flex; flex-direction: column; gap: 2px; margin-top: 4px;">
                <button class="action-btn btn-primary" onclick="createVariables()">
                    Create Variables (현재 모드)
                </button>
                <button class="action-btn btn-success" onclick="createDualModeVariables()">
                    Create Light + Dark Variables
                </button>
                <button class="action-btn btn-secondary" onclick="createStyles()">
                    Create Color Styles
                </button>
            </div>
        </div>

        <!-- Tone Matching 탭 -->
        <div id="toneMatchingContent" class="tab-content">
            <div class="header">
                
            </div>

            <!-- 기준 색상 설정 -->
            <div class="section">
                <div class="section-title">Step 1. 기준 색상 정하기</div>
                <p style="color: #666; margin-bottom: 8px; font-size: 10px;">기준이 될 색상을 선택하세요</p>
                
                <div class="color-input-group">
                    <input type="color" id="referenceColorPicker" class="color-picker" value="#667eea">
                    <input type="text" id="referenceColorHex" class="hex-input" value="#667EEA">
                </div>
                
                <div class="button-group">
                    <button id="setRefBtn" class="action-btn btn-primary">Set Reference</button>
                    <button id="clearRefBtn" class="action-btn btn-secondary">Clear</button>
                </div>
                
                <div id="referenceStatus" style="color: #666; font-size: 10px; margin: 8px 0px 8px 0px;">현재 설정된 기준 컬러가 없습니다.</div>
                <div id="referenceDisplay"></div>
            </div>
            
            <!-- 새 색상 입력 -->
            <div class="section">
                <div class="section-title">Step 2. 새로운 컬러 입력하기</div>
                <p style="color: #666; margin-bottom: 8px; font-size: 10px;">원하는 색상을 입력하면 톤 매칭이 제공됩니다</p>
                
                <div class="tone-input-area">
                    <div class="color-input-group">
                        <input type="color" id="newColorPicker" class="color-picker" value="#ff0000">
                        <input type="text" id="newColorHex" class="hex-input" value="#FF0000">
                    </div>
                    <button id="getSuggestionsBtn" class="action-btn btn-success">추천받기</button>
                    <p style="font-size: 10px; color: #666; margin-top: 4px;">이 색상은 기준 톤에 맞게 조정됩니다.</p>
                </div>
                
                <div id="toneMatchingResults"></div>
            </div>
        </div>

        <!-- 성공 메시지 -->
        <div class="success-message" id="successMessage"></div>
    </div>

    <script>
        
        // 전역 변수
        let currentMode = 'light';
        let generatedColors = [];
        let referenceColor = null;
        let currentTheme = null;

        // 색상 유틸리티
        class ColorUtils {
            static hexToRgb(hex) {
                var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : { r: 0, g: 0, b: 0 };
            }

            static rgbToHex(r, g, b) {
                return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
            }

            static hexToHsl(hex) {
                var rgb = this.hexToRgb(hex);
                return this.rgbToHsl(rgb.r / 255, rgb.g / 255, rgb.b / 255);
            }

            static rgbToHsl(r, g, b) {
                var max = Math.max(r, g, b);
                var min = Math.min(r, g, b);
                let h, s, l = (max + min) / 2;

                if (max === min) {
                    h = s = 0;
                } else {
                    var d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    switch (max) {
                        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                        case g: h = (b - r) / d + 2; break;
                        case b: h = (r - g) / d + 4; break;
                    }
                    h /= 6;
                }

                return [h * 360, s * 100, l * 100];
            }

            static hslToRgb(h, s, l) {
                h /= 360; s /= 100; l /= 100;
                var a = s * Math.min(l, 1 - l);
                var f = n => {
                    var k = (n + h * 12) % 12;
                    return l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
                };
                return [
                    Math.round(f(0) * 255),
                    Math.round(f(8) * 255),
                    Math.round(f(4) * 255)
                ];
            }

            static hslToHex(h, s, l) {
                var [r, g, b] = this.hslToRgb(h, s, l);
                return this.rgbToHex(r, g, b);
            }

            // === Contrast <-> Luminance 도우미 (white/dark 배경) ===
            static luminanceFromContrastVsWhite(contrast) {
                // contrast = (1.0 + 0.05) / (Y + 0.05)  →  Y = (1.05 / C) - 0.05
                return (1.05 / contrast) - 0.05;
            }

            static luminanceFromContrastVsBlack(contrast) {
                // contrast = (Y + 0.05) / 0.05  →  Y = 0.05 * contrast - 0.05
                return 0.05 * contrast - 0.05;
            }

            static luminanceFromContrastVsDarkBg(contrast) {
                // #0c0c0c의 luminance 계산
                const darkBgLuminance = this.getLuminance(12, 12, 12);
                // contrast = (Y + 0.05) / (darkBgLuminance + 0.05)  →  Y = contrast * (darkBgLuminance + 0.05) - 0.05
                return contrast * (darkBgLuminance + 0.05) - 0.05;
            }

            // HSL(h,s,L)에서 L을 이진탐색해서 목표 Y에 최대근접
            static solveLForY(h, s, targetY) {
                let lo = 0, hi = 100, bestL = 50, bestErr = 1e9;
                for (let i = 0; i < 24; i++) {
                    const mid = (lo + hi) / 2;
                    const [r, g, b] = this.hslToRgb(h, s, mid);
                    const Y = this.getLuminance(r, g, b);
                    const err = Math.abs(Y - targetY);
                    if (err < bestErr) { bestErr = err; bestL = mid; }
                    // white 기준: Y가 높으면 더 어둡게(hi 내림)
                    if (Y > targetY) hi = mid; else lo = mid;
                }
                return { L: bestL, err: bestErr };
            }

            // (가능하면 채도 보존) 목표 대비를 만족하는 HSL 찾기
            static solveHSLForContrast(h, sInput, contrastTarget, background = 'light') {
                const bgRgb = background === 'light' 
                    ? { r: 255, g: 255, b: 255 }
                    : { r: 12, g: 12, b: 12 };

                // 채도는 입력값 우선, 불가시 극소폭 보정
                const SAT_CAND = [1.0, 0.95, 0.9, 0.85].map(f => Math.max(5, Math.min(100, sInput * f)));
                let best = null;

                for (const s of SAT_CAND) {
                    // L값을 이진탐색으로 목표 대비에 맞춤
                    let lo = 0, hi = 100, bestL = 50, bestErr = 1e9;
                    
                    for (let i = 0; i < 24; i++) {
                        const mid = (lo + hi) / 2;
                        const [r, g, b] = this.hslToRgb(h, s, mid);
                        const actualContrast = this.getContrast({ r, g, b }, bgRgb);
                        const err = Math.abs(actualContrast - contrastTarget);
                        
                        if (err < bestErr) { 
                            bestErr = err; 
                            bestL = mid; 
                        }
                        
                        if (actualContrast > contrastTarget) {
                            if (background === 'light') {
                                lo = mid; // Light: 대비가 높으면 L을 높여서 대비를 줄임 (밝게)
                            } else {
                                hi = mid; // Dark: 대비가 높으면 L을 낮춰서 대비를 줄임 (어둡게)
                            }
                        } else {
                            if (background === 'light') {
                                hi = mid; // Light: 대비가 낮으면 L을 낮춰서 대비를 높임 (어둡게)
                            } else {
                                lo = mid; // Dark: 대비가 낮으면 L을 높여서 대비를 높임 (밝게)
                            }
                        }
                    }
                    
                    if (!best || bestErr < best.err) {
                        best = { h, s, l: bestL, err: bestErr };
                    }
                    if (bestErr < 0.01) break; // 충분히 근접하면 조기 종료
                }
                return best; // {h,s,l,err}
            }

            static getLuminance(r, g, b) {
                var [rs, gs, bs] = [r, g, b].map(c => {
                    c = c / 255;
                    return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
                });
                return 0.2126 * rs + 0.7152 * gs + 0.0722 * bs;
            }

            static getContrast(rgb1, rgb2) {
                var l1 = this.getLuminance(rgb1.r, rgb1.g, rgb1.b);
                var l2 = this.getLuminance(rgb2.r, rgb2.g, rgb2.b);
                var lighter = Math.max(l1, l2);
                var darker = Math.min(l1, l2);
                return (lighter + 0.05) / (darker + 0.05);
            }

            // 가장 가까운 스텝 찾기
            static findClosestStep(hex, mode) {
                mode = mode || 'light';  // 기본값 설정
                var [h, s, l] = this.hexToHsl(hex);
                var steps = [50, 75, 100, 150, 200, 300, 400, 500, 600, 700, 800, 900, 950];
                let closestStep = 500;
                let minDiff = Infinity;
                
                steps.forEach(function(step) {
                    let targetLightness;
                    if (mode === 'light') {
                        // ColorGenerator와 동일한 로직 사용
                        switch(step) {
                            case 50:  targetLightness = 95; break;
                            case 75:  targetLightness = 90; break;
                            case 100: targetLightness = 85; break;
                            case 150: targetLightness = 78; break;
                            case 200: targetLightness = 70; break;
                            case 300: targetLightness = 60; break;
                            case 400: targetLightness = 50; break;
                            case 500: targetLightness = 40; break;
                            case 600: targetLightness = 32; break;
                            case 700: targetLightness = 25; break;
                            case 800: targetLightness = 18; break;
                            case 900: targetLightness = 12; break;
                            case 950: targetLightness = 8; break;
                            default: targetLightness = 50;
                        }
                    } else {
                        // Dark mode 명도 매핑
                        switch(step) {
                            case 50:  targetLightness = 5; break;
                            case 75:  targetLightness = 10; break;
                            case 100: targetLightness = 15; break;
                            case 150: targetLightness = 22; break;
                            case 200: targetLightness = 30; break;
                            case 300: targetLightness = 40; break;
                            case 400: targetLightness = 50; break;
                            case 500: targetLightness = 60; break;
                            case 600: targetLightness = 68; break;
                            case 700: targetLightness = 75; break;
                            case 800: targetLightness = 82; break;
                            case 900: targetLightness = 88; break;
                            case 950: targetLightness = 92; break;
                            default: targetLightness = 50;
                        }
                    }
                    
                    var diff = Math.abs(l - targetLightness);
                    if (diff < minDiff) {
                        minDiff = diff;
                        closestStep = step;
                    }
                });
                
                return closestStep;
            }
        }

        // Hue의 본질적 밝기 판단 함수
        function getHueBrightness(hue) {
            // Hue 범위별 본질적 밝기 분류
            
            // 매우 밝은 색상군
            if (hue >= 50 && hue <= 70) return 'very-bright';     // 노랑 (Yellow)
            if (hue >= 170 && hue <= 190) return 'very-bright';   // 청록 (Cyan)
            
            // 밝은 색상군  
            if (hue >= 70 && hue <= 150) return 'bright';         // 연두-초록 (Yellow-Green to Green)
            if (hue >= 150 && hue <= 170) return 'bright';        // 청록-초록 경계 (Green-Cyan)
            if (hue >= 30 && hue <= 50) return 'bright';          // 주황 (Orange)
            
            // 중간 색상군
            if (hue >= 190 && hue <= 210) return 'medium';        // 청록-파랑 경계 (Cyan-Blue)
            if (hue >= 20 && hue <= 30) return 'medium';          // 주황-빨강 경계
            
            // 어두운 색상군
            if (hue >= 210 && hue <= 240) return 'dark';          // 파랑 (Blue)
            if (hue >= 240 && hue <= 300) return 'dark';          // 보라 (Purple/Violet)
            if (hue >= 0 && hue <= 20 || hue >= 300) return 'dark'; // 빨강-자주 (Red-Magenta)
            
            return 'medium'; // 기본값
        }

        // 새로운 컬러 범위 분류 로직
        function getColorRangeFromStep(closestStep, hex) {
            // 본질적 밝기 판단
            var isInherentlyBright = false;
            if (hex) {
                var hsl = ColorUtils.hexToHsl(hex);
                var hue = hsl[0];
                var lightness = hsl[2];
                var hueBrightness = getHueBrightness(hue);
                
                // 1) Lightness가 80% 이상이면 무조건 밝은 색상으로 분류
                if (lightness >= 80) {
                    isInherentlyBright = true;
                } 
                // 2) 그렇지 않으면 Hue의 본질적 밝기로 판단
                else {
                    // very-bright, bright까지를 본질적으로 밝은 색상으로 분류
                    isInherentlyBright = (hueBrightness === 'very-bright' || hueBrightness === 'bright');
                }
            }
            
            // 색상 범위 결정 (본질적 밝기에 따라 기준 조정)
            if (isInherentlyBright) {
                // 본질적으로 밝은 색상: 더 넓은 범위를 'light'로 분류
                if (closestStep <= 300) {
                    return 'light';
                } else if (closestStep >= 400 && closestStep <= 600) {
                    return 'medium';
                } else {
                    return 'dark';  // 700-950
                }
            } else {
                // 중간/어두운 색상: 더 좁은 범위만 'light'로 분류
                if (closestStep < 200) {
                    return 'light';
                } else if (closestStep >= 200 && closestStep <= 600) {
                    return 'medium';
                } else {
                    return 'dark';  // 700-950
                }
            }
        }

        // 색상 생성기
        class ColorGenerator {
    constructor() {
        this.steps = [50, 75, 100, 150, 200, 300, 400, 500, 600, 700, 800, 900, 950];
        
        // Light Mode 회색 톤 (기존 규칙대로)
        this.lightModeGrayTones = [
            '#FFFFFF', // 50
            '#F7F7F7', // 75
            '#F0F0F0', // 100
            '#E8E8E8', // 150
            '#DDDDDD', // 200
            '#CCCCCC', // 300
            '#B4B4B4', // 400
            '#9E9E9E', // 500
            '#8A8A8A', // 600
            '#6A6A6A', // 700
            '#464646', // 800
            '#1F1F1F', // 900
            '#000000'  // 950
        ];
        
        // Dark Mode 회색 톤
        this.darkModeGrayTones = [
            '#0C0C0C', // 50
            '#141414', // 75
            '#1C1C1C', // 100
            '#242424', // 150
            '#313131', // 200
            '#414141', // 300
            '#525252', // 400
            '#626262', // 500
            '#808080', // 600
            '#ADADAD', // 700
            '#E3E3E3', // 800
            '#F4F4F4', // 900
            '#FCFCFC'  // 950
        ];

        // Dark Mode 대비값 (#0c0c0c 배경 기준)
        this.darkModeContrastRatios = [
            1.00, // 50
            1.06, // 75
            1.15, // 100
            1.26, // 150
            1.50, // 200
            1.92, // 300
            2.50, // 400
            3.21, // 500
            4.95, // 600
            8.72, // 700
            15.24, // 800
            17.79, // 900
            20.0   // 950
        ];
    }

    getAutoTuningValue(hex) {
        var [h, s, l] = ColorUtils.hexToHsl(hex);
        let tuning = 0;
        
        // 색상별 조정
        if (h >= 45 && h <= 75) tuning = -3;      // 노란색: 더 어둡게
        else if (h >= 15 && h <= 45) tuning = -2; // 주황색
        else if (h >= 210 && h <= 270) tuning = 2; // 파란색: 더 밝게
        else if (h >= 180 && h <= 210) tuning = 1; // 청록색
        
        // 채도에 따른 추가 조정
        if (s > 80) tuning -= 1;
        else if (s < 30) tuning += 1;
        
        return Math.max(-10, Math.min(10, tuning));
    }

    generateColors(inputHex, mode, tuningValue = 0) {
        const [hInput, sInput, lInput] = ColorUtils.hexToHsl(inputHex);
        const backgroundRgb = (mode === 'light') ? { r: 255, g: 255, b: 255 } : { r: 12, g: 12, b: 12 };

        // 무채색은 기존 회색 톤 그대로 (UI 의도 유지)
        if (sInput < 5) {
            const toneSet = (mode === 'light') ? this.lightModeGrayTones : this.darkModeGrayTones;
            return this.steps.map((step, i) => {
                const hex = toneSet[i];
                const rgb = ColorUtils.hexToRgb(hex);
                const contrast = ColorUtils.getContrast(rgb, backgroundRgb);
                return { step, hex, contrast, isClosest: false };
            });
        }

        // 1) grayscale 분포를 기반으로 현재 모드의 "목표 대비" 산출
        const targets = this.buildTargetContrasts(mode, hInput);

        // 2) 각 스텝에서 목표 대비를 만족하도록 HSL 계산 (hue 고정, 채도 보존)
        const colors = this.steps.map((step, i) => {
            const targetContrast = targets[i];
            const solved = ColorUtils.solveHSLForContrast(hInput, sInput, targetContrast, mode);

            // 튜닝: 최종 L에 소폭 가감
            let L = Math.max(0, Math.min(100, solved.l + (tuningValue || 0)));
            const [r, g, b] = ColorUtils.hslToRgb(solved.h, solved.s, L);
            const hex = ColorUtils.rgbToHex(r, g, b);
            const contrast = ColorUtils.getContrast({ r, g, b }, backgroundRgb);

            return { step, hex, contrast, isClosest: false };
        });

        // 3) 새로운 Hue 기반 로직으로 가장 가까운 step 찾기
        const inputColorHex = ColorUtils.hslToHex(hInput, sInput * 100, lInput);
        
        // 모든 step에 대해 새로운 분류 로직을 적용하여 가장 적절한 step 찾기
        let bestStepIndex = 0;
        let minDiff = Infinity;
        
        colors.forEach((color, index) => {
            // 각 step이 입력 색상과 얼마나 유사한 범위에 속하는지 계산
            const colorRange = getColorRangeFromStep(color.step, inputColorHex);
            const actualLightness = lInput;
            const stepLightness = ColorUtils.hexToHsl(color.hex)[2];
            
            // lightness 차이와 범위 일치도를 종합적으로 고려
            let diff = Math.abs(actualLightness - stepLightness);
            
            // 같은 범위(light/medium/dark)에 속한 경우 가중치 부여 
            if (colorRange === getColorRangeFromStep(color.step, inputColorHex)) {
                diff *= 0.5; // 같은 범위면 우선순위 높임
            }
            
            if (diff < minDiff) {
                minDiff = diff;
                bestStepIndex = index;
            }
        });
        
        colors[bestStepIndex].isClosest = true;

        return colors;
    }

    // 목표 대비 빌더 - 각 스텝의 목표 대비비율 계산
    buildTargetContrasts(mode, inputHue) {
        const steps = this.steps;
        const bg = (mode === 'light') ? { r: 255, g: 255, b: 255 } : { r: 12, g: 12, b: 12 };

        // 1) Grayscale 대비율 분포 계산
        const grayContrast = (mode === 'light') ? 
            steps.map((_, i) => {
                const hex = this.lightModeGrayTones[i];
                const rgb = ColorUtils.hexToRgb(hex);
                return ColorUtils.getContrast(rgb, { r: 255, g: 255, b: 255 });
            }) :
            this.darkModeContrastRatios;

        // 2) 입력 hue의 anchor 대비 계산 (Step50/Step950)
        let hueMinContrast, hueMaxContrast;
        
        if (mode === 'light') {
            // Light: Step50=1.03 고정, Step950=20.0 고정
            hueMinContrast = 1.03; // Step50 anchor
            hueMaxContrast = 20.0; // Step950 anchor
        } else {
            // Dark: Step50=가장어둠(L=0), Step950=최대 19.0으로 제한 (완전 흰색 방지)
            const darkestRgb = ColorUtils.hexToRgb(ColorUtils.hslToHex(inputHue, 100, 0));
            const brightestRgb = ColorUtils.hexToRgb(ColorUtils.hslToHex(inputHue, 100, 100));
            hueMinContrast = ColorUtils.getContrast(darkestRgb, bg);   // Step50 anchor
            const theoreticalMax = ColorUtils.getContrast(brightestRgb, bg);
            hueMaxContrast = Math.min(19.0, theoreticalMax); // Step950을 19.0으로 제한
        }

        // 3) Grayscale 분포의 비율로 hue 범위에 보간
        const grayMinContrast = grayContrast[0];
        const grayMaxContrast = grayContrast[grayContrast.length - 1];
        
        return grayContrast.map(grayC => {
            const ratio = (grayC - grayMinContrast) / (grayMaxContrast - grayMinContrast);
            return hueMinContrast + ratio * (hueMaxContrast - hueMinContrast);
        });
    }
}

        // Wizard 관련 함수들
        let currentWizardStep = 1;
        let wizardThemeData = null;

        function goToStep(stepNumber) {
            
            // 현재 스텝에서 데이터 수집 및 처리
            if (stepNumber === 3 && currentWizardStep === 1) {
                // Step 1에서 Step 3로: 테마 변수를 먼저 생성하고 테마 데이터 생성
                createCustomThemeVariablesAndProceed();
                return; // 비동기 처리를 위해 여기서 리턴
            }

            // 프로그레스 업데이트
            updateProgressBar(stepNumber);

            // 스텝 콘텐츠 업데이트
            updateStepContent(stepNumber);

            currentWizardStep = stepNumber;
        }
        
        function updateProgressBar(stepNumber) {
            document.querySelectorAll('.progress-segment').forEach(segment => {
                const step = parseInt(segment.dataset.step);
                segment.classList.remove('active', 'completed');
                
                if (step < stepNumber) {
                    segment.classList.add('completed');
                } else if (step === stepNumber) {
                    segment.classList.add('active');
                }
            });
        }
        
        function updateStepContent(stepNumber) {
            document.querySelectorAll('.wizard-step').forEach(step => {
                step.classList.remove('active');
            });
            
            const targetStep = document.getElementById('wizardStep' + stepNumber);
            if (targetStep) {
                targetStep.classList.add('active');
                
                // Step 3에서 모드 미리보기 업데이트
                if (stepNumber === 3) {
                    setTimeout(() => {
                        const baseColorInput = document.getElementById('wizardThemeBaseHex');
                        if (baseColorInput && baseColorInput.value) {
                            updateAllModePreviewsWithColor(baseColorInput.value);
                        }
                    }, 100);
                }
            } else {
                console.error('Step element not found:', 'wizardStep' + stepNumber);
            }
        }
        
        function createCustomThemeVariablesAndProceed() {
            const themeName = document.getElementById('wizardThemeNameInput').value;
            const baseColor = document.getElementById('wizardThemeBaseHex').value;
            
            if (!themeName || !baseColor) {
                showMessage('테마 이름과 색상을 입력해주세요!');
                return;
            }
            
            // 테마 생성
            const tuningValue = 0; // 기본값
            currentTheme = themeGenerator.generateTheme(baseColor, themeName, 'accent-on-bg-off', tuningValue);
            
            // 모드 카드 미리보기 업데이트
            updateModeCardPreviews();
            
            // 백엔드에 테마 변수 생성 요청
            parent.postMessage({
                pluginMessage: {
                    type: 'create-custom-theme',
                    theme: currentTheme
                }
            }, '*');
            
            showMessage('테마 변수 생성 중...');
            
            // 잠시 후 Step 3로 바로 진행
            setTimeout(() => {
                generateWizardTheme(); // 토큰 미리보기 생성
                updateProgressBar(3);
                updateStepContent(3);
                currentWizardStep = 3;
                showMessage('테마 변수가 생성되었습니다!');
            }, 1000);
        }

        function generateWizardTheme() {
            
            // currentTheme가 이미 생성되어 있다면 그것을 사용
            if (currentTheme) {
                const themeName = currentTheme.themeName;
                const closestStep = currentTheme.selectedStep || 200;
                
                // Step 2가 제거되었으므로 토큰 미리보기 업데이트 생략

                // wizardThemeData와 동기화
                wizardThemeData = {
                    themeName: themeName,
                    baseColor: currentTheme.baseColor,
                    closestStep: closestStep,
                    applicationMode: currentTheme.applicationMode || 'accent-on-bg-off'
                };
            } else {
                // 기존 로직 (fallback)
                const themeName = document.getElementById('wizardThemeNameInput').value;
                const baseColor = document.getElementById('wizardThemeBaseHex').value;
                
                // Scale Generator와 동일한 로직 사용
                const closestStep = ColorUtils.findClosestStep(baseColor, 'light');
                

                wizardThemeData = {
                    themeName: themeName,
                    baseColor: baseColor,
                    closestStep: closestStep,
                    applicationMode: 'accent-on-bg-off'
                };
            }
            
        }

        function selectModeCard(card, mode) {
            
            // 모든 카드에서 selected 클래스 제거
            document.querySelectorAll('.mode-card').forEach(c => {
                c.classList.remove('selected');
            });
            
            // 클릭된 카드에 selected 클래스 추가
            card.classList.add('selected');
            
            // 테마 데이터 업데이트
            if (wizardThemeData) {
                wizardThemeData.applicationMode = mode;
            }
        }

        // 모드별 토큰 미리보기 업데이트
        function updateModeCardPreviews() {
            if (!currentTheme) return;
            
            
            const modes = ['accent-on-bg-off', 'accent-off-bg-on', 'accent-on-bg-fixed', 'accent-on-bg-black'];
            
            modes.forEach(mode => {
                const tokens = getTokensForMode(mode);
                updateModeCardPreview(mode, tokens);
            });
        }
        
        // 특정 모드의 토큰값 계산 (밝기 기준에 따른 매핑 규칙 적용)
        function getTokensForMode(mode) {
            if (!currentTheme || !currentTheme.scaleColors) return null;
            
            const lightColors = currentTheme.scaleColors.light;
            const darkColors = currentTheme.scaleColors.dark;
            const selectedStep = currentTheme.selectedStep || 500;
            
            // 밝기 기준 (백엔드 getDynamicMappings와 동일한 로직)
            let isBrightColor = selectedStep < 200; // 200 미만
            if (currentTheme.baseColor) {
                const hsl = ColorUtils.hexToHsl(currentTheme.baseColor);
                const lightness = hsl[2];
                // 밝기가 80% 이상이면 bright color로 분류
                if (lightness >= 80) {
                    isBrightColor = true;
                }
            }
            
            let backgroundLight, textPrimaryLight, fillPrimaryLight;
            
            switch(mode) {
                case 'accent-on-bg-off':
                    // forground 중심: 배경 고정, 텍스트와 fill이 accent
                    backgroundLight = '#FFFFFF';
                    if (isBrightColor) {
                        textPrimaryLight = lightColors.find(c => c.step === 900)?.hex || '#000000';
                        fillPrimaryLight = lightColors.find(c => c.step === 600)?.hex;
                    } else {
                        textPrimaryLight = lightColors.find(c => c.step === selectedStep)?.hex;
                        fillPrimaryLight = lightColors.find(c => c.step === selectedStep)?.hex;
                    }
                    break;
                    
                case 'accent-off-bg-on':
                    // background 중심: 배경이 accent, 텍스트와 fill은 contrasting
                    backgroundLight = lightColors.find(c => c.step === selectedStep)?.hex;
                    if (isBrightColor) {
                        textPrimaryLight = lightColors.find(c => c.step === 900)?.hex || '#000000';
                        fillPrimaryLight = lightColors.find(c => c.step === 800)?.hex;
                    } else {
                        textPrimaryLight = '#FFFFFF';
                        fillPrimaryLight = lightColors.find(c => c.step === 50)?.hex;
                    }
                    break;
                    
                case 'accent-on-bg-fixed':
                    // forground 중심, white bg 고정
                    backgroundLight = '#FFFFFF';
                    if (isBrightColor) {
                        textPrimaryLight = lightColors.find(c => c.step === 900)?.hex || '#000000';
                        fillPrimaryLight = lightColors.find(c => c.step === 600)?.hex;
                    } else {
                        textPrimaryLight = lightColors.find(c => c.step === selectedStep)?.hex;
                        fillPrimaryLight = lightColors.find(c => c.step === selectedStep)?.hex;
                    }
                    break;
                    
                case 'accent-on-bg-black':
                    // forground 중심, black bg 고정 (백엔드와 동일한 로직)
                    backgroundLight = '#1f1f1f';
                    // 실제 GRAY:50 색상 사용 (Light Mode gray scale의 50번째)
                    const colorGenerator = new ColorGenerator();
                    textPrimaryLight = colorGenerator.lightModeGrayTones[0]; // 50번째 = index 0 = '#FFFFFF'
                    if (isBrightColor) {
                        fillPrimaryLight = lightColors.find(c => c.step === selectedStep)?.hex;
                    } else {
                        fillPrimaryLight = lightColors.find(c => c.step === selectedStep)?.hex;
                    }
                    break;
            }
            
            
            // fillSurfaceContents는 항상 연한 회색 계열 (50-100 단계)
            const fillSurfaceContentsLight = lightColors.find(c => c.step === 50)?.hex || '#f9fafb';
            
            return {
                background: backgroundLight,
                textPrimary: textPrimaryLight,
                fillPrimary: fillPrimaryLight,
                fillSurfaceContents: fillSurfaceContentsLight
            };
        }
        
        // 모드 카드 미리보기 업데이트
        function updateModeCardPreview(mode, tokens) {
            if (!tokens) return;
            
            const card = document.querySelector(`[data-mode="${mode}"]`);
            if (!card) return;
            
            const previewFrame = card.querySelector('.preview-frame');
            const frameHeader = card.querySelector('.frame-header');
            const frameButton = card.querySelector('.frame-button');
            
            // 모든 모드의 mode-card 자체에 배경색 적용
            card.style.backgroundColor = tokens.background;
            
            // 텍스트 색상 적용 (로고)
            if (frameHeader) {
                const svgPaths = frameHeader.querySelectorAll('svg path');
                svgPaths.forEach(path => {
                    path.setAttribute('fill', tokens.textPrimary);
                    path.style.setProperty('fill', tokens.textPrimary, 'important');
                });
            }
            
            // 버튼 색상 적용
            if (frameButton) {
                frameButton.style.backgroundColor = tokens.fillPrimary;
            }
            
            // content-block 색상 적용 (semantic-fill-surface-contents 미리보기)
            const contentBlocks = card.querySelectorAll('.content-block');
            contentBlocks.forEach(block => {
                block.style.backgroundColor = tokens.fillSurfaceContents || '#f1f5f9';
            });
            
            // 카드 라벨 텍스트 색상 고정 (카드 밖으로 나왔으므로 검은색 고정)
            const cardLabel = card.querySelector('.card-label');
            const cardSubLabel = card.querySelector('.card-sub-label');
            if (cardLabel) {
                cardLabel.style.setProperty('color', '#000000', 'important');
            }
            if (cardSubLabel) {
                cardSubLabel.style.setProperty('color', '#000000', 'important');
            }
        }

        // 현재 입력된 색상을 기반으로 모든 모드 카드의 미리보기를 실시간 업데이트하는 함수
        function updateAllModePreviewsWithColor(baseColor) {
            if (!baseColor || !baseColor.startsWith('#')) {
                return;
            }
            
            
            // 각 모드에 대해 색상 토큰 계산 및 미리보기 업데이트
            const modes = ['accent-on-bg-off', 'accent-on-bg-fixed', 'accent-off-bg-on', 'accent-on-bg-black'];
            
            modes.forEach(mode => {
                const tokens = calculatePreviewTokensForMode(baseColor, mode);
                if (tokens) {
                    updateModeCardPreview(mode, tokens);
                }
            });
        }

        // 각 모드별로 미리보기용 색상 토큰을 계산하는 함수
        function calculatePreviewTokensForMode(baseColor, mode) {
            if (!baseColor) return null;
            
            // HSL 변환 함수들이 없다면 간단한 구현
            const hsl = ColorUtils.hexToHsl ? ColorUtils.hexToHsl(baseColor) : hexToHsl(baseColor);
            const lightness = hsl[2];
            const hue = hsl[0];
            
            // 밝은 색상 판단: 1) 밝기 80% 이상 또는 2) BornBright 색상 (Hue 40°-190°)
            const isLightColor = lightness >= 80 || (hue >= 40 && hue <= 190);
            
            let tokens = {
                background: '#ffffff',
                textPrimary: '#000000',
                fillPrimary: baseColor
            };
            
            switch (mode) {
                case 'accent-on-bg-off':
                    if (isLightColor) {
                        // 밝은 색상일 때: 색상 기반의 어두운 배경에 밝은 텍스트
                        tokens.background = adjustColorLightness(baseColor, 20);
                        tokens.textPrimary = '#ffffff';
                        tokens.fillPrimary = baseColor;
                    } else {
                        // 어두운 색상일 때: 색상 기반의 밝은 배경에 어두운 텍스트
                        tokens.background = adjustColorLightness(baseColor, 95);
                        tokens.textPrimary = '#000000';
                        tokens.fillPrimary = baseColor;
                    }
                    break;
                    
                case 'accent-on-bg-fixed':
                    // 항상 흰 배경
                    tokens.background = '#ffffff';
                    tokens.textPrimary = '#000000';
                    tokens.fillPrimary = baseColor;
                    break;
                    
                case 'accent-off-bg-on':
                    // 배경에 메인 색상 사용
                    tokens.background = baseColor;
                    tokens.textPrimary = getContrastTextColor(baseColor);
                    tokens.fillPrimary = getLighterShade(baseColor);
                    break;
                    
                case 'accent-on-bg-black':
                    // 항상 검은 배경
                    tokens.background = '#1f1f1f';
                    tokens.textPrimary = '#ffffff';
                    tokens.fillPrimary = baseColor;
                    break;
            }
            
            return tokens;
        }

        // 색상의 명도를 조정하는 헬퍼 함수
        function adjustColorLightness(hex, targetLightness) {
            const hsl = ColorUtils.hexToHsl ? ColorUtils.hexToHsl(hex) : hexToHsl(hex);
            return ColorUtils.hslToHex ? ColorUtils.hslToHex(hsl[0], hsl[1], targetLightness) : hslToHex(hsl[0], hsl[1], targetLightness);
        }

        // 배경 색상에 대한 적절한 텍스트 색상을 반환하는 함수
        function getContrastTextColor(backgroundColor) {
            const hsl = ColorUtils.hexToHsl ? ColorUtils.hexToHsl(backgroundColor) : hexToHsl(backgroundColor);
            return hsl[2] > 50 ? '#000000' : '#ffffff';
        }

        // 더 밝은 색조를 생성하는 함수
        function getLighterShade(baseColor) {
            const hsl = ColorUtils.hexToHsl ? ColorUtils.hexToHsl(baseColor) : hexToHsl(baseColor);
            const lighterLightness = Math.min(hsl[2] + 30, 90);
            const reducedSaturation = Math.max(hsl[1] - 20, 30);
            return ColorUtils.hslToHex ? ColorUtils.hslToHex(hsl[0], reducedSaturation, lighterLightness) : hslToHex(hsl[0], reducedSaturation, lighterLightness);
        }

        // 밝은 색상 판단 함수 (코드베이스의 isLightRange와 동일한 로직)
        function isLightColor(hex) {
            if (!hex || !hex.startsWith('#')) return false;
            
            const hsl = ColorUtils.hexToHsl ? ColorUtils.hexToHsl(hex) : hexToHsl(hex);
            const lightness = hsl[2];
            const hue = hsl[0];
            
            // 1) HSL 밝기 기준: 80% 이상
            if (lightness >= 80) return true;
            
            // 2) BornBright 색상: Hue 40°-190° (노랑~청록 계열)
            if (hue >= 40 && hue <= 190) return true;
            
            return false;
        }

        // 색상 분류 정보를 반환하는 함수
        function getColorClassification(hex) {
            if (!hex || !hex.startsWith('#')) return null;
            
            const hsl = ColorUtils.hexToHsl ? ColorUtils.hexToHsl(hex) : hexToHsl(hex);
            const lightness = hsl[2];
            const hue = hsl[0];
            const isLight = isLightColor(hex);
            
            let reasons = [];
            if (lightness >= 80) reasons.push(`밝기 ${Math.round(lightness)}%`);
            if (hue >= 40 && hue <= 190) reasons.push('본질적 밝은 색상 (노랑~청록 계열)');
            
            return {
                isLight: isLight,
                lightness: Math.round(lightness),
                hue: Math.round(hue),
                reasons: reasons,
                classification: isLight ? '밝은 범위' : '어두운 범위'
            };
        }

        // 색상 분류 정보 표시 업데이트 함수
        function updateColorClassificationDisplay(hex) {
            const classificationInfo = getColorClassification(hex);
            if (!classificationInfo) return;
            
            const classificationResult = document.getElementById('classificationResult');
            const lightnessValue = document.getElementById('lightnessValue');
            const hueValue = document.getElementById('hueValue');
            const classificationReasons = document.getElementById('classificationReasons');
            
            if (classificationResult) {
                classificationResult.textContent = classificationInfo.classification;
                classificationResult.className = `classification-result ${classificationInfo.isLight ? 'bright' : 'dark'}`;
            }
            
            if (lightnessValue) {
                lightnessValue.textContent = classificationInfo.lightness;
            }
            
            if (hueValue) {
                hueValue.textContent = classificationInfo.hue;
            }
            
            if (classificationReasons) {
                if (classificationInfo.reasons.length > 0) {
                    classificationReasons.textContent = '분류 근거: ' + classificationInfo.reasons.join(', ');
                    classificationReasons.style.display = 'block';
                } else {
                    classificationReasons.style.display = 'none';
                }
            }
        }

        // HSL 변환 함수들 (ColorUtils가 없는 경우 대비)
        function hexToHsl(hex) {
            const r = parseInt(hex.slice(1, 3), 16) / 255;
            const g = parseInt(hex.slice(3, 5), 16) / 255;
            const b = parseInt(hex.slice(5, 7), 16) / 255;

            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }

            return [h * 360, s * 100, l * 100];
        }

        function hslToHex(h, s, l) {
            h = h % 360;
            if (h < 0) h += 360;
            s = Math.max(0, Math.min(100, s));
            l = Math.max(0, Math.min(100, l));
            
            h /= 360;
            s /= 100;
            l /= 100;
            
            const a = s * Math.min(l, 1 - l);
            const f = n => {
                const k = (n + h * 12) % 12;
                return l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
            };
            
            const r = Math.round(f(0) * 255);
            const g = Math.round(f(8) * 255);
            const b = Math.round(f(4) * 255);
            
            return "#" + [r, g, b].map(x => {
                const hex = x.toString(16);
                return hex.length === 1 ? "0" + hex : hex;
            }).join("");
        }

        function applyCustomTheme() {
            if (!currentTheme && !wizardThemeData) {
                showMessage('먼저 테마를 생성해주세요!');
                return;
            }

            // 현재 선택된 모드로 테마 업데이트
            const selectedMode = document.querySelector('.mode-card.selected')?.dataset.mode || 'accent-on-bg-off';
            
            let themeToApply;
            if (currentTheme) {
                // currentTheme 사용 (이미 변수가 생성된 경우)
                themeToApply = {
                    ...currentTheme,
                    applicationMode: selectedMode
                };
            } else {
                // wizardThemeData 사용 (fallback)
                themeToApply = {
                    themeName: wizardThemeData.themeName,
                    baseColor: wizardThemeData.baseColor,
                    applicationMode: selectedMode,
                    scaleColors: { light: generateScaleColors(wizardThemeData.baseColor) }
                };
            }

            parent.postMessage({
                pluginMessage: {
                    type: 'apply-theme-colors-to-frame',
                    theme: themeToApply
                }
            }, '*');
            
            // 적용하기 후 annotation 자동 활성화
            const annotationCheckbox = document.getElementById('annotationToggle');
            if (annotationCheckbox) {
                // 체크박스 활성화 및 체크
                annotationCheckbox.disabled = false;
                annotationCheckbox.checked = true;
                
                // 라벨 텍스트 업데이트
                const labelSpan = annotationCheckbox.parentElement.querySelector('span');
                if (labelSpan) {
                    labelSpan.textContent = '선택된 요소의 색상 매핑 표시';
                    labelSpan.style.color = '#333';
                }
                
                toggleAnnotation(); // annotation 활성화 함수 호출
            }
            
            showMessage('Custom Theme 적용 중...');
        }

        function generateScaleColors(baseColor) {
            // 기존 ScaleColorGenerator 로직 사용
            const generator = new ScaleColorGenerator();
            return generator.generate(baseColor, 'light');
        }


        // Custom Theme 생성기 
        class CustomThemeGenerator {
            constructor() {
                // 고정 매핑만 남기기 (preserve tokens)
                this.fixedMappings = {
                    'fill/surface-floating': { light: 900, dark: 900 },
                    'fill/surface-dialog': { light: 50, dark: 75 },
                    'fill/surface-sheet': { light: 50, dark: 75 },
                    'fill/surface-black': { light: 950, dark: 50 },
                    'background/black': { light: 950, dark: 50 },
                    'common/on-white': { light: 50, dark: 950 },
                    'common/on-white-hover': { light: 75, dark: 900 },
                    'common/on-white-pressed': { light: 75, dark: 900 },
                    'common/on-black': { light: 900, dark: 75 },
                    'common/on-black-hover': { light: 950, dark: 50 },
                    'common/on-black-pressed': { light: 950, dark: 50 },
                    'overlay/dimmed': { light: 700, dark: 700 }
                };
            }

            generateTheme(baseHex, themeName, applicationMode, tuningValue = 0) {
                var colorGenerator = new ColorGenerator();
                var lightColors = colorGenerator.generateColors(baseHex, 'light', tuningValue);
                var darkColors = colorGenerator.generateColors(baseHex, 'dark', tuningValue);
                
                // 입력 색상의 명도로 closest step 찾기
                var inputHsl = ColorUtils.hexToHsl(baseHex);
                var inputLightness = inputHsl[2];
                var closestStepLight = this.findClosestStep(lightColors, inputLightness);
                var closestStepDark = this.findClosestStep(darkColors, inputLightness);
                
                // 테마 객체 생성 (백엔드 형식과 일치)
                return {
                    themeName,
                    baseColor: baseHex,
                    applicationMode,
                    selectedStep: closestStepLight,
                    scaleColors: { 
                        light: lightColors, 
                        dark: darkColors 
                    },
                    // semanticTokens는 백엔드에서 처리하므로 빈 배열
                    semanticTokens: []
                };
            }
            
            findClosestStep(colors, inputLightness) {
                var closestStep = 500;
                var minDifference = Infinity;
                
                colors.forEach(color => {
                    var colorLightness = ColorUtils.hexToHsl(color.hex)[2];
                    var diff = Math.abs(inputLightness - colorLightness);
                    
                    if (diff < minDifference) {
                        minDifference = diff;
                        closestStep = color.step;
                    }
                });
                
                return closestStep;
            }
        }

        // 인스턴스 생성
        var colorGenerator = new ColorGenerator();
        var themeGenerator = new CustomThemeGenerator();

        // 탭 전환 함수
        function switchTab(tabName) {
            console.log('switchTab called with:', tabName);
            const tabNavigation = document.querySelector('.tab-navigation');
            
            // 모든 탭 버튼 비활성화
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // 모든 탭 콘텐츠 숨기기
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // 슬라이딩 애니메이션을 위한 클래스 제거
            tabNavigation.classList.remove('second-active', 'third-active');
            
            if (tabName === 'generator') {
                document.getElementById('generatorTab').classList.add('active');
                document.getElementById('generatorContent').classList.add('active');
                tabNavigation.classList.add('second-active');
            } else if (tabName === 'tone-matching') {
                document.getElementById('toneMatchingTab').classList.add('active');
                document.getElementById('toneMatchingContent').classList.add('active');
                tabNavigation.classList.add('third-active');
            } else if (tabName === 'custom-theme') {
                document.getElementById('customThemeTab').classList.add('active');
                document.getElementById('customThemeContent').classList.add('active');
                // 첫 번째 탭이므로 기본 위치 (클래스 추가 안 함)
                
                // Custom Theme 탭 전환 시 색상 동기화 리스너 다시 설정
                setTimeout(() => {
                    setupWizardColorSync();
                }, 100);
            }
        }

        // Wizard 색상 동기화 설정 함수
        function setupWizardColorSync() {
            
            const wizardBaseColor = document.getElementById('wizardThemeBaseColor');
            const wizardBaseHex = document.getElementById('wizardThemeBaseHex');
            
            
            if (wizardBaseColor && wizardBaseHex) {
                
                // 기존 리스너 제거 (중복 방지)
                wizardBaseColor.removeEventListener('input', handleColorPickerChange);
                wizardBaseHex.removeEventListener('input', handleHexInputChange);
                
                // 새 리스너 추가
                wizardBaseColor.addEventListener('input', handleColorPickerChange);
                wizardBaseHex.addEventListener('input', handleHexInputChange);
                
                // 테스트용 클릭 리스너도 추가
                wizardBaseColor.addEventListener('change', () => {
                });
                
                // 초기 색상에 대한 분류 정보 표시
                const initialColor = wizardBaseColor.value || wizardBaseHex.value;
                if (initialColor) {
                    updateWizardStepIndicator(initialColor);
                }
                
            } else {
                console.error('❌ Wizard color elements not found!');
                document.querySelectorAll('[id*="wizard"]').forEach(el => {
                });
            }
        }

        function handleColorPickerChange() {
            const wizardBaseColor = document.getElementById('wizardThemeBaseColor');
            const wizardBaseHex = document.getElementById('wizardThemeBaseHex');
            
            if (wizardBaseColor && wizardBaseHex) {
                const oldHexValue = wizardBaseHex.value;
                const newColorValue = wizardBaseColor.value.toUpperCase();
                
                
                wizardBaseHex.value = newColorValue;
                
                // 모드 카드 미리보기 업데이트
                updateAllModePreviewsWithColor(newColorValue);
                
                // 색상 분류 정보 업데이트
                updateWizardStepIndicator(newColorValue);
                
            } else {
                console.error('❌ Elements not found in handleColorPickerChange');
            }
        }

        function handleHexInputChange() {
            const wizardBaseColor = document.getElementById('wizardThemeBaseColor');
            const wizardBaseHex = document.getElementById('wizardThemeBaseHex');
            
            if (wizardBaseColor && wizardBaseHex) {
                const hexValue = wizardBaseHex.value;
                
                if (/^#[0-9A-F]{6}$/i.test(hexValue)) {
                    const oldColorValue = wizardBaseColor.value;
                    wizardBaseColor.value = hexValue;
                    
                    // 모드 카드 미리보기 업데이트
                    updateAllModePreviewsWithColor(hexValue);
                    
                    // 색상 분류 정보 업데이트
                    updateWizardStepIndicator(hexValue);
                    
                } else {
                    console.warn('⚠️ Invalid hex format:', hexValue);
                }
            } else {
                console.error('❌ Elements not found in handleHexInputChange');
            }
        }

        // 모드 설정 함수
        function setMode(mode) {
            currentMode = mode;
            
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            event.target.classList.add('active');
            updateDisplay();
        }

        // 디스플레이 업데이트
        function updateDisplay() {
            var baseColor = document.getElementById('baseColor');
            if (!baseColor) return;

            var inputHex = baseColor.value;
            var tuningVal = 0;
            
            console.log('updateDisplay called with:', inputHex);
            
            // Fine Tuning 값 가져오기
            if (document.getElementById('autoTuning').checked) {
                tuningVal = colorGenerator.getAutoTuningValue(inputHex);
                document.getElementById('tuningSlider').value = tuningVal;
                document.getElementById('tuningValue').textContent = tuningVal;
            } else {
                tuningVal = parseInt(document.getElementById('tuningSlider').value) || 0;
            }
            
            console.log('Generating colors with tuningVal:', tuningVal);
            
            // tuning 값을 포함하여 색상 생성
            try {
                generatedColors = colorGenerator.generateColors(inputHex, currentMode, tuningVal);
                console.log('Generated colors:', generatedColors);
            } catch (error) {
                console.error('Error generating colors:', error);
                return;
            }
            
            displayColors();
        }

        // 색상 표시
        function displayColors() {
            var container = document.getElementById('colorResults');
            console.log('displayColors called, container found:', !!container);
            console.log('generatedColors length:', generatedColors.length);
            
            if (!container) return;

            container.innerHTML = '';
            
            generatedColors.forEach(color => {
                console.log('Creating row for color:', color);
                var row = createColorRow(color);
                container.appendChild(row);
            });
        }

        // 색상 행 생성
        function createColorRow(color) {
            var row = document.createElement('div');
            row.className = color.isClosest ? 'color-row closest' : 'color-row';
            
            var rgb = ColorUtils.hexToRgb(color.hex);
            var textColor = ColorUtils.getLuminance(rgb.r, rgb.g, rgb.b) > 0.5 ? '#000' : '#fff';
            
            // 접근성 배지 추가
            var badge = '';
            if (color.contrast >= 7) {
                badge = '<span style="background: #28a745; color: white; padding: 1px 4px; border-radius: 2px; font-size: 7px; margin-left: 4px;">AAA</span>';
            } else if (color.contrast >= 4.5) {
                badge = '<span style="background: #ffc107; color: black; padding: 1px 4px; border-radius: 2px; font-size: 7px; margin-left: 4px;">AA</span>';
            } else if (color.contrast >= 3) {
                badge = '<span style="background: #fd7e14; color: white; padding: 1px 4px; border-radius: 2px; font-size: 7px; margin-left: 4px;">A</span>';
            }
            
            row.innerHTML = `
                <div class="color-swatch" style="background: ${color.hex}; color: ${textColor}">
                    ${color.step}${color.isClosest ? ' ★' : ''}
                </div>
                <div class="color-info">
                    <span class="color-hex" onclick="copyColor('${color.hex}')">${color.hex.toUpperCase()}</span>
                    <span>${color.contrast.toFixed(2)}:1 ${badge}</span>
                </div>
            `;
            
            return row;
        }

        // 스텝 분류 표시 업데이트 (Scale Generator용)
        function updateStepIndicator(hex) {
            var stepIndicator = document.getElementById('stepIndicator');
            var classificationBadge = document.getElementById('classificationBadge');
            var classificationInfo = document.getElementById('stepClassificationInfo');
            var classificationText = document.getElementById('stepClassificationText');
            
            if (!stepIndicator || !classificationBadge) return;
            
            // ColorGenerator에서 생성된 색상들과 일치시키기
            var colors = colorGenerator.generateColors(hex, 'light', 0);
            var closestColor = colors.find(color => color.isClosest);
            var closestStep = closestColor ? closestColor.step : 500;
            var colorRange = getColorRangeFromStep(closestStep, hex);
            
            stepIndicator.textContent = `Step: ${closestStep}`;
            
            if (colorRange === 'light') {
                stepIndicator.className = 'step-indicator step-light';
                classificationBadge.textContent = '밝음';
                classificationBadge.className = 'classification-badge classification-light';
                
                if (classificationInfo) classificationInfo.style.display = 'block';
                if (classificationText) classificationText.textContent = `입력 색상이 Step ${closestStep}에 해당합니다. 밝은 범위로 분류되어 Mode별로 다른 매핑이 적용됩니다.`;
            } else if (colorRange === 'medium') {
                stepIndicator.className = 'step-indicator step-medium';
                classificationBadge.textContent = '중간';
                classificationBadge.className = 'classification-badge classification-medium';
                
                if (classificationInfo) classificationInfo.style.display = 'block';
                if (classificationText) classificationText.textContent = `입력 색상이 Step ${closestStep}에 해당합니다. 중간 범위로 분류되어 Mode별로 다른 매핑이 적용됩니다.`;
            } else {
                stepIndicator.className = 'step-indicator step-dark';
                classificationBadge.textContent = '어두움';
                classificationBadge.className = 'classification-badge classification-dark';
                
                if (classificationInfo) classificationInfo.style.display = 'block';
                if (classificationText) classificationText.textContent = `입력 색상이 Step ${closestStep}에 해당합니다. 어두운 범위로 분류되어 Mode별로 다른 매핑이 적용됩니다.`;
            }
        }

        // 스텝 분류 표시 업데이트 (Custom Theme Wizard용)
        function updateWizardStepIndicator(hex) {
            var stepIndicator = document.getElementById('wizardStepIndicator');
            var classificationBadge = document.getElementById('wizardClassificationBadge');
            var classificationInfo = document.getElementById('wizardStepClassificationInfo');
            var classificationText = document.getElementById('wizardStepClassificationText');
            
            if (!stepIndicator || !classificationBadge) return;
            
            // ColorGenerator에서 생성된 색상들과 일치시키기
            var colors = colorGenerator.generateColors(hex, 'light', 0);
            var closestColor = colors.find(color => color.isClosest);
            var closestStep = closestColor ? closestColor.step : 500;
            var colorRange = getColorRangeFromStep(closestStep, hex);
            
            stepIndicator.textContent = `Step: ${closestStep}`;
            
            if (colorRange === 'light') {
                stepIndicator.className = 'step-indicator step-light';
                classificationBadge.textContent = '밝음';
                classificationBadge.className = 'classification-badge classification-light';
                
                if (classificationInfo) classificationInfo.style.display = 'block';
                if (classificationText) classificationText.textContent = `입력 색상이 Step ${closestStep}에 해당합니다. 밝은 범위로 분류되어 Mode별로 다른 매핑이 적용됩니다.`;
            } else if (colorRange === 'medium') {
                stepIndicator.className = 'step-indicator step-medium';
                classificationBadge.textContent = '중간';
                classificationBadge.className = 'classification-badge classification-medium';
                
                if (classificationInfo) classificationInfo.style.display = 'block';
                if (classificationText) classificationText.textContent = `입력 색상이 Step ${closestStep}에 해당합니다. 중간 범위로 분류되어 Mode별로 다른 매핑이 적용됩니다.`;
            } else {
                stepIndicator.className = 'step-indicator step-dark';
                classificationBadge.textContent = '어두움';
                classificationBadge.className = 'classification-badge classification-dark';
                
                if (classificationInfo) classificationInfo.style.display = 'block';
                if (classificationText) classificationText.textContent = `입력 색상이 Step ${closestStep}에 해당합니다. 어두운 범위로 분류되어 Mode별로 다른 매핑이 적용됩니다.`;
            }
        }

        function generateCustomTheme() {
            var baseColor = document.getElementById('themeBaseColor').value;
            var themeName = document.getElementById('themeNameInput').value || 'brand-theme';
            var applicationMode = document.querySelector('input[name="applicationMode"]:checked').value;
            
            // Fine Tuning 값 가져오기
            var tuningValue = document.getElementById('autoTuning').checked ? 
                colorGenerator.getAutoTuningValue(baseColor) :
                parseInt(document.getElementById('tuningSlider').value) || 0;
            
            
            // themeGenerator에 tuning 값 전달
            currentTheme = themeGenerator.generateTheme(baseColor, themeName, applicationMode, tuningValue);
            
            // 모드 카드 미리보기 업데이트
            updateModeCardPreviews();
            
            displayThemePreview(currentTheme);
            
            showMessage(`${themeName} 테마가 생성되었습니다!`);
        }

            function displayThemePreview(theme) {
                var container = document.getElementById('themePreviewContainer');
                
                let modeDescription = '';
                if (theme.applicationMode === 'accent-on-bg-off') {
                    modeDescription = 'Mode 1: 강조 요소 ON / 배경 요소 OFF';
                } else if (theme.applicationMode === 'accent-on-bg-fixed') {
                    modeDescription = 'Mode 2: 강조 요소 ON / 배경 Light 고정';
                } else if (theme.applicationMode === 'accent-off-bg-on') {
                    modeDescription = 'Mode 3: 강조 요소 OFF / 배경 요소 ON';
                } else if (theme.applicationMode === 'accent-on-bg-black') {
                    modeDescription = 'Mode 4: 강조 요소 ON / 배경 Dark 고정';
                }
                
                container.innerHTML = `
                    <div style="background: #e8f5e8; border: 1px solid #d4edda; border-radius: 4px; padding: 8px; margin-top: 8px;">
                        <p style="font-size: 10px; color: #155724; margin: 0;">
                            <strong>적용된 Mode:</strong> ${modeDescription}<br>
                            <strong>Closest Step:</strong> Light: ${theme.selectedStep || 'N/A'}, Dark: ${theme.selectedStep || 'N/A'}
                        </p>
                    </div>
                    
                    <button class="action-btn btn-success" onclick="createCustomThemeVariables()">
                        모든 테마 변수 생성
                    </button>
                    
                    <div style="margin-top: 8px;">
                        <button class="action-btn btn-secondary" onclick="applyCustomMode('CustomLight')" style="width: 100%;">
                            Custom Theme 적용하기
                        </button>
                    </div>
                `;
            }

        function createCustomThemeVariables() {
            if (!currentTheme) {
                showMessage('먼저 테마를 생성해주세요!');
                return;
            }
            
            
            parent.postMessage({
                pluginMessage: {
                    type: 'create-custom-theme',
                    theme: currentTheme
                }
            }, '*');
            
            showMessage('Custom Theme Variables 생성 중...');
        }

        // Custom Mode 적용 함수
        function applyCustomMode(modeName) {
            
            if (!currentTheme) {
                showMessage('먼저 테마를 생성해주세요!');
                return;
            }
            
            parent.postMessage({
                pluginMessage: {
                    type: 'apply-theme-colors-to-frame',
                    theme: currentTheme
                }
            }, '*');
            
            showMessage('테마 토큰을 Frame에 적용 중...');
        }
        // 아코디언 토글 함수 추가
        function toggleThemePreview() {
        var header = document.getElementById('themePreviewAccordion');
        var content = document.getElementById('themePreviewContent');
        
        header.classList.toggle('active');
        content.classList.toggle('expanded');
        }
        // 색상 복사
        function copyColor(hex) {
            // 클릭된 요소 찾기
            var elements = document.querySelectorAll('.color-hex');
            elements.forEach(function(el) {
                if (el.textContent === hex.toUpperCase()) {
                    el.classList.add('copied');
                    setTimeout(function() {
                        el.classList.remove('copied');
                    }, 500);
                }
            });
            
            navigator.clipboard.writeText(hex).then(function() {
                showMessage(`📋 ${hex} 복사됨!`);
            }).catch(function() {
                showMessage('복사 실패');
            });
        }

        // 변수 생성 함수들
function createVariables() {
    var variableName = document.getElementById('variableName').value.trim();
    
    if (!variableName) {
        showMessage('변수 이름을 입력해주세요!');
        return;
    }
    
    if (generatedColors.length === 0) {
        showMessage('먼저 색상을 생성해주세요!');
        return;
    }

    // Fine Tuning 값 포함
    var tuningValue = document.getElementById('autoTuning').checked ? 
        colorGenerator.getAutoTuningValue(document.getElementById('baseColor').value) :
        parseInt(document.getElementById('tuningSlider').value) || 0;

    parent.postMessage({
        pluginMessage: {
            type: 'create-variables',
            colors: generatedColors,
            variableName: variableName,
            mode: currentMode,
            dualMode: false,
            tuningValue: tuningValue  // 추가
        }
    }, '*');
    
    showMessage('Variables 생성 중...');
}

function createDualModeVariables() {
    var variableName = document.getElementById('variableName').value.trim();
    
    if (!variableName) {
        showMessage('변수 이름을 입력해주세요!');
        return;
    }

    var baseColor = document.getElementById('baseColor').value;
    
    // Fine Tuning 값 포함
    var tuningValue = document.getElementById('autoTuning').checked ? 
        colorGenerator.getAutoTuningValue(baseColor) :
        parseInt(document.getElementById('tuningSlider').value) || 0;
    
    // Light 모드 색상 생성 (tuning 값 포함)
    var lightColors = colorGenerator.generateColors(baseColor, 'light', tuningValue);
    // Dark 모드 색상 생성 (tuning 값 포함)
    var darkColors = colorGenerator.generateColors(baseColor, 'dark', tuningValue);
    
    parent.postMessage({
        pluginMessage: {
            type: 'create-variables',
            lightColors: lightColors,
            darkColors: darkColors,
            variableName: variableName,
            dualMode: true,
            tuningValue: tuningValue  // 추가
        }
    }, '*');
    
    showMessage('Light + Dark Variables 생성 중...');
}

function createStyles() {
    var variableName = document.getElementById('variableName').value.trim() || 'color';
    
    if (generatedColors.length === 0) {
        showMessage('먼저 색상을 생성해주세요!');
        return;
    }

    parent.postMessage({
        pluginMessage: {
            type: 'create-styles',
            colors: generatedColors,
            styleName: variableName,
            mode: currentMode
        }
    }, '*');
    
    showMessage('Color Styles 생성 중...');
}

// 메시지 수신 처리 수정
window.addEventListener('message', (event) => {
    var msg = event.data.pluginMessage;
    if (!msg) return;

    
    switch(msg.type) {
        case 'plugin-ready':
            break;
        case 'variable-created':
            if (msg.success) {
                var modeText = msg.dualMode ? 'Light + Dark' : currentMode;
                showMessage(`✅ ${msg.count}개의 ${modeText} Variables 생성 완료!`);
            } else {
                showMessage('에러: ' + msg.error);
            }
            break;
        case 'style-created':
            if (msg.success) {
                showMessage(`✅ ${msg.count}개의 Color Styles 생성 완료!`);
            } else {
                showMessage('에러: ' + msg.error);
            }
            break;
        case 'custom-theme-created':
            if (msg.success) {
                showMessage(`${msg.themeName} 테마 생성 완료! (${msg.count || 0}개 변수)`);
            } else {
                showMessage('테마 생성 에러: ' + msg.error);
            }
            break;
        case 'custom-mode-applied':
            if (msg.success) {
                var message = msg.modeName + ' 모드 적용 완료!';
                if (msg.cleared && msg.cleared > 0) {
                    message += ' (' + msg.count + '개 적용, ' + msg.cleared + '개 자식 상속)';
                } else {
                    message += ' (' + msg.count + '개 적용)';
                }
                showMessage(message);
            } else {
                showMessage('모드 적용 에러: ' + msg.error);
            }
            break;
        case 'error':
            showMessage('에러: ' + msg.message);
            break;
    }
});

        // 톤 매칭 관련 함수들
        function setReferenceColor() {
            var picker = document.getElementById('referenceColorPicker');
            var hex = document.getElementById('referenceColorHex');
            
            referenceColor = {
                hex: picker.value.toUpperCase(),
                hsl: ColorUtils.hexToHsl(picker.value)
            };
            
            updateReferenceDisplay();
            showMessage('기준 색상이 설정되었습니다!');
        }

        function clearReference() {
            referenceColor = null;
            updateReferenceDisplay();
            clearToneMatchingResults();
            showMessage('기준 색상이 초기화되었습니다.');
        }

        function updateReferenceDisplay() {
            var statusElement = document.getElementById('referenceStatus');
            var displayElement = document.getElementById('referenceDisplay');
            
            if (!referenceColor) {
                statusElement.textContent = '현재 설정된 기준 컬러가 없습니다.';
                statusElement.style.color = '#666';
                displayElement.innerHTML = '';
                return;
            }
            
            statusElement.textContent = `Reference Set: ${referenceColor.hex}`;
            statusElement.style.color = '#28a745';
            
            var [h, s, l] = referenceColor.hsl;
            displayElement.innerHTML = `
                <div class="reference-display">
                    <div class="reference-color" style="background: ${referenceColor.hex};"></div>
                    <div class="reference-info">
                        <h4>Reference Active</h4>
                        <p><strong>${referenceColor.hex}</strong></p>
                        <p>HSL(${Math.round(h)}°, ${Math.round(s)}%, ${Math.round(l)}%)</p>
                    </div>
                </div>
            `;
        }

        function generateToneMatching() {
            if (!referenceColor) {
                showMessage('먼저 기준 색상을 설정해주세요!');
                return;
            }
            
            var newColorHex = document.getElementById('newColorPicker').value;
            
            // 백엔드에 톤 매칭 요청
            parent.postMessage({
                pluginMessage: {
                    type: 'generate-tone-matching',
                    referenceColor: referenceColor.hex,
                    inputColor: newColorHex
                }
            }, '*');
            
            showMessage('톤 매칭 제안을 생성하는 중...');
        }

        function displayToneMatchingSuggestions(originalHex, suggestions) {
            var container = document.getElementById('toneMatchingResults');
            
            container.innerHTML = `
                <div style="background: white; border: 2px solid #17a2b8; border-radius: 6px; padding: 12px; margin: 8px 0;">
                    <h4 style="color: #17a2b8; margin-bottom: 8px; font-size: 11px;">🎨 Tone Matching Results</h4>
                    <p style="margin-bottom: 8px; font-size: 9px;">
                        Original: <strong>${originalHex.toUpperCase()}</strong><br>
                        → Adjusted to match reference tone:
                    </p>
                    
                    <div class="tone-suggestions">
                        ${suggestions.map((suggestion, index) => `
                            <div class="tone-suggestion" onclick="applyToneToGenerator('${suggestion.hex}')">
                                <div class="tone-color-display" style="background: ${suggestion.hex};"></div>
                                <div class="tone-suggestion-title">${suggestion.type}</div>
                                <div class="tone-suggestion-hex">${suggestion.hex.toUpperCase()}</div>
                                <div class="tone-suggestion-desc">${suggestion.explanation}</div>
                            </div>
                        `).join('')}
                    </div>
                </div>
                
                <div class="info-box">
                    <h5>💡 Tone Matching:</h5>
                    <p>• 제안은 기준 색상의 톤과 매칭됩니다.<br>
                    • 색상을 클릭하면 Scale Generator에 적용됩니다.<br>
                    • 일관된 브랜드 톤으로 13단계 스케일 생성이 가능합니다.</p>
                </div>
            `;
        }

        function applyToneToGenerator(hex) {
            switchTab('generator');
            document.getElementById('baseColor').value = hex;
            document.getElementById('hexInput').value = hex.toUpperCase();
            updateDisplay();
            showMessage(`${hex} 색상이 Generator에 적용되었습니다!`);
        }

        function clearToneMatchingResults() {
            var container = document.getElementById('toneMatchingResults');
            if (container) container.innerHTML = '';
        }

        // 메시지 표시
        function showMessage(message) {
            var el = document.getElementById('successMessage');
            if (el) {
                el.textContent = message;
                el.classList.add('show');
                setTimeout(() => el.classList.remove('show'), 3000);
            }
        }

        // 이벤트 리스너 설정
        function setupEventListeners() {

            // 탭 버튼들
            const generatorTab = document.getElementById('generatorTab');
            const toneMatchingTab = document.getElementById('toneMatchingTab');
            const customThemeTab = document.getElementById('customThemeTab');
            
            if (generatorTab) {
                generatorTab.addEventListener('click', () => {
                    console.log('Generator tab clicked');
                    switchTab('generator');
                });
            } else {
                console.warn('generatorTab not found');
            }
            
            if (toneMatchingTab) {
                toneMatchingTab.addEventListener('click', () => {
                    console.log('Tone matching tab clicked');
                    switchTab('tone-matching');
                });
            } else {
                console.warn('toneMatchingTab not found');
            }
            
            if (customThemeTab) {
                customThemeTab.addEventListener('click', () => {
                    console.log('Custom theme tab clicked');
                    switchTab('custom-theme');
                });
            } else {
                console.warn('customThemeTab not found');
            }

            // 색상 입력
            var baseColor = document.getElementById('baseColor');
            var hexInput = document.getElementById('hexInput');

            if (baseColor && hexInput) {
                baseColor.addEventListener('input', () => {
                    hexInput.value = baseColor.value.toUpperCase();
                    updateDisplay();
                    updateStepIndicator(baseColor.value);
                    // 모드 미리보기도 업데이트
                    if (document.getElementById('wizardStep3').classList.contains('active')) {
                        updateAllModePreviewsWithColor(baseColor.value);
                    }
                });

                hexInput.addEventListener('input', () => {
                    if (/^#[0-9A-F]{6}$/i.test(hexInput.value)) {
                        baseColor.value = hexInput.value;
                        updateDisplay();
                        updateStepIndicator(hexInput.value);
                        // 모드 미리보기도 업데이트
                        if (document.getElementById('wizardStep3').classList.contains('active')) {
                            updateAllModePreviewsWithColor(hexInput.value);
                        }
                    }
                });
            }

            // Fine Tuning 이벤트 리스너
            var autoTuning = document.getElementById('autoTuning');
            var tuningSlider = document.getElementById('tuningSlider');
            var tuningValue = document.getElementById('tuningValue');
            var tuningStatus = document.getElementById('tuningStatus');

            if (autoTuning && tuningSlider && tuningValue && tuningStatus) {
                autoTuning.addEventListener('change', function() {
                if (this.checked) {
                    // Auto 모드
                    var baseColor = document.getElementById('baseColor').value;
                    var autoValue = colorGenerator.getAutoTuningValue(baseColor);
                    tuningSlider.value = autoValue;
                    tuningSlider.disabled = true;
                    tuningValue.textContent = autoValue;
                    tuningStatus.textContent = 'Auto: ' + autoValue;
                    tuningStatus.className = 'auto';
                } else {
                    // Manual 모드
                    tuningSlider.disabled = false;
                    tuningStatus.textContent = 'Manual: ' + tuningSlider.value;
                    tuningStatus.className = '';
                }
                updateDisplay();
            });

                tuningSlider.addEventListener('input', function() {
                    if (!autoTuning.checked) {
                        tuningValue.textContent = this.value;
                        tuningStatus.textContent = 'Manual: ' + this.value;
                        updateDisplay();
                    }
                });
            } else {
                console.warn('Fine Tuning elements not found');
            }

            // 톤 매칭 관련
            const setRefBtn = document.getElementById('setRefBtn');
            const clearRefBtn = document.getElementById('clearRefBtn');
            const getSuggestionsBtn = document.getElementById('getSuggestionsBtn');
            
            if (setRefBtn) {
                setRefBtn.addEventListener('click', setReferenceColor);
            } else {
                console.warn('setRefBtn not found');
            }
            
            if (clearRefBtn) {
                clearRefBtn.addEventListener('click', clearReference);
            } else {
                console.warn('clearRefBtn not found');
            }
            
            if (getSuggestionsBtn) {
                getSuggestionsBtn.addEventListener('click', generateToneMatching);
            } else {
                console.warn('getSuggestionsBtn not found');
            }

            // Reference 색상 입력 동기화
            var refPicker = document.getElementById('referenceColorPicker');
            var refHex = document.getElementById('referenceColorHex');
            
            if (refPicker && refHex) {
                refPicker.addEventListener('input', () => {
                    refHex.value = refPicker.value.toUpperCase();
                });
                
                refHex.addEventListener('input', () => {
                    if (/^#[0-9A-F]{6}$/i.test(refHex.value)) {
                        refPicker.value = refHex.value;
                    }
                });
            } else {
                console.warn('Reference color elements not found');
            }

            // New 색상 입력 동기화
            var newPicker = document.getElementById('newColorPicker');
            var newHex = document.getElementById('newColorHex');
            
            if (newPicker && newHex) {
                newPicker.addEventListener('input', () => {
                    newHex.value = newPicker.value.toUpperCase();
                });
                
                newHex.addEventListener('input', () => {
                    if (/^#[0-9A-F]{6}$/i.test(newHex.value)) {
                        newPicker.value = newHex.value;
                    }
                });
            } else {
                console.warn('New color elements not found');
            }

            // Custom Theme 관련 (구버전)
            var themeBaseColor = document.getElementById('themeBaseColor');
            var themeBaseHex = document.getElementById('themeBaseHex');
            
            if (themeBaseColor && themeBaseHex) {
                themeBaseColor.addEventListener('input', () => {
                    themeBaseHex.value = themeBaseColor.value.toUpperCase();
                    updateStepIndicator(themeBaseColor.value);
                });
                
                themeBaseHex.addEventListener('input', () => {
                    if (/^#[0-9A-F]{6}$/i.test(themeBaseHex.value)) {
                        themeBaseColor.value = themeBaseHex.value;
                        updateStepIndicator(themeBaseHex.value);
                    }
                });
            } else {
                console.warn('Custom Theme (old version) elements not found');
            }

            // Radio button 스타일 업데이트
            document.querySelectorAll('input[name="applicationMode"]').forEach(radio => {
                radio.addEventListener('change', (e) => {
                    document.querySelectorAll('.radio-option').forEach(option => {
                        option.classList.remove('selected');
                    });
                    e.target.parentElement.classList.add('selected');
                });
            });

            // Wizard 이벤트 리스너
            
            // Step 1 색상 입력 동기화
            setupWizardColorSync();
            
            // Mode 카드 클릭 이벤트
            document.querySelectorAll('.mode-card').forEach(card => {
                card.addEventListener('click', () => {
                    const mode = card.dataset.mode;
                    selectModeCard(card, mode);
                });
            });

            // 초기화 완료
        }

        // 플러그인 메시지 수신
        window.addEventListener('message', (event) => {
            var msg = event.data.pluginMessage;
            if (!msg) return;

                    
            switch(msg.type) {
                case 'plugin-ready':
                            break;
                case 'variable-created':
                    if (msg.success) {
                        showMessage(`Variables 생성 완료! (${msg.count || 0}개)`);
                    } else {
                        showMessage('에러: ' + msg.error);
                    }
                    break;
                case 'custom-theme-created':
                    if (msg.success) {
                        showMessage(`${msg.themeName} 테마 생성 완료! (${msg.count || 0}개 변수)`);
                    } else {
                        showMessage('테마 생성 에러: ' + msg.error);
                    }
                    break;
                case 'custom-mode-applied':
                    if (msg.success) {
                        var message = msg.modeName + ' 모드 적용 완료!';
                        if (msg.cleared && msg.cleared > 0) {
                            message += ' (' + msg.count + '개 적용, ' + msg.cleared + '개 자식 상속)';
                        } else {
                            message += ' (' + msg.count + '개 적용)';
                        }
                        showMessage(message);
                    } else {
                        showMessage('모드 적용 에러: ' + msg.error);
                    }
                    break;
                case 'tone-matching-complete':
                    displayToneMatchingSuggestions(msg.originalColor, msg.suggestions);
                    showMessage('톤 매칭 제안이 완료되었습니다!');
                    break;
                case 'tone-matching-error':
                    showMessage('톤 매칭 에러: ' + msg.error);
                    break;
                case 'error':
                    showMessage('에러: ' + msg.message);
                    break;
            }
        });

        // 초기화
        function init() {
            setupEventListeners();
            updateDisplay();
            
            // 초기 컬러 분류 표시
            const baseColor = document.getElementById('baseColor');
            if (baseColor) {
                updateStepIndicator(baseColor.value);
            }
            
            // Custom Theme 탭이 기본이므로 초기화 시에도 wizard 색상 동기화 설정
            setTimeout(() => {
                setupWizardColorSync();
            }, 200);
            
        }
        
        // =====================================
        // Annotation 제어 함수들
        // =====================================
        
        function showMappingInfo() {
            // 현재 테마 정보와 함께 메시지 전송
            parent.postMessage({
                pluginMessage: {
                    type: 'annotation-control',
                    action: 'show-mapping',
                    theme: currentTheme // 현재 테마 정보 포함
                }
            }, '*');
        }
        
        // Mapping 정보 표시 상태 업데이트
        function updateMappingStatus(message, color = '#666') {
            const statusSpan = document.getElementById('mappingStatus');
            if (statusSpan) {
                statusSpan.textContent = message;
                statusSpan.style.color = color;
            }
        }

        // DOM 로드 완료 후 초기화
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }

        // 페이지 로드 완료 후에도 확인
        window.addEventListener('load', () => {
            if (generatedColors.length === 0) {
                updateDisplay();
            }
        });
    </script>