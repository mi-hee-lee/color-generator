<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Generator</title>
    <style>
        /* CSS Variables - Design System */
        :root {
            /* Colors */
            --basicwhite: #ffffff;
            --basicblack: #000000;
            --basicblack-3: #666666;
            --basicblack-8: #333333;
            --basicgray: #f0f0f0;
            --specialblack-1: #e0e0e0;
            --specialblue-3: #e3f2fd;
            --accentblue: #007aff;
            
            /* Primary Color Scale */
            --primary-50: #eff6ff;
            --primary-100: #dbeafe;
            --primary-200: #bfdbfe;
            --primary-300: #93c5fd;
            --primary-400: #60a5fa;
            --primary-500: #3b82f6;
            --primary-600: #2563eb;
            --primary-700: #1d4ed8;
            --primary-800: #1e40af;
            --primary-900: #1e3a8a;
            
            /* Ruler v2 Colors */
            --ruler-v2-scale-custom-theme-150: #dbeafe;
            --ruler-v2-scale-custom-theme-500: #3b82f6;
            --ruler-v2-scale-gray-50: #f9fafb;
            --ruler-v2-scale-gray-800: #1f2937;
            --ruler-v2-scale-gray-950: #030712;
            --ruler-v2-semantic-border-line-selected: #3b82f6;
            --ruler-v2-semantic-fill-primary: #3b82f6;
            --ruler-v2-semantic-fill-surface-contents: #f1f5f9;
            
            /* Typography */
            --body-1-regular-font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            --body-1-regular-font-size: 12px;
            --body-1-regular-font-weight: 400;
            --body-1-regular-line-height: 16px;
            
            --body-1-semi-bold-font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            --body-1-semi-bold-font-size: 12px;
            --body-1-semi-bold-font-weight: 600;
            --body-1-semi-bold-line-height: 16px;
            
            --heading-2-semi-bold-font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            --heading-2-semi-bold-font-size: 14px;
            --heading-2-semi-bold-font-weight: 600;
            --heading-2-semi-bold-line-height: 20px;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: var(--body-1-regular-font-family);
            background: #f5f5f5;
            color: var(--basicblack-8);
            font-size: var(--body-1-regular-font-size);
            line-height: var(--body-1-regular-line-height);
            overflow-x: hidden;
        }

        .container {
            padding: 16px;
            width: 100%;
            max-width: 100%;
            background: var(--basicwhite);
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            margin: 0;
            box-sizing: border-box;
            overflow: hidden;
        }

        /* Tabs */
        .tab-navigation {
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            padding: 0px 16px;
            gap: 16px;
            position: relative;
            width: 352px;
            height: 40px;
            background: #FFFFFF;
            margin-bottom: 16px;
            box-sizing: border-box;
        }
        

        /* Tab */
        .tab-btn {
            display: flex;
            flex-direction: row;
            align-items: center;
            padding: 0px;
            gap: 4px;
            height: 40px;
            flex: none;
            align-self: stretch;
            flex-grow: 0;
            background: transparent;
            border: none;
            cursor: pointer;
        }

        /* Title for active tab */
        .tab-btn.active {
            font-family: 'Inter';
            font-style: normal;
            font-weight: 600;
            font-size: 11px;
            line-height: 16px;
            display: flex;
            align-items: center;
            text-align: center;
            letter-spacing: 0.005em;
            color: #000000;
        }
        
        /* Title for inactive tabs */
        .tab-btn:not(.active) {
            font-family: 'Inter';
            font-style: normal;
            font-weight: 400;
            font-size: 11px;
            line-height: 16px;
            display: flex;
            align-items: center;
            text-align: center;
            letter-spacing: 0.005em;
            color: rgba(0, 0, 0, 0.3);
        }
        
        /* Specific widths for different tabs */
        .tab-btn:nth-child(1) {
            width: 82px;
            order: 0;
        }
        
        .tab-btn:nth-child(2) {
            width: 85px;
            order: 1;
        }
        
        .tab-btn:nth-child(3) {
            width: 78px;
            order: 2;
        }


        .tab-content {
            display: none;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
            overflow: hidden;
        }

        .tab-content.active {
            display: block;
            animation: fadeIn 0.3s ease-in;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
            overflow: hidden;
        }
        

        .section {
            background: var(--basicwhite);
            border-radius: 8px;
            border: 0.5px solid #00000010;
            padding: 12px;
            margin-bottom: 10px;
            box-shadow: 0 6px 4px rgba(0,0,0,0.04);
            box-sizing: border-box;
            width: 100%;
            max-width: 100%;
            overflow: hidden;
        }

        .section-title {
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 8px;
            color: #333;
        }

        .color-input-group {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            width: 100%;
            box-sizing: border-box;
        }

        .color-picker {
            
            
            margin-right: 8px;
            
            
            cursor: pointer;
            background: none;
            flex: auto;
            text-transform: uppercase;

            width: 40px;
            padding: 2px 2px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 11px;
            margin-bottom: 8px;
            background: white;



        }

        .hex-input {
            flex: auto;
            text-transform: uppercase;

            width: 100%;
            padding: 6px 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 11px;
            margin-bottom: 8px;
            background: white;
        }

        .mode-buttons {
            display: flex;
            gap: 4px;
            margin-bottom: 8px;
        }

        .mode-btn {
            flex: 1;
            padding: 6px 8px;
            border: 1px solid var(--specialblack-1);
            border-radius: 4px;
            background: var(--basicwhite);
            color: var(--basicblack-3);
            font-size: 10px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .mode-btn.active {
            background: var(--basicblack);
            color: var(--basicwhite);
            border-color: var(--basicblack);
        }

        .action-btn {
            width: 100%;
            padding: 0px 12px;
            height: 32px;
            border: none;
            border-radius: 3px;
            font-family: var(--body-1-semi-bold-font-family);
            font-size: var(--body-1-semi-bold-font-size);
            font-weight: var(--body-1-semi-bold-font-weight);
            cursor: pointer;
            transition: background-color 0.2s;
            margin-top: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .btn-primary {
            background: var(--basicblack);
            color: var(--basicwhite);
        }

        .btn-primary:hover {
            background: var(--basicblack);
        }

        .btn-secondary {
            background: var(--basicgray);
            color: var(--basicblack);
        }

        .btn-secondary:hover {
            background: var(--basicgray);
            color: var(--basicblack);
        }

        .btn-success {
            background: var(--accentblue);
            color: var(--basicwhite)
        }

        .btn-success:hover {
            background: var(--accentblue);
            color: var(--basicwhite)
        }

        .color-grid {
            display: flex;
            flex-direction: column;
            gap: 3px;
            max-height: 300px;
            overflow-y: auto;
        }

        .color-row {
            display: flex;
            border-radius: 4px;
            overflow: hidden;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
            font-size: 9px;
        }

        .color-row.closest {
            border: 1.5px solid #000000;
        }

        .color-swatch {
            width: 28px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 8px;
            color: white;
            text-shadow: 0 0 2px rgba(0,0,0,0.3);
        }

        .color-info {
            flex: 1;
            background: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 6px;
        }

        .color-hex {
            font-family: 'Monaco', monospace;
            font-size: 9px;
            cursor: pointer;
            padding: 1px 3px;
            border-radius: 2px;
            transition: all 0.2s;
        }

        .color-hex:hover {
            background: #f0f8ff;
            transform: scale(1.05);
        }

        .success-message {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #00000095;
            color: white;
            padding: 8px 20px;
            border-radius: 4px;
            font-size: 12px;
            text-align: center;
            z-index: 9999;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            opacity: 0;
            transform: translateX(-50%) translateY(20px);
            transition: all 0.3s ease;
            pointer-events: none;
            width: calc(100% - 40px);
        }

        .success-message.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        /* 톤 매칭 스타일 */
        .reference-display {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: linear-gradient(145deg, #e8f5e8, #d4f4d4);
            border-radius: 6px;
            margin-bottom: 8px;
        }

        .reference-color {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .reference-info {
            flex: 1;
        }

        .reference-info h4 {
            font-size: 11px;
            color: #28a745;
            margin-bottom: 2px;
        }

        .reference-info p {
            font-size: 9px;
            color: #155724;
            margin: 0;
        }

        .tone-input-area {

            background: #f8f9fa;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            box-sizing: border-box;
            width: 100%;
            max-width: 100%;
            overflow: hidden;


        }
        
        .button-group {
            display: flex;
            gap: 6px;
            margin-top: 8px;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
        }
        
        .button-group .action-btn {
            flex: 1;
            min-width: 0;
            white-space: nowrap;
            max-width: calc(50% - 3px);
        }

        .tone-suggestions {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
            margin-top: 8px;
        }

        .tone-suggestion {
            background: white;
            border-radius: 6px;
            padding: 8px;
            text-align: center;
            transition: all 0.2s ease;
            cursor: pointer;
            border: 1px solid #e0e0e0;
        }

        .tone-suggestion:hover {
            border-color: #000;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .tone-color-display {
            width: 40px;
            height: 24px;
            border-radius: 4px;
            margin: 0 auto 6px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.15);
        }

        .tone-suggestion-title {
            font-weight: 600;
            font-size: 10px;
            color: #333;
            margin-bottom: 3px;
        }

        .tone-suggestion-hex {
            font-family: 'Monaco', monospace;
            font-size: 9px;
            font-weight: 600;
            margin-bottom: 3px;
        }

        .tone-suggestion-desc {
            font-size: 8px;
            color: #666;
            line-height: 1.2;
        }

        .info-box {
            background: #f0f0f0;
            border: 1px solid #c7c7c7;
            border-radius: 4px;
            padding: 12px;
            margin-top: 8px;
        }

        .info-box h5 {
            color: #000000;
            font-size: 10px;
            margin-bottom: 4px;
        }

        .info-box p {
            font-size: 9px;
            color: #888;
            margin: 0;
            line-height: 1.3;
        }

        /* Custom Theme Wizard 스타일 */
        .wizard-progress {
            margin-top: 20px;
            margin-bottom: 20px;
            padding: 0 4px;
        }

        .simple-progress-bar {
            display: flex;
            height: 4px;
            background: var(--specialblack-1);
            border-radius: 2px;
            overflow: hidden;
        }

        .progress-segment {
            flex: 1;
            background: var(--specialblack-1);
            margin-right: 2px;
            border-radius: 2px;
            position: relative;
            overflow: hidden;
        }
        
        .progress-segment::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: var(--accentblue);
            transition: left 0.6s ease-out;
        }

        .progress-segment:last-child {
            margin-right: 0;
        }

        .progress-segment.active::before {
            left: 0;
        }

        .progress-segment.completed::before {
            left: 0;
            transition: none;
        }

        .wizard-step {
            display: none;
            animation: fadeIn 0.3s ease-in;
        }

        .wizard-step.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .step-header {
            text-align: left;
            margin-bottom: 20px;
            padding: 0px 8px 0px 8px;
        }

        .step-header .step-title {
            font-size: 14px;
            color: #1a202c;
            margin-bottom: 4px;
            font-weight: 600;
            background: #1a202c;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .step-header p {
            font-size: 12px;
            color: #888;
            margin: 0;
        }

        .step-content {
            margin-bottom: 24px;
        }

        .input-group {
            margin-bottom: 16px;
        }

        .input-group label {
            display: block;
            font-size: 11px;
            font-weight: 500;
            color: #333;
            margin-bottom: 4px;
        }

        .color-preview {
            margin-top: 6px;
        }

        .preview-swatch {
            width: 40px;
            height: 20px;
            border-radius: 3px;
            background: #667eea;
            border: 1px solid #ccc;
        }

        .token-preview {
            background: #f5f5f5;
            border-radius: 4px;
            padding: 12px;
        }

        .token-item {
            display: block;
            margin-bottom: 8px;
            padding: 0;
            border: none;
        }

        .token-item:last-child {
            margin-bottom: 0;
        }

        .token-label {
            font-size: 11px;
            color: #333;
            font-weight: 500;
            margin-bottom: 2px;
        }

        .token-value {
            font-size: 11px;
            font-family: 'Monaco', monospace;
            color: #667eea;
            background: transparent;
            padding: 0;
            border-radius: 0;
            display: block;
        }

        .mode-cards {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 40px 12px;
            margin-bottom: 30px;
            padding:8px;
            width: 100%;
            justify-content: center;
            padding-bottom: 20px;
        }


        .mode-card {
            background: var(--basicwhite);
            border: 1px solid #00000010;
            border-radius: 6px;
            box-sizing: border-box;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            position: relative;
            width: 100%;
            height: 168px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 10px;
            overflow: visible;
        }

        .mode-card:hover {
            border-color: var(--accentblue);
            box-shadow: 0 4px 12px rgba(0, 122, 255, 0.15);
            transform: translateY(-1px);
        }

        .mode-card.selected {
            outline: 2px solid var(--accentblue);
            outline-offset: 2px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .card-checkbox {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 24px;
            height: 24px;
            border-radius: 14px;
            background: #ffffff80;
            border: 1px solid #00000010;
            box-sizing: border-box;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2px;
            transition: all 0.2s;
            z-index: 10;
        }

        .mode-card.selected .card-checkbox {
            background: #1f1f1f;
            border: 2px solid #000;
        }

        .checkbox-icon {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .checkbox-icon.unselected {
            opacity: 0.0;
        }

        .mode-card.selected .checkbox-icon.unselected {
            display: none;
        }
        
        /* 새로운 아이콘 구조 CSS */
        .mode-card .selected-icon {
            display: none !important;
        }
        .mode-card .unselected-icon {
            display: none !important;
        }
        .mode-card.selected .selected-icon {
            display: block !important;
        }
        .mode-card.selected .unselected-icon {
            display: none !important;
        }
        
        /* accent-on-bg-off 모드 배경색 적용 */
        .mode-card[data-mode="accent-on-bg-off"] {
            background: #e8edff;
        }
        
        /* accent-off-bg-on 모드 배경색 적용 */
        .mode-card[data-mode="accent-off-bg-on"] {
            background: #667eea;
        }
        .mode-card[data-mode="accent-off-bg-on"] .preview-frame {
            
        }
        .mode-card[data-mode="accent-off-bg-on"] .card-label {
            color: white;
        }
        
        /* accent-on-bg-black 모드 배경색 적용 */
        .mode-card[data-mode="accent-on-bg-black"] {
            background: #1f1f1f;
        }
        .mode-card[data-mode="accent-on-bg-black"] .preview-frame {
            background: none !important;
        }
        .mode-card[data-mode="accent-on-bg-black"] .card-label,
        .mode-card[data-mode="accent-on-bg-black"] .card-sub-label {
            color: white;
        }

        /* Background Selection Styles */
        .background-selection {
            width: 100%;
        }

        .bg-options-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin-bottom: 16px;
        }

        .bg-card {
            border: 2px solid #E5E5E5;
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
            background: white;
            overflow: hidden;
        }
        
        .bg-card.selected {
            border-color: #007AFF;
            box-shadow: 0 2px 12px rgba(0, 122, 255, 0.2);
        }
        
        .bg-card[data-mode="accent-on-bg-black"] {
            background: #000000;
        }
        
        .bg-card-content {
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .bg-card-header {
            position: relative;
            display: flex;
            align-items: flex-start;
        }
        
        .bg-large-preview {
            width: 64px;
            height: 64px;
            border-radius: 12px;
            flex-shrink: 0;
            background: #F5F5F5; /* 기본값 */
        }
        
        .bg-radio-button {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 24px;
            height: 24px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .bg-radio-button.selected {
            background: #007AFF;
        }
        
        .bg-radio-button.white-circle {
            background: rgba(255, 255, 255, 0.9);
        }
        
        .radio-circle {
            width: 16px;
            height: 16px;
            border: none;
            border-radius: 8px;
            background: #D1D1D6;
        }
        
        .radio-circle.white {
            background: #666666;
        }
        
        .radio-icon {
            width: 16px;
            height: 16px;
        }
        
        .bg-card-info {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .bg-label {
            font-size: 14px;
            font-weight: 600;
            color: #000000;
        }
        
        .bg-hex-code {
            font-size: 12px;
            color: #666666;
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
        }

        /* Custom Background Card */
        .custom-bg-card {
            border: 2px solid #E5E5E5;
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
            background: white;
            margin-top: 16px;
            position: relative;
        }
        
        .custom-bg-card.selected {
            border-color: #007AFF;
            box-shadow: 0 2px 12px rgba(0, 122, 255, 0.2);
        }
        
        .custom-bg-card-content {
            padding: 16px;
            display: flex;
            align-items: center;
            gap: 16px;
        }
        
        .custom-bg-left {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
        }
        
        .bg-small-preview {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            flex-shrink: 0;
        }
        
        .custom-bg-info {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        .custom-bg-inputs {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .custom-bg-inputs input[type="color"] {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background: none;
        }
        
        .custom-bg-inputs input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
            border-radius: 8px;
            border: 2px solid #E5E5E5;
        }
        
        .custom-bg-inputs input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: 6px;
        }
        
        .custom-bg-inputs input[type="text"] {
            width: 100px;
            height: 40px;
            border: 2px solid #E5E5E5;
            border-radius: 8px;
            padding: 0 12px;
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            font-size: 14px;
            text-align: center;
        }
        
        .custom-bg-inputs input[type="text"]:focus {
            outline: none;
            border-color: #007AFF;
        }
        
        .custom-bg-card .bg-radio-button {
            position: absolute;
            top: 16px;
            right: 16px;
        }

        .bg-preview {
            width: 40px;
            height: 40px;
            border-radius: 6px;
            border: 1px solid #e0e0e0;
        }

        .bg-option span {
            font-size: 12px;
            font-weight: 500;
            color: #333;
        }

        .bg-hex {
            font-size: 10px;
            color: #666;
            font-family: monospace;
        }

        /* Custom Background Section */
        .custom-bg-section {
            margin-top: 16px;
        }

        .custom-bg-option {
            width: 100%;
            padding: 16px;
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            background: white;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-direction: row;
        }

        .custom-bg-option:hover {
            border-color: var(--accentblue);
            box-shadow: 0 2px 8px rgba(0, 122, 255, 0.1);
        }

        .custom-bg-option.selected {
            border-color: var(--accentblue);
            background: #f0f7ff;
            box-shadow: 0 2px 8px rgba(0, 122, 255, 0.15);
        }

        .custom-bg-content {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .custom-bg-info {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .custom-bg-info span {
            font-size: 14px;
            font-weight: 500;
            color: #333;
        }

        .custom-bg-input {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .custom-bg-input input[type="color"] {
            width: 40px;
            height: 32px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            cursor: pointer;
        }

        .custom-bg-input input[type="text"] {
            width: 80px;
            padding: 6px 8px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            font-family: monospace;
            font-size: 11px;
        }

        /* 기존 custom-background 클래스는 제거 (더 이상 사용안함) */

        .card-preview {
            
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            width: 100%;
        }

        .preview-frame {
            width: 100%;
            height: 100%;
            
            border-radius: 3px;
            position: relative;
            transition: all 0.2s ease-in-out; /* 부드러운 색상 전환 애니메이션 */
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            box-sizing: border-box;
        }


        .frame-header {
            font-size: 8px;
            font-weight: 600;
            color: #333;
            text-align: left;
            padding: 8px 6px 12px 6px;
            width : 100%;
            
            display: flex;
            justify-content: flex-start;
            align-items: center;
        }
        .frame-header svg path {
            fill: #000000;
            transition: fill 0.3s ease;
        }

        .frame-header.white {
            color: white;
        }


        .preview-frame.black-bg .frame-header {
            color: white;
            background: transparent;
            border-bottom-color: rgba(255,255,255,0.2);
        }

        .frame-content-area {
            justify-content: center;
            
            grid-template-columns: 1fr 1fr;
            flex: 1;
            align-items: stretch;
            width:100%;
        }

        .content-block {
            flex: 1;
            height:48px;
            margin-bottom: 8px;
            background: #f8f9fa;
            border-radius: 4px;
        }

        .content-block.light {
            background: #f8f9fa;
        }

        .content-block.white {
            background: rgba(255,255,255,0.8);
        }


        .preview-frame.black-bg .content-block.white {
            background: rgba(255,255,255,0.8);
        }

        .frame-button {
            background: #bcc8ff;
            transition: background-color 0.2s ease-in-out; /* 버튼 색상 전환 애니메이션 */
            border-radius: 4px;
            width: calc(100% - 16px);
            height: 26px;
            position: absolute;
            bottom: 0px;
            left: 10px;
            right: 10px;
            transition: background-color 0.3s ease;
        }

        .frame-button.accent {
            background: #667eea;
        }

        .frame-button.dark {
            background: #333;
        }

        .card-footer {
            position: absolute;
            bottom: -30px;
            left: 0;
            right: 0;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            line-height: 1.2;
            min-height: 20px;
        }

        .card-label {
            font-size: 8px;
            font-weight: 400;
            color: #333;
            transition: color 0.3s ease;
            text-align: center;
            width: 100%;
        }

        .card-description {
            font-size: 9px;
            color: #777;
            line-height: 1.2;
        }

        /* 색상 분류 정보 스타일 */
        .color-classification-info {
            margin-top: 8px;
            background: #f8f9fa;
            border-radius: 6px;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: row;

            padding: 12px;
        }

        .classification-result {
            
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: all 0.3s ease;
        }

        .classification-result.light {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .classification-result.dark {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .classification-details {
            font-size: 10px;
            color: #666;
            text-align: center;
        }

        .classification-reasons {
            font-size: 9px;
            color: #888;
            font-style: italic;
            line-height: 1.2;
        }

        .color-classification-info.light {
            border-left-color: #ffc107;
            background: #fff9e6;
        }

        .color-classification-info.dark {
            border-left-color: #17a2b8;
            background: #e6f7ff;
        }

        .step-actions {
            display: flex;
            justify-content: space-between;
            gap: 8px;
            padding-top: 12px;
        }

        .step-actions button {
            flex: 1;
            height: 32px;
            font-size: 11px;
        }

        .theme-preview {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 12px;
        }

        .theme-mode-preview {
            background: white;
            border-radius: 6px;
            padding: 8px;
            border: 1px solid #e0e0e0;
        }

        .theme-mode-title {
            font-size: 10px;
            font-weight: 600;
            margin-bottom: 6px;
            text-align: center;
        }

        .theme-semantic-list {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .semantic-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 8px;
        }

        .semantic-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            border: 1px solid rgba(0,0,0,0.1);
        }

        .semantic-name {
            flex: 1;
            font-family: 'Monaco', monospace;
            color: #666;
        }

        .theme-name-input {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 11px;
            margin-bottom: 8px;
            background: white;
        }

        .theme-name-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
        }

        /* Radio Button 스타일 */
        .radio-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 8px;
            background: rgba(255,255,255,0.5);
            border-radius: 4px;
            margin-bottom: 8px;
        }

        .radio-option {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            padding: 8px;
            background: white;
            border-radius: 4px;
            border: 1px solid #e0e0e0;
            cursor: pointer;
            transition: all 0.2s;
        }

        .radio-option:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .radio-option input[type="radio"] {
            margin-top: 2px;
        }

        .radio-option.selected {
            border-color: #667eea;
            background: #f0f4ff;
            border-width: 2px;
        }

        .radio-content {
            flex: 1;
        }

        .radio-label {
            font-size: 10px;
            font-weight: 600;
            color: #333;
            margin-bottom: 2px;
            display: block;
        }

        .radio-hint {
            font-size: 8px;
            color: #666;
            line-height: 1.3;
        }

        .step-indicator {
            display: inline-block;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: 600;
            margin-left: 6px;
        }

        .step-light {
            background: #fff3cd;
            color: #856404;
        }

        .step-medium {
            background: #e2e3e5;
            color: #41464b;
        }

        .step-dark {
            background: #343a40;
            color: #f8f9fa;
        }

        .classification-badge {
            display: inline-block;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: 600;
            
        }

        .classification-light {
            background: #cfe2ff;
            color: #084298;
            border: 1px solid #b6d4fe;
        }

        .classification-medium {
            background: #fff3cd;
            color: #664d03;
            border: 1px solid #ffecb5;
        }

        .classification-dark {
            background: #f8d7da;
            color: #842029;
            border: 1px solid #f5c2c7;
        }

        .warning-box {
            background: #fff7dd;
            border: 1px solid #ffeaa7;
            border-radius: 4px;
            padding: 8px 20px;
            margin-bottom: 8px;
        }

        .warning-box p {
            font-size: 9px;
            color: #856404;
            margin: 0;
        }

        /* 아코디언 스타일 추가 */
        .accordion-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 12px;
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 12px;
        }

        .accordion-header:hover {
            background: #e9ecef;
            border-color: #667eea;
        }

        .accordion-header.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .accordion-icon {
            font-size: 14px;
            transition: transform 0.2s;
        }

        .accordion-header.active .accordion-icon {
            transform: rotate(180deg);
        }

        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .accordion-content.expanded {
            max-height: 2000px;
            transition: max-height 0.5s ease-in;
        }

        .accordion-body {
            padding: 12px;
            border: 1px solid #e0e0e0;
            border-top: none;
            border-radius: 0 0 6px 6px;
            background: white;
        }

        #tuningSlider {
            width: 100%;
            -webkit-appearance: none;
            height: 4px;
            border-radius: 2px;
            background: #e0e0e0;
            outline: none;
        }

        #tuningSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }

        #tuningSlider:disabled {
            opacity: 0.5;
        }

        #tuningStatus {
            padding: 2px 6px;
            border-radius: 3px;
            background: #f0f0f0;
        }

        #tuningStatus.auto {
            background: #e8f5e8;
            color: #28a745;
        }

        /* 색상 복사 애니메이션 */
        @keyframes copyFlash {
            0% { 
                background: #4CAF50; 
                color: white;
                transform: scale(1.1);
            }
            100% { 
                background: transparent; 
                transform: scale(1);
            }
        }

        .color-hex.copied {
            animation: copyFlash 0.5s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- 탭 네비게이션 -->
        <div class="tab-navigation">
            <button class="tab-btn active" id="customThemeTab">
                Custom Theme
            </button>
            <button class="tab-btn" id="generatorTab">
                Scale Generator
            </button>
            <button class="tab-btn" id="toneMatchingTab">
                Tone Matching
            </button>
        </div>

        <!-- Custom Theme 탭 -->
        <div id="customThemeContent" class="tab-content active">
            <!-- 프로그레스 바 -->
            <div class="wizard-progress">
                <div class="simple-progress-bar">
                    <div class="progress-segment active" data-step="1"></div>
                    <div class="progress-segment" data-step="3"></div>
                </div>
            </div>

            <!-- Step 1: Key Color 선택 -->
            <div id="wizardStep1" class="wizard-step active">
                <div class="step-header">
                    <div class="step-title">Step 1. Key Color 선택</div>
                    <p>선택한 Key Color를 기반으로 완전한 semantic 토큰 시스템을 생성합니다.</p>
                </div>
                
                <div class="step-content">
                    <div class="input-group">
                        <label>테마 이름</label>
                        <input type="text" id="wizardThemeNameInput" class="theme-name-input" 
                               placeholder="예: custom-theme" value="custom-theme">
                    </div>
                    
                    <div class="input-group">
                        <label>Key Color</label>
                        <div class="color-input-group">
                            <input type="color" id="wizardThemeBaseColor" class="color-picker" value="#667eea">
                            <input type="text" id="wizardThemeBaseHex" class="hex-input" value="#667EEA">
                        </div>
                        
                        <!-- 컬러 분류 표시 -->
                        <div style="margin-top: 12px; display: flex; align-items: center; gap: 8px;">
                            <span id="wizardStepIndicator" class="step-indicator">Step: 500</span>
                            <span id="wizardClassificationBadge" class="classification-badge classification-medium">중간</span>
                        </div>
                        <div id="wizardStepClassificationInfo" class="color-classification-info" style="margin-top: 8px; display: none;">
                            <span id="wizardStepClassificationText">입력 색상이 Step 500에 해당합니다. 중간 범위(400-600)로 분류되어 Mode별로 다른 매핑이 적용됩니다.</span>
                        </div>
                    </div>
                </div>
                
                <div class="step-actions">
                    <button class="action-btn btn-success" onclick="goToStep(3)">다음</button>
                </div>
            </div>


            <!-- Step 3: Background 선택 및 적용 -->
            <div id="wizardStep3" class="wizard-step">
                <div class="step-header">
                    <div class="step-title">Step 2. Background 선택</div>
                    <p>선택한 Key Color에 맞는 Background를 선택하거나 직접 지정하세요.</p>
                </div>
                
                
                <div class="step-content">
                    <div class="background-selection">
                        <!-- 상단 3개 옵션 -->
                        <div class="bg-options-grid">
                            <!-- 추천 색상 (Mode 1) -->
                            <div class="bg-card selected" data-mode="accent-on-bg-off">
                                <div class="bg-card-content">
                                    <div class="bg-card-header">
                                        <div class="bg-large-preview" id="recommendedBgPreview"></div>
                                        <div class="bg-radio-button selected">
                                            <svg class="radio-icon" width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                                                <path d="M3.2332 8.0227L6.95951 12.0004L12.7589 4.03613" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                            </svg>
                                        </div>
                                    </div>
                                    <div class="bg-card-info">
                                        <div class="bg-label">추천 색상</div>
                                        <div class="bg-hex-code" id="recommendedBgHex">#F5F5F5</div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- White 배경 (Mode 3) -->
                            <div class="bg-card" data-mode="accent-on-bg-fixed">
                                <div class="bg-card-content">
                                    <div class="bg-card-header">
                                        <div class="bg-large-preview" style="background: #FFFFFF; border: 1px solid #E5E5E5;"></div>
                                        <div class="bg-radio-button">
                                            <div class="radio-circle"></div>
                                        </div>
                                    </div>
                                    <div class="bg-card-info">
                                        <div class="bg-label">White</div>
                                        <div class="bg-hex-code">#FFFFFF</div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Black 배경 (Mode 4) -->
                            <div class="bg-card" data-mode="accent-on-bg-black">
                                <div class="bg-card-content">
                                    <div class="bg-card-header">
                                        <div class="bg-large-preview" style="background: #000000;"></div>
                                        <div class="bg-radio-button white-circle">
                                            <div class="radio-circle white"></div>
                                        </div>
                                    </div>
                                    <div class="bg-card-info">
                                        <div class="bg-label" style="color: white;">Black</div>
                                        <div class="bg-hex-code" style="color: #999999;">#000000</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Custom Background Option -->
                        <div class="custom-bg-card" data-mode="custom-background" id="customBgOption">
                            <div class="custom-bg-card-content">
                                <div class="custom-bg-left">
                                    <div class="bg-small-preview" id="customBgPreview" style="background: #F5F5F5;"></div>
                                    <div class="custom-bg-info">
                                        <div class="bg-label">Custom</div>
                                        <div class="bg-hex-code" id="customBgHexDisplay">#F5F5F5</div>
                                    </div>
                                </div>
                                <div class="custom-bg-inputs">
                                    <input type="color" id="customBgColor" value="#F5F5F5">
                                    <input type="text" id="customBgHex" value="#F5F5F5" placeholder="#F5F5F5">
                                </div>
                                <div class="bg-radio-button" id="customRadioButton">
                                    <div class="radio-circle"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="step-actions">
                    <button class="action-btn btn-secondary" onclick="goToStep(1)">이전</button>
                    <button class="action-btn btn-success" onclick="applyCustomThemeWithBackground()">적용하기</button>
                </div>
                
                <!-- Mapping 정보보기 컨트롤 -->
                <div class="mapping-info-controls" style="margin: 8px; padding: 12px; border: 1px solid #00000010; border-radius: 8px; background: #f8f9fa;">
                    <div style="display: flex; gap: 6px; align-items: center; flex-direction: column; ">
                        <button 
                            id="showMappingBtn" 
                            onclick="showMappingInfo()" 
                            style="padding: 8px 16px; background: #000; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 10px;">
                            선택된 Frame의 Mapping 정보보기
                        </button>
                        <span id="mappingStatus" style="font-size: 10px; color: #666; margin-left: 8px;">Frame을 선택하고 버튼을 눌러주세요</span>
                    </div>
                </div>
            </div>
        </div>
        </div>
        <!-- End Step 3 -->

        <!-- Scale Generator 탭 부분 수정 -->
        <div id="generatorContent" class="tab-content">
            <div class="section">
                <div class="section-title">Base Color Input</div>
                <div class="color-input-group">
                    <input type="color" id="baseColor" class="color-picker" value="#667eea">
                    <input type="text" id="hexInput" class="hex-input" value="#667EEA">
                </div>
                
                <!-- 컬러 분류 표시 -->
                <div style="margin-top: 12px; display: flex; align-items: center; gap: 8px;">
                    <span id="stepIndicator" class="step-indicator">Step: 500</span>
                    <span id="classificationBadge" class="classification-badge classification-medium">중간</span>
                </div>
                <div id="stepClassificationInfo" class="color-classification-info" style="margin-top: 8px; display: none;">
                    <span id="stepClassificationText">입력 색상이 Step 500에 해당합니다. 중간 범위(400-600)로 분류되어 Mode별로 다른 매핑이 적용됩니다.</span>
                </div>
            </div>

            <!-- Base Color Input 섹션 다음에 추가 -->
            <div class="section" style="display: none;">
                <div class="section-title">Fine Tuning</div>
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <div style="display: flex; gap: 8px;">
                        <label style="font-size: 11px;">Auto Mode</label>
                        <input type="checkbox" id="autoTuning">
                    </div>
                    <span id="tuningStatus" style="font-size: 10px; color: #666;">Manual: 0</span>
                </div>
                <div style="display: flex; gap: 8px; align-items: center;">
                    <input type="range" id="tuningSlider" min="-10" max="10" value="0" style="flex: 1;">
                    <span id="tuningValue" style="min-width: 30px; text-align: center;">0</span>
                </div>
            </div>

            <div class="section">
                <div class="section-title">Background Mode</div>
                <div class="mode-buttons">
                    <button class="mode-btn active" onclick="setMode('light')">Light Mode</button>
                    <button class="mode-btn" onclick="setMode('dark')">Dark Mode</button>
                </div>
            </div>

            <div class="section">
                <div class="section-title">Variable Name</div>
                <input type="text" id="variableName" class="hex-input" placeholder="예: primary, brand, blue" style="width: 100%;">
                <p style="font-size: 9px; color: #666; margin-top: 4px;">
                    변수 이름 형식: {name}-50, {name}-100, {name}-200...
                </p>
            </div>

            <div class="section">
                <div class="section-title">Generated Color Palette</div>
                <div class="color-grid" id="colorResults">
                    <!-- 색상들이 여기에 표시됩니다 -->
                </div>
            </div>

            <!-- 액션 버튼들 추가 -->
            <div class="action-buttons" style="display: flex; flex-direction: column; gap: 2px; margin-top: 4px;">
                <button class="action-btn btn-primary" onclick="createVariables()">
                    Create Variables (현재 모드)
                </button>
                <button class="action-btn btn-success" onclick="createDualModeVariables()">
                    Create Light + Dark Variables
                </button>
                <button class="action-btn btn-secondary" onclick="createStyles()">
                    Create Color Styles
                </button>
            </div>
        </div>

        <!-- Tone Matching 탭 -->
        <div id="toneMatchingContent" class="tab-content">
            <div class="header">
                
            </div>

            <!-- 기준 색상 설정 -->
            <div class="section">
                <div class="section-title">Step 1. 기준 색상 정하기</div>
                <p style="color: #666; margin-bottom: 8px; font-size: 10px;">기준이 될 색상을 선택하세요</p>
                
                <div class="color-input-group">
                    <input type="color" id="referenceColorPicker" class="color-picker" value="#667eea">
                    <input type="text" id="referenceColorHex" class="hex-input" value="#667EEA">
                </div>
                
                <div class="button-group">
                    <button id="setRefBtn" class="action-btn btn-primary">Set Reference</button>
                    <button id="clearRefBtn" class="action-btn btn-secondary">Clear</button>
                </div>
                
                <div id="referenceStatus" style="color: #666; font-size: 10px; margin: 8px 0px 8px 0px;">현재 설정된 기준 컬러가 없습니다.</div>
                <div id="referenceDisplay"></div>
            </div>
            
            <!-- 새 색상 입력 -->
            <div class="section">
                <div class="section-title">Step 2. 새로운 컬러 입력하기</div>
                <p style="color: #666; margin-bottom: 8px; font-size: 10px;">원하는 색상을 입력하면 톤 매칭이 제공됩니다</p>
                
                <div class="tone-input-area">
                    <div class="color-input-group">
                        <input type="color" id="newColorPicker" class="color-picker" value="#ff0000">
                        <input type="text" id="newColorHex" class="hex-input" value="#FF0000">
                    </div>
                    <button id="getSuggestionsBtn" class="action-btn btn-success">추천받기</button>
                    <p style="font-size: 10px; color: #666; margin-top: 4px;">이 색상은 기준 톤에 맞게 조정됩니다.</p>
                </div>
                
                <div id="toneMatchingResults"></div>
            </div>
        </div>

        <!-- 성공 메시지 -->
        <div class="success-message" id="successMessage"></div>
    </div>

    <script>
        
        // 전역 변수
        let currentMode = 'light';
        let generatedColors = [];
        let referenceColor = null;
        let currentTheme = null;

        // 색상 유틸리티
        class ColorUtils {
            static hexToRgb(hex) {
                var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : { r: 0, g: 0, b: 0 };
            }

            static rgbToHex(r, g, b) {
                return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
            }

            static hexToHsl(hex) {
                var rgb = this.hexToRgb(hex);
                return this.rgbToHsl(rgb.r / 255, rgb.g / 255, rgb.b / 255);
            }

            static rgbToHsl(r, g, b) {
                var max = Math.max(r, g, b);
                var min = Math.min(r, g, b);
                let h, s, l = (max + min) / 2;

                if (max === min) {
                    h = s = 0;
                } else {
                    var d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    switch (max) {
                        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                        case g: h = (b - r) / d + 2; break;
                        case b: h = (r - g) / d + 4; break;
                    }
                    h /= 6;
                }

                return [h * 360, s * 100, l * 100];
            }

            static hslToRgb(h, s, l) {
                h /= 360; s /= 100; l /= 100;
                var a = s * Math.min(l, 1 - l);
                var f = n => {
                    var k = (n + h * 12) % 12;
                    return l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
                };
                return [
                    Math.round(f(0) * 255),
                    Math.round(f(8) * 255),
                    Math.round(f(4) * 255)
                ];
            }

            static hslToHex(h, s, l) {
                var [r, g, b] = this.hslToRgb(h, s, l);
                return this.rgbToHex(r, g, b);
            }

            // === Contrast <-> Luminance 도우미 (white/dark 배경) ===
            static luminanceFromContrastVsWhite(contrast) {
                // contrast = (1.0 + 0.05) / (Y + 0.05)  →  Y = (1.05 / C) - 0.05
                return (1.05 / contrast) - 0.05;
            }

            static luminanceFromContrastVsBlack(contrast) {
                // contrast = (Y + 0.05) / 0.05  →  Y = 0.05 * contrast - 0.05
                return 0.05 * contrast - 0.05;
            }

            static luminanceFromContrastVsDarkBg(contrast) {
                // #0c0c0c의 luminance 계산
                const darkBgLuminance = this.getLuminance(12, 12, 12);
                // contrast = (Y + 0.05) / (darkBgLuminance + 0.05)  →  Y = contrast * (darkBgLuminance + 0.05) - 0.05
                return contrast * (darkBgLuminance + 0.05) - 0.05;
            }

            // HSL(h,s,L)에서 L을 이진탐색해서 목표 Y에 최대근접
            static solveLForY(h, s, targetY) {
                let lo = 0, hi = 100, bestL = 50, bestErr = 1e9;
                for (let i = 0; i < 24; i++) {
                    const mid = (lo + hi) / 2;
                    const [r, g, b] = this.hslToRgb(h, s, mid);
                    const Y = this.getLuminance(r, g, b);
                    const err = Math.abs(Y - targetY);
                    if (err < bestErr) { bestErr = err; bestL = mid; }
                    // white 기준: Y가 높으면 더 어둡게(hi 내림)
                    if (Y > targetY) hi = mid; else lo = mid;
                }
                return { L: bestL, err: bestErr };
            }

            // (가능하면 채도 보존) 목표 대비를 만족하는 HSL 찾기
            static solveHSLForContrast(h, sInput, contrastTarget, background = 'light') {
                const bgRgb = background === 'light' 
                    ? { r: 255, g: 255, b: 255 }
                    : { r: 12, g: 12, b: 12 };

                // 채도는 입력값 우선, 불가시 극소폭 보정
                const SAT_CAND = [1.0, 0.95, 0.9, 0.85].map(f => Math.max(5, Math.min(100, sInput * f)));
                let best = null;

                for (const s of SAT_CAND) {
                    // L값을 이진탐색으로 목표 대비에 맞춤
                    let lo = 0, hi = 100, bestL = 50, bestErr = 1e9;
                    
                    for (let i = 0; i < 24; i++) {
                        const mid = (lo + hi) / 2;
                        const [r, g, b] = this.hslToRgb(h, s, mid);
                        const actualContrast = this.getContrast({ r, g, b }, bgRgb);
                        const err = Math.abs(actualContrast - contrastTarget);
                        
                        if (err < bestErr) { 
                            bestErr = err; 
                            bestL = mid; 
                        }
                        
                        if (actualContrast > contrastTarget) {
                            if (background === 'light') {
                                lo = mid; // Light: 대비가 높으면 L을 높여서 대비를 줄임 (밝게)
                            } else {
                                hi = mid; // Dark: 대비가 높으면 L을 낮춰서 대비를 줄임 (어둡게)
                            }
                        } else {
                            if (background === 'light') {
                                hi = mid; // Light: 대비가 낮으면 L을 낮춰서 대비를 높임 (어둡게)
                            } else {
                                lo = mid; // Dark: 대비가 낮으면 L을 높여서 대비를 높임 (밝게)
                            }
                        }
                    }
                    
                    if (!best || bestErr < best.err) {
                        best = { h, s, l: bestL, err: bestErr };
                    }
                    if (bestErr < 0.01) break; // 충분히 근접하면 조기 종료
                }
                return best; // {h,s,l,err}
            }

            static getLuminance(r, g, b) {
                var [rs, gs, bs] = [r, g, b].map(c => {
                    c = c / 255;
                    return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
                });
                return 0.2126 * rs + 0.7152 * gs + 0.0722 * bs;
            }

            static getContrast(rgb1, rgb2) {
                var l1 = this.getLuminance(rgb1.r, rgb1.g, rgb1.b);
                var l2 = this.getLuminance(rgb2.r, rgb2.g, rgb2.b);
                var lighter = Math.max(l1, l2);
                var darker = Math.min(l1, l2);
                return (lighter + 0.05) / (darker + 0.05);
            }

            // 가장 가까운 스텝 찾기
            static findClosestStep(hex, mode) {
                mode = mode || 'light';  // 기본값 설정
                var [h, s, l] = this.hexToHsl(hex);
                var steps = [50, 75, 100, 150, 200, 300, 400, 500, 600, 700, 800, 900, 950];
                let closestStep = 500;
                let minDiff = Infinity;
                
                steps.forEach(function(step) {
                    let targetLightness;
                    if (mode === 'light') {
                        // ColorGenerator와 동일한 로직 사용
                        switch(step) {
                            case 50:  targetLightness = 95; break;
                            case 75:  targetLightness = 90; break;
                            case 100: targetLightness = 85; break;
                            case 150: targetLightness = 78; break;
                            case 200: targetLightness = 70; break;
                            case 300: targetLightness = 60; break;
                            case 400: targetLightness = 50; break;
                            case 500: targetLightness = 40; break;
                            case 600: targetLightness = 32; break;
                            case 700: targetLightness = 25; break;
                            case 800: targetLightness = 18; break;
                            case 900: targetLightness = 12; break;
                            case 950: targetLightness = 8; break;
                            default: targetLightness = 50;
                        }
                    } else {
                        // Dark mode 명도 매핑
                        switch(step) {
                            case 50:  targetLightness = 5; break;
                            case 75:  targetLightness = 10; break;
                            case 100: targetLightness = 15; break;
                            case 150: targetLightness = 22; break;
                            case 200: targetLightness = 30; break;
                            case 300: targetLightness = 40; break;
                            case 400: targetLightness = 50; break;
                            case 500: targetLightness = 60; break;
                            case 600: targetLightness = 68; break;
                            case 700: targetLightness = 75; break;
                            case 800: targetLightness = 82; break;
                            case 900: targetLightness = 88; break;
                            case 950: targetLightness = 92; break;
                            default: targetLightness = 50;
                        }
                    }
                    
                    var diff = Math.abs(l - targetLightness);
                    if (diff < minDiff) {
                        minDiff = diff;
                        closestStep = step;
                    }
                });
                
                return closestStep;
            }
        }

        // Hue의 본질적 밝기 판단 함수
        function getHueBrightness(hue) {
            // Hue 범위별 본질적 밝기 분류
            
            // 매우 밝은 색상군
            if (hue >= 50 && hue <= 70) return 'very-bright';     // 노랑 (Yellow)
            if (hue >= 170 && hue <= 190) return 'very-bright';   // 청록 (Cyan)
            
            // 밝은 색상군  
            if (hue >= 70 && hue <= 150) return 'bright';         // 연두-초록 (Yellow-Green to Green)
            if (hue >= 150 && hue <= 170) return 'bright';        // 청록-초록 경계 (Green-Cyan)
            if (hue >= 30 && hue <= 50) return 'bright';          // 주황 (Orange)
            
            // 중간 색상군
            if (hue >= 190 && hue <= 210) return 'medium';        // 청록-파랑 경계 (Cyan-Blue)
            if (hue >= 20 && hue <= 30) return 'medium';          // 주황-빨강 경계
            
            // 어두운 색상군
            if (hue >= 210 && hue <= 240) return 'dark';          // 파랑 (Blue)
            if (hue >= 240 && hue <= 300) return 'dark';          // 보라 (Purple/Violet)
            if (hue >= 0 && hue <= 20 || hue >= 300) return 'dark'; // 빨강-자주 (Red-Magenta)
            
            return 'medium'; // 기본값
        }

        // 새로운 컬러 범위 분류 로직
        function getColorRangeFromStep(closestStep, hex) {
            // 본질적 밝기 판단
            var isInherentlyBright = false;
            if (hex) {
                var hsl = ColorUtils.hexToHsl(hex);
                var hue = hsl[0];
                var saturation = hsl[1];
                var lightness = hsl[2];
                var hueBrightness = getHueBrightness(hue);
                
                if (saturation < 20) {
                    // 회색조는 lightness로만 판단
                    isInherentlyBright = (lightness >= 50);
                } else {
                    // 1) Lightness가 75% 이상이면 무조건 밝은 색상으로 분류
                    if (lightness >= 75) {
                        isInherentlyBright = true;
                    } 
                    // 2) 그렇지 않으면 Hue의 본질적 밝기로 판단
                    else {
                        // very-bright, bright까지를 본질적으로 밝은 색상으로 분류
                        isInherentlyBright = (hueBrightness === 'very-bright' || hueBrightness === 'bright');
                    }
                }
            }
            
            // 색상 범위 결정 (본질적 밝기에 따라 기준 조정)
            if (isInherentlyBright) {
                // 태생이 밝은 색상
                if (closestStep <= 400) {
                    return 'light';
                } else if (closestStep >= 500 && closestStep <= 700) {
                    return 'medium';
                } else {
                    return 'dark';  // 800-950
                }
            } else {
                // 태생이 어두운 색상
                if (closestStep < 300) {
                    return 'light';
                } else if (closestStep >= 300 && closestStep <= 700) {
                    return 'medium';
                } else {
                    return 'dark';  // 800-950
                }
            }
        }

        // 색상 생성기
        class ColorGenerator {
    constructor() {
        this.steps = [50, 75, 100, 150, 200, 300, 400, 500, 600, 700, 800, 900, 950];
        
        // Light Mode 회색 톤 (기존 규칙대로)
        this.lightModeGrayTones = [
            '#FFFFFF', // 50
            '#F7F7F7', // 75
            '#F0F0F0', // 100
            '#E8E8E8', // 150
            '#DDDDDD', // 200
            '#CCCCCC', // 300
            '#B4B4B4', // 400
            '#9E9E9E', // 500
            '#8A8A8A', // 600
            '#6A6A6A', // 700
            '#464646', // 800
            '#1F1F1F', // 900
            '#000000'  // 950
        ];
        
        // Dark Mode 회색 톤
        this.darkModeGrayTones = [
            '#0C0C0C', // 50
            '#141414', // 75
            '#1C1C1C', // 100
            '#242424', // 150
            '#313131', // 200
            '#414141', // 300
            '#525252', // 400
            '#626262', // 500
            '#808080', // 600
            '#ADADAD', // 700
            '#E3E3E3', // 800
            '#F4F4F4', // 900
            '#FCFCFC'  // 950
        ];

        // Dark Mode 대비값 (#0c0c0c 배경 기준)
        this.darkModeContrastRatios = [
            1.00, // 50
            1.06, // 75
            1.15, // 100
            1.26, // 150
            1.50, // 200
            1.92, // 300
            2.50, // 400
            3.21, // 500
            4.95, // 600
            8.72, // 700
            15.24, // 800
            17.79, // 900
            20.0   // 950
        ];
    }

    getAutoTuningValue(hex) {
        var [h, s, l] = ColorUtils.hexToHsl(hex);
        let tuning = 0;
        
        // 색상별 조정
        if (h >= 45 && h <= 75) tuning = -3;      // 노란색: 더 어둡게
        else if (h >= 15 && h <= 45) tuning = -2; // 주황색
        else if (h >= 210 && h <= 270) tuning = 2; // 파란색: 더 밝게
        else if (h >= 180 && h <= 210) tuning = 1; // 청록색
        
        // 채도에 따른 추가 조정
        if (s > 80) tuning -= 1;
        else if (s < 30) tuning += 1;
        
        return Math.max(-10, Math.min(10, tuning));
    }

    generateColors(inputHex, mode, tuningValue = 0) {
        const [hInput, sInput, lInput] = ColorUtils.hexToHsl(inputHex);
        const backgroundRgb = (mode === 'light') ? { r: 255, g: 255, b: 255 } : { r: 12, g: 12, b: 12 };

        // 무채색은 기존 회색 톤 그대로 (UI 의도 유지)
        if (sInput < 5) {
            const toneSet = (mode === 'light') ? this.lightModeGrayTones : this.darkModeGrayTones;
            return this.steps.map((step, i) => {
                const hex = toneSet[i];
                const rgb = ColorUtils.hexToRgb(hex);
                const contrast = ColorUtils.getContrast(rgb, backgroundRgb);
                return { step, hex, contrast, isClosest: false };
            });
        }

        // 1) grayscale 분포를 기반으로 현재 모드의 "목표 대비" 산출
        const targets = this.buildTargetContrasts(mode, hInput);

        // 2) 각 스텝에서 목표 대비를 만족하도록 HSL 계산 (hue 고정, 채도 보존)
        const colors = this.steps.map((step, i) => {
            const targetContrast = targets[i];
            const solved = ColorUtils.solveHSLForContrast(hInput, sInput, targetContrast, mode);

            // 튜닝: 최종 L에 소폭 가감
            let L = Math.max(0, Math.min(100, solved.l + (tuningValue || 0)));
            const [r, g, b] = ColorUtils.hslToRgb(solved.h, solved.s, L);
            const hex = ColorUtils.rgbToHex(r, g, b);
            const contrast = ColorUtils.getContrast({ r, g, b }, backgroundRgb);

            return { step, hex, contrast, isClosest: false };
        });

        // 3) 새로운 Hue 기반 로직으로 가장 가까운 step 찾기
        const inputColorHex = ColorUtils.hslToHex(hInput, sInput * 100, lInput);
        
        // 모든 step에 대해 새로운 분류 로직을 적용하여 가장 적절한 step 찾기
        let bestStepIndex = 0;
        let minDiff = Infinity;
        
        colors.forEach((color, index) => {
            // 각 step이 입력 색상과 얼마나 유사한 범위에 속하는지 계산
            const colorRange = getColorRangeFromStep(color.step, inputColorHex);
            const actualLightness = lInput;
            const stepLightness = ColorUtils.hexToHsl(color.hex)[2];
            
            // lightness 차이와 범위 일치도를 종합적으로 고려
            let diff = Math.abs(actualLightness - stepLightness);
            
            // 같은 범위(light/medium/dark)에 속한 경우 가중치 부여 
            if (colorRange === getColorRangeFromStep(color.step, inputColorHex)) {
                diff *= 0.5; // 같은 범위면 우선순위 높임
            }
            
            if (diff < minDiff) {
                minDiff = diff;
                bestStepIndex = index;
            }
        });
        
        colors[bestStepIndex].isClosest = true;

        return colors;
    }

    // 목표 대비 빌더 - 각 스텝의 목표 대비비율 계산
    buildTargetContrasts(mode, inputHue) {
        const steps = this.steps;
        const bg = (mode === 'light') ? { r: 255, g: 255, b: 255 } : { r: 12, g: 12, b: 12 };

        // 1) Grayscale 대비율 분포 계산
        const grayContrast = (mode === 'light') ? 
            steps.map((_, i) => {
                const hex = this.lightModeGrayTones[i];
                const rgb = ColorUtils.hexToRgb(hex);
                return ColorUtils.getContrast(rgb, { r: 255, g: 255, b: 255 });
            }) :
            this.darkModeContrastRatios;

        // 2) 입력 hue의 anchor 대비 계산 (Step50/Step950)
        let hueMinContrast, hueMaxContrast;
        
        if (mode === 'light') {
            // Light: Step50=1.03 고정, Step950=20.0 고정
            hueMinContrast = 1.03; // Step50 anchor
            hueMaxContrast = 20.0; // Step950 anchor
        } else {
            // Dark: Step50=가장어둠(L=0), Step950=최대 19.0으로 제한 (완전 흰색 방지)
            const darkestRgb = ColorUtils.hexToRgb(ColorUtils.hslToHex(inputHue, 100, 0));
            const brightestRgb = ColorUtils.hexToRgb(ColorUtils.hslToHex(inputHue, 100, 100));
            hueMinContrast = ColorUtils.getContrast(darkestRgb, bg);   // Step50 anchor
            const theoreticalMax = ColorUtils.getContrast(brightestRgb, bg);
            hueMaxContrast = Math.min(19.0, theoreticalMax); // Step950을 19.0으로 제한
        }

        // 3) Grayscale 분포의 비율로 hue 범위에 보간
        const grayMinContrast = grayContrast[0];
        const grayMaxContrast = grayContrast[grayContrast.length - 1];
        
        return grayContrast.map(grayC => {
            const ratio = (grayC - grayMinContrast) / (grayMaxContrast - grayMinContrast);
            return hueMinContrast + ratio * (hueMaxContrast - hueMinContrast);
        });
    }
}

        // Wizard 관련 함수들
        let currentWizardStep = 1;
        let wizardThemeData = null;

        function goToStep(stepNumber) {
            
            // 현재 스텝에서 데이터 수집 및 처리
            if (stepNumber === 3 && currentWizardStep === 1) {
                // Step 1에서 Step 3로: 테마 변수를 먼저 생성하고 테마 데이터 생성
                createCustomThemeVariablesAndProceed();
                return; // 비동기 처리를 위해 여기서 리턴
            }

            // 프로그레스 업데이트
            updateProgressBar(stepNumber);

            // 스텝 콘텐츠 업데이트
            updateStepContent(stepNumber);

            // Step 3로 이동할 때 추천 배경색 업데이트
            if (stepNumber === 3) {
                setTimeout(() => {
                    const wizardBaseColor = document.getElementById('wizardThemeBaseColor');
                    if (wizardBaseColor && wizardBaseColor.value) {
                        console.log('🎨 Step 3 진입 시 추천 배경색 업데이트:', wizardBaseColor.value);
                        updateRecommendedBackground(wizardBaseColor.value);
                    }
                }, 100); // DOM 업데이트 후 실행
            }

            currentWizardStep = stepNumber;
        }
        
        function updateProgressBar(stepNumber) {
            document.querySelectorAll('.progress-segment').forEach(segment => {
                const step = parseInt(segment.dataset.step);
                segment.classList.remove('active', 'completed');
                
                if (step < stepNumber) {
                    segment.classList.add('completed');
                } else if (step === stepNumber) {
                    segment.classList.add('active');
                }
            });
        }
        
        function updateStepContent(stepNumber) {
            document.querySelectorAll('.wizard-step').forEach(step => {
                step.classList.remove('active');
            });
            
            const targetStep = document.getElementById('wizardStep' + stepNumber);
            if (targetStep) {
                targetStep.classList.add('active');
                
                // Step 3에서 모드 미리보기 업데이트
                if (stepNumber === 3) {
                    setTimeout(() => {
                        const baseColorInput = document.getElementById('wizardThemeBaseHex');
                        if (baseColorInput && baseColorInput.value) {
                            updateAllModePreviewsWithColor(baseColorInput.value);
                        }
                    }, 100);
                }
            } else {
                console.error('Step element not found:', 'wizardStep' + stepNumber);
            }
        }
        
        function createCustomThemeVariablesAndProceed() {
            const themeName = document.getElementById('wizardThemeNameInput').value;
            const baseColor = document.getElementById('wizardThemeBaseHex').value;
            
            if (!themeName || !baseColor) {
                showMessage('테마 이름과 색상을 입력해주세요!');
                return;
            }
            
            // 테마 생성
            const tuningValue = 0; // 기본값
            currentTheme = themeGenerator.generateTheme(baseColor, themeName, 'accent-on-bg-off', tuningValue);
            
            // 모드 카드 미리보기 업데이트
            updateModeCardPreviews();
            
            // 백엔드에 테마 변수 생성 요청
            parent.postMessage({
                pluginMessage: {
                    type: 'create-custom-theme',
                    theme: currentTheme
                }
            }, '*');
            
            showMessage('테마 변수 생성 중...');
            
            // 잠시 후 Step 3로 바로 진행
            setTimeout(() => {
                generateWizardTheme(); // 토큰 미리보기 생성
                updateProgressBar(3);
                updateStepContent(3);
                currentWizardStep = 3;
                showMessage('테마 변수가 생성되었습니다!');
            }, 1000);
        }

        function generateWizardTheme() {
            
            // currentTheme가 이미 생성되어 있다면 그것을 사용
            if (currentTheme) {
                const themeName = currentTheme.themeName;
                const closestStep = currentTheme.selectedStep || 200;
                
                // Step 2가 제거되었으므로 토큰 미리보기 업데이트 생략

                // wizardThemeData와 동기화
                wizardThemeData = {
                    themeName: themeName,
                    baseColor: currentTheme.baseColor,
                    closestStep: closestStep,
                    applicationMode: currentTheme.applicationMode || 'accent-on-bg-off'
                };
            } else {
                // 기존 로직 (fallback)
                const themeName = document.getElementById('wizardThemeNameInput').value;
                const baseColor = document.getElementById('wizardThemeBaseHex').value;
                
                // Scale Generator와 동일한 로직 사용
                const closestStep = ColorUtils.findClosestStep(baseColor, 'light');
                

                wizardThemeData = {
                    themeName: themeName,
                    baseColor: baseColor,
                    closestStep: closestStep,
                    applicationMode: 'accent-on-bg-off'
                };
            }
            
        }

        function selectModeCard(card, mode) {
            
            // 모든 카드에서 selected 클래스 제거
            document.querySelectorAll('.mode-card').forEach(c => {
                c.classList.remove('selected');
            });
            
            // 클릭된 카드에 selected 클래스 추가
            card.classList.add('selected');
            
            // 테마 데이터 업데이트
            if (wizardThemeData) {
                wizardThemeData.applicationMode = mode;
            }
        }

        // 모드별 토큰 미리보기 업데이트
        function updateModeCardPreviews() {
            if (!currentTheme) return;
            
            
            const modes = ['accent-on-bg-off', 'accent-off-bg-on', 'accent-on-bg-fixed', 'accent-on-bg-black'];
            
            modes.forEach(mode => {
                const tokens = getTokensForMode(mode);
                updateModeCardPreview(mode, tokens);
            });
        }
        
        // 특정 모드의 토큰값 계산 (밝기 기준에 따른 매핑 규칙 적용)
        function getTokensForMode(mode) {
            if (!currentTheme || !currentTheme.scaleColors) return null;
            
            const lightColors = currentTheme.scaleColors.light;
            const darkColors = currentTheme.scaleColors.dark;
            const selectedStep = currentTheme.selectedStep || 500;
            
            // 밝기 기준 (백엔드 getDynamicMappings와 동일한 로직)
            let isBrightColor = selectedStep < 200; // 200 미만
            if (currentTheme.baseColor) {
                const hsl = ColorUtils.hexToHsl(currentTheme.baseColor);
                const lightness = hsl[2];
                // 밝기가 80% 이상이면 bright color로 분류
                if (lightness >= 80) {
                    isBrightColor = true;
                }
            }
            
            let backgroundLight, textPrimaryLight, fillPrimaryLight;
            
            switch(mode) {
                case 'accent-on-bg-off':
                    // foreground 중심: 배경 고정, 텍스트와 fill이 accent
                    backgroundLight = '#FFFFFF';
                    if (isBrightColor) {
                        textPrimaryLight = lightColors.find(c => c.step === 900)?.hex || '#000000';
                        fillPrimaryLight = lightColors.find(c => c.step === 600)?.hex;
                    } else {
                        textPrimaryLight = lightColors.find(c => c.step === selectedStep)?.hex;
                        fillPrimaryLight = lightColors.find(c => c.step === selectedStep)?.hex;
                    }
                    break;
                    
                case 'accent-off-bg-on':
                    // background 중심: 배경이 accent, 텍스트와 fill은 contrasting
                    backgroundLight = lightColors.find(c => c.step === selectedStep)?.hex;
                    if (isBrightColor) {
                        textPrimaryLight = lightColors.find(c => c.step === 900)?.hex || '#000000';
                        fillPrimaryLight = lightColors.find(c => c.step === 800)?.hex;
                    } else {
                        textPrimaryLight = '#FFFFFF';
                        fillPrimaryLight = lightColors.find(c => c.step === 50)?.hex;
                    }
                    break;
                    
                case 'accent-on-bg-fixed':
                    // foreground 중심, white bg 고정
                    backgroundLight = '#FFFFFF';
                    if (isBrightColor) {
                        textPrimaryLight = lightColors.find(c => c.step === 900)?.hex || '#000000';
                        fillPrimaryLight = lightColors.find(c => c.step === 600)?.hex;
                    } else {
                        textPrimaryLight = lightColors.find(c => c.step === selectedStep)?.hex;
                        fillPrimaryLight = lightColors.find(c => c.step === selectedStep)?.hex;
                    }
                    break;
                    
                case 'accent-on-bg-black':
                    // foreground 중심, black bg 고정 (백엔드와 동일한 로직)
                    backgroundLight = '#1f1f1f';
                    // 실제 GRAY:50 색상 사용 (Light Mode gray scale의 50번째)
                    const colorGenerator = new ColorGenerator();
                    textPrimaryLight = colorGenerator.lightModeGrayTones[0]; // 50번째 = index 0 = '#FFFFFF'
                    if (isBrightColor) {
                        fillPrimaryLight = lightColors.find(c => c.step === selectedStep)?.hex;
                    } else {
                        fillPrimaryLight = lightColors.find(c => c.step === selectedStep)?.hex;
                    }
                    break;
            }
            
            
            // fillSurfaceContents는 항상 연한 회색 계열 (50-100 단계)
            const fillSurfaceContentsLight = lightColors.find(c => c.step === 50)?.hex || '#f9fafb';
            
            return {
                background: backgroundLight,
                textPrimary: textPrimaryLight,
                fillPrimary: fillPrimaryLight,
                fillSurfaceContents: fillSurfaceContentsLight
            };
        }
        
        // 모드 카드 미리보기 업데이트
        function updateModeCardPreview(mode, tokens) {
            if (!tokens) return;
            
            const card = document.querySelector(`[data-mode="${mode}"]`);
            if (!card) return;
            
            const previewFrame = card.querySelector('.preview-frame');
            const frameHeader = card.querySelector('.frame-header');
            const frameButton = card.querySelector('.frame-button');
            
            // 모든 모드의 mode-card 자체에 배경색 적용
            card.style.backgroundColor = tokens.background;
            
            // 텍스트 색상 적용 (로고)
            if (frameHeader) {
                const svgPaths = frameHeader.querySelectorAll('svg path');
                svgPaths.forEach(path => {
                    path.setAttribute('fill', tokens.textPrimary);
                    path.style.setProperty('fill', tokens.textPrimary, 'important');
                });
            }
            
            // 버튼 색상 적용 (semantic/fill/primary)
            if (frameButton) {
                frameButton.style.backgroundColor = tokens.fillPrimary;
                frameButton.style.border = 'none';
                frameButton.style.boxShadow = 'none';
            }
            
            // content-block 색상 적용 (semantic/fill/surface-contents 미리보기)
            const contentBlocks = card.querySelectorAll('.content-block');
            contentBlocks.forEach(block => {
                block.style.backgroundColor = tokens.fillSurfaceContents || '#f1f5f9';
                block.style.border = 'none';
            });
            
            // 카드 라벨 텍스트 색상 고정 (카드 밖으로 나왔으므로 검은색 고정)
            const cardLabel = card.querySelector('.card-label');
            const cardSubLabel = card.querySelector('.card-sub-label');
            if (cardLabel) {
                cardLabel.style.setProperty('color', '#000000', 'important');
            }
            if (cardSubLabel) {
                cardSubLabel.style.setProperty('color', '#000000', 'important');
            }
        }

        // 현재 입력된 색상을 기반으로 모든 모드 카드의 미리보기를 실시간 업데이트하는 함수
        function updateAllModePreviewsWithColor(baseColor) {
            if (!baseColor || !baseColor.startsWith('#')) {
                return;
            }
            
            // 각 모드에 대해 색상 토큰 계산 및 미리보기 업데이트
            const modes = ['accent-on-bg-off', 'accent-on-bg-fixed', 'accent-off-bg-on', 'accent-on-bg-black'];
            
            modes.forEach(mode => {
                const tokens = calculatePreviewTokensForMode(baseColor, mode);
                if (tokens) {
                    updateModeCardPreview(mode, tokens);
                }
            });
        }

        // 현재 테마의 실시간 미리보기 업데이트
        function updateCurrentThemePreview(newBaseColor) {
            if (!currentTheme || !themeGenerator) return;
            
            // 현재 테마의 설정을 유지하면서 baseColor만 변경
            const themeName = currentTheme.themeName || 'preview-theme';
            const applicationMode = currentTheme.applicationMode || 'accent-on-bg-off';
            const tuningValue = 0; // 기본값
            
            try {
                const updatedTheme = themeGenerator.generateTheme(newBaseColor, themeName, applicationMode, tuningValue);
                currentTheme = updatedTheme;
                
                // 테마 미리보기 업데이트
                displayThemePreview(updatedTheme);
                
            } catch (error) {
                console.warn('테마 실시간 업데이트 중 오류:', error);
            }
        }

        // 미리보기 업데이트 성능 최적화
        function optimizedPreviewUpdate(baseColor) {
            // 이미 같은 색상으로 업데이트 중이면 스킵
            if (window.lastPreviewColor === baseColor) return;
            window.lastPreviewColor = baseColor;
            
            // 애니메이션 프레임 내에서 업데이트 실행
            requestAnimationFrame(() => {
                updateAllModePreviewsWithColor(baseColor);
                updateWizardStepIndicator(baseColor);
                
                if (currentTheme) {
                    updateCurrentThemePreview(baseColor);
                }
            });
        }

        // 각 모드별로 미리보기용 색상 토큰을 계산하는 함수 (실제 semantic token 매핑 기반)
        function calculatePreviewTokensForMode(baseColor, mode) {
            if (!baseColor) return null;
            
            try {
                // 임시 테마 생성하여 실제 매핑 규칙 사용
                const tempTheme = themeGenerator ? themeGenerator.generateTheme(baseColor, 'preview', mode, 0) : null;
                if (tempTheme && tempTheme.scaleColors) {
                    
                    // 실제 semantic token 매핑에서 값 추출
                    const lightColors = tempTheme.scaleColors.light;
                    const darkColors = tempTheme.scaleColors.dark;
                    
                    // 색상 분류 (실제 로직과 동일)
                    const hsl = ColorUtils.hexToHsl ? ColorUtils.hexToHsl(baseColor) : hexToHsl(baseColor);
                    const lightness = hsl[2];
                    const hue = hsl[0];
                    const saturation = hsl[1];
                    
                    // 색상 분류 로직 (75% 기준)
                    let isInherentlyBright = false;
                    if (saturation < 20) {
                        isInherentlyBright = (lightness >= 50);
                    } else {
                        if (lightness >= 75) {
                            isInherentlyBright = true;
                        } else {
                            // Hue 기반 판단
                            const isBrightHue = (hue >= 50 && hue <= 190);
                            isInherentlyBright = isBrightHue;
                        }
                    }
                    
                    // closestStep 계산
                    const closestStep = findClosestStepFromColors(lightColors, baseColor) || 500;
                    
                    // 색상 범위 결정
                    let colorRange;
                    if (isInherentlyBright) {
                        if (closestStep <= 400) colorRange = 'light';
                        else if (closestStep >= 500 && closestStep <= 700) colorRange = 'medium';
                        else colorRange = 'dark';
                    } else {
                        if (closestStep < 300) colorRange = 'light';
                        else if (closestStep >= 300 && closestStep <= 700) colorRange = 'medium';
                        else colorRange = 'dark';
                    }
                    
                    // 모드별 매핑 결정
                    return calculateTokensForModeAndRange(mode, colorRange, lightColors, darkColors, baseColor, closestStep);
                }
            } catch (error) {
                console.warn('임시 테마 생성 실패, 기본 로직 사용:', error);
            }
            
            // 폴백: 기본 로직
            return calculateBasicPreviewTokens(baseColor, mode);
        }

        // 실제 semantic token 매핑 기반 토큰 계산
        function calculateTokensForModeAndRange(mode, colorRange, lightColors, darkColors, baseColor, closestStep) {
            let tokens = {
                background: '#ffffff',
                textPrimary: '#000000',  
                fillPrimary: baseColor,
                fillSurfaceContents: '#f8fafc'
            };
            
            const getColorByStep = (step) => {
                const color = lightColors.find(c => c.step === step);
                return color ? color.hex : baseColor;
            };
            
            switch (mode) {
                case 'accent-on-bg-off': // foreground 중심
                    if (colorRange === 'light') {
                        // 밝은 색상: 어두운 배경 + 밝은 fillPrimary
                        tokens.background = getColorByStep(950);  
                        tokens.textPrimary = '#f9fafb'; // GRAY:50 (밝은 텍스트)
                        tokens.fillPrimary = getColorByStep(400); // 밝은 primary 색상
                        tokens.fillSurfaceContents = 'rgba(255,255,255,0.2)'; // STATIC-WHITE-ALPHA:200
                    } else if (colorRange === 'medium') {
                        // 중간 색상: 색상 배경 + 밝은 primary
                        tokens.background = getColorByStep(closestStep);
                        tokens.textPrimary = 'rgba(255,255,255,0.9)'; // STATIC-WHITE-ALPHA:900
                        tokens.fillPrimary = getColorByStep(50); // 밝은 primary
                        tokens.fillSurfaceContents = 'rgba(255,255,255,0.2)'; 
                    } else {
                        // 어두운 색상: 색상 배경 + 밝은 primary  
                        tokens.background = getColorByStep(closestStep);
                        tokens.textPrimary = 'rgba(255,255,255,0.9)'; // STATIC-WHITE-ALPHA:900
                        tokens.fillPrimary = getColorByStep(50); // 밝은 primary
                        tokens.fillSurfaceContents = 'rgba(255,255,255,0.2)';
                    }
                    break;
                    
                case 'accent-on-bg-fixed': // foreground 중심 white bg
                    tokens.background = '#ffffff'; // 항상 흰 배경으로 고정
                    tokens.textPrimary = '#1f2937'; // GRAY:900
                    tokens.fillPrimary = getColorByStep(closestStep);
                    tokens.fillSurfaceContents = 'rgba(107,114,128,0.1)'; // GRAY-ALPHA:100
                    break;
                    
                case 'accent-off-bg-on': // background 중심  
                    tokens.background = baseColor;
                    tokens.textPrimary = getContrastTextColor(baseColor);
                    tokens.fillPrimary = getLighterShade(baseColor);
                    tokens.fillSurfaceContents = 'rgba(255,255,255,0.1)';
                    break;
                    
                case 'accent-on-bg-black': // foreground 중심 black bg
                    tokens.background = '#1f1f1f';
                    tokens.textPrimary = '#f9fafb'; // GRAY:50
                    tokens.fillPrimary = baseColor;
                    tokens.fillSurfaceContents = 'rgba(255,255,255,0.2)'; // STATIC-WHITE-ALPHA:200
                    break;
            }
            
            return tokens;
        }

        // 기본 미리보기 토큰 계산 (폴백)
        function calculateBasicPreviewTokens(baseColor, mode) {
            const hsl = ColorUtils.hexToHsl ? ColorUtils.hexToHsl(baseColor) : hexToHsl(baseColor);
            const lightness = hsl[2];
            const isLightColor = lightness >= 75;
            
            let tokens = {
                background: '#ffffff',
                textPrimary: '#000000',
                fillPrimary: baseColor,
                fillSurfaceContents: '#f8fafc'
            };
            
            switch (mode) {
                case 'accent-on-bg-off':
                    if (isLightColor) {
                        tokens.background = adjustColorLightness(baseColor, 15);
                        tokens.textPrimary = '#ffffff';
                    } else {
                        tokens.background = adjustColorLightness(baseColor, 95);
                        tokens.textPrimary = '#000000';
                    }
                    break;
                    
                case 'accent-on-bg-fixed':
                    tokens.background = '#ffffff';
                    tokens.textPrimary = '#000000';
                    break;
                    
                case 'accent-off-bg-on':
                    tokens.background = baseColor;
                    tokens.textPrimary = getContrastTextColor(baseColor);
                    tokens.fillPrimary = getLighterShade(baseColor);
                    break;
                    
                case 'accent-on-bg-black':
                    tokens.background = '#1f1f1f';
                    tokens.textPrimary = '#ffffff';
                    break;
            }
            
            return tokens;
        }

        // 색상 배열에서 가장 가까운 step 찾기
        function findClosestStepFromColors(colors, targetColor) {
            if (!colors || !targetColor) return 500;
            
            const targetHsl = ColorUtils.hexToHsl ? ColorUtils.hexToHsl(targetColor) : hexToHsl(targetColor);
            const targetLightness = targetHsl[2];
            
            let closestStep = 500;
            let minDiff = Infinity;
            
            colors.forEach(color => {
                const colorHsl = ColorUtils.hexToHsl ? ColorUtils.hexToHsl(color.hex) : hexToHsl(color.hex);
                const diff = Math.abs(targetLightness - colorHsl[2]);
                
                if (diff < minDiff) {
                    minDiff = diff;
                    closestStep = color.step;
                }
            });
            
            return closestStep;
        }

        // 색상의 명도를 조정하는 헬퍼 함수
        function adjustColorLightness(hex, targetLightness) {
            const hsl = ColorUtils.hexToHsl ? ColorUtils.hexToHsl(hex) : hexToHsl(hex);
            return ColorUtils.hslToHex ? ColorUtils.hslToHex(hsl[0], hsl[1], targetLightness) : hslToHex(hsl[0], hsl[1], targetLightness);
        }

        // 배경 색상에 대한 적절한 텍스트 색상을 반환하는 함수
        function getContrastTextColor(backgroundColor) {
            const hsl = ColorUtils.hexToHsl ? ColorUtils.hexToHsl(backgroundColor) : hexToHsl(backgroundColor);
            return hsl[2] > 50 ? '#000000' : '#ffffff';
        }

        // 더 밝은 색조를 생성하는 함수
        function getLighterShade(baseColor) {
            const hsl = ColorUtils.hexToHsl ? ColorUtils.hexToHsl(baseColor) : hexToHsl(baseColor);
            const lighterLightness = Math.min(hsl[2] + 30, 90);
            const reducedSaturation = Math.max(hsl[1] - 20, 30);
            return ColorUtils.hslToHex ? ColorUtils.hslToHex(hsl[0], reducedSaturation, lighterLightness) : hslToHex(hsl[0], reducedSaturation, lighterLightness);
        }

        // 밝은 색상 판단 함수 (코드베이스의 isLightRange와 동일한 로직)
        function isLightColor(hex) {
            if (!hex || !hex.startsWith('#')) return false;
            
            const hsl = ColorUtils.hexToHsl ? ColorUtils.hexToHsl(hex) : hexToHsl(hex);
            const lightness = hsl[2];
            const hue = hsl[0];
            
            // 1) HSL 밝기 기준: 80% 이상
            if (lightness >= 80) return true;
            
            // 2) BornBright 색상: Hue 40°-190° (노랑~청록 계열)
            if (hue >= 40 && hue <= 190) return true;
            
            return false;
        }

        // 색상 분류 정보를 반환하는 함수
        function getColorClassification(hex) {
            if (!hex || !hex.startsWith('#')) return null;
            
            const hsl = ColorUtils.hexToHsl ? ColorUtils.hexToHsl(hex) : hexToHsl(hex);
            const lightness = hsl[2];
            const hue = hsl[0];
            const isLight = isLightColor(hex);
            
            let reasons = [];
            if (lightness >= 80) reasons.push(`밝기 ${Math.round(lightness)}%`);
            if (hue >= 40 && hue <= 190) reasons.push('본질적 밝은 색상 (노랑~청록 계열)');
            
            return {
                isLight: isLight,
                lightness: Math.round(lightness),
                hue: Math.round(hue),
                reasons: reasons,
                classification: isLight ? '밝은 범위' : '어두운 범위'
            };
        }

        // 색상 분류 정보 표시 업데이트 함수
        function updateColorClassificationDisplay(hex) {
            const classificationInfo = getColorClassification(hex);
            if (!classificationInfo) return;
            
            const classificationResult = document.getElementById('classificationResult');
            const lightnessValue = document.getElementById('lightnessValue');
            const hueValue = document.getElementById('hueValue');
            const classificationReasons = document.getElementById('classificationReasons');
            
            if (classificationResult) {
                classificationResult.textContent = classificationInfo.classification;
                classificationResult.className = `classification-result ${classificationInfo.isLight ? 'bright' : 'dark'}`;
            }
            
            if (lightnessValue) {
                lightnessValue.textContent = classificationInfo.lightness;
            }
            
            if (hueValue) {
                hueValue.textContent = classificationInfo.hue;
            }
            
            if (classificationReasons) {
                if (classificationInfo.reasons.length > 0) {
                    classificationReasons.textContent = '분류 근거: ' + classificationInfo.reasons.join(', ');
                    classificationReasons.style.display = 'block';
                } else {
                    classificationReasons.style.display = 'none';
                }
            }
        }

        // HSL 변환 함수들 (ColorUtils가 없는 경우 대비)
        function hexToHsl(hex) {
            const r = parseInt(hex.slice(1, 3), 16) / 255;
            const g = parseInt(hex.slice(3, 5), 16) / 255;
            const b = parseInt(hex.slice(5, 7), 16) / 255;

            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }

            return [h * 360, s * 100, l * 100];
        }

        function hslToHex(h, s, l) {
            h = h % 360;
            if (h < 0) h += 360;
            s = Math.max(0, Math.min(100, s));
            l = Math.max(0, Math.min(100, l));
            
            h /= 360;
            s /= 100;
            l /= 100;
            
            const a = s * Math.min(l, 1 - l);
            const f = n => {
                const k = (n + h * 12) % 12;
                return l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
            };
            
            const r = Math.round(f(0) * 255);
            const g = Math.round(f(8) * 255);
            const b = Math.round(f(4) * 255);
            
            return "#" + [r, g, b].map(x => {
                const hex = x.toString(16);
                return hex.length === 1 ? "0" + hex : hex;
            }).join("");
        }

        function applyCustomTheme() {
            if (!currentTheme && !wizardThemeData) {
                showMessage('먼저 테마를 생성해주세요!');
                return;
            }

            // 현재 선택된 모드로 테마 업데이트
            const selectedMode = document.querySelector('.mode-card.selected')?.dataset.mode || 'accent-on-bg-off';
            
            let themeToApply;
            if (currentTheme) {
                // currentTheme 사용 (이미 변수가 생성된 경우)
                themeToApply = {
                    ...currentTheme,
                    applicationMode: selectedMode
                };
            } else {
                // wizardThemeData 사용 (fallback)
                themeToApply = {
                    themeName: wizardThemeData.themeName,
                    baseColor: wizardThemeData.baseColor,
                    applicationMode: selectedMode,
                    scaleColors: { light: generateScaleColors(wizardThemeData.baseColor) }
                };
            }

            parent.postMessage({
                pluginMessage: {
                    type: 'apply-theme-colors-to-frame',
                    theme: themeToApply
                }
            }, '*');
            
            // 적용하기 후 annotation 자동 활성화
            const annotationCheckbox = document.getElementById('annotationToggle');
            if (annotationCheckbox) {
                // 체크박스 활성화 및 체크
                annotationCheckbox.disabled = false;
                annotationCheckbox.checked = true;
                
                // 라벨 텍스트 업데이트
                const labelSpan = annotationCheckbox.parentElement.querySelector('span');
                if (labelSpan) {
                    labelSpan.textContent = '선택된 요소의 색상 매핑 표시';
                    labelSpan.style.color = '#333';
                }
                
                toggleAnnotation(); // annotation 활성화 함수 호출
            }
            
            showMessage('Custom Theme 적용 중...');
        }

        function applyCustomThemeWithBackground() {
            // 선택된 background 옵션 가져오기
            const selectedBgOption = document.querySelector('.bg-card.selected, .custom-bg-card.selected');
            if (!selectedBgOption) {
                showMessage('Background를 선택해주세요!');
                return;
            }

            // Frame 선택 확인
            parent.postMessage({
                pluginMessage: { type: 'check-frame-selection' }
            }, '*');
            
            // 응답을 기다리기 위해 플래그 설정
            window.pendingThemeApplication = true;
        }

        // Frame 선택 체크 응답 처리
        window.handleFrameSelectionResult = function(frameInfo) {
            if (window.pendingThemeApplication) {
                window.pendingThemeApplication = false;
                
                if (frameInfo && frameInfo.hasFrames) {
                    applySelectedBackgroundTheme();
                } else {
                    showMessage('⚠️ Frame을 선택한 후 다시 시도해주세요');
                }
            }
        };

        function applySelectedBackgroundTheme() {
            if (!currentTheme && !wizardThemeData) {
                showMessage('먼저 테마를 생성해주세요!');
                return;
            }

            // 선택된 background 옵션의 mode 가져오기
            const selectedBgOption = document.querySelector('.bg-card.selected, .custom-bg-card.selected');
            const selectedMode = selectedBgOption.dataset.mode;
            
            let themeToApply;
            if (currentTheme) {
                themeToApply = {
                    ...currentTheme,
                    applicationMode: selectedMode
                };
            } else {
                themeToApply = {
                    themeName: wizardThemeData.themeName,
                    baseColor: wizardThemeData.baseColor,
                    applicationMode: selectedMode,
                    scaleColors: { light: generateScaleColors(wizardThemeData.baseColor) }
                };
            }

            // Custom Background가 선택된 경우 색상 정보 추가
            if (selectedMode === 'custom-background') {
                const customBgHex = document.getElementById('customBgHex');
                if (customBgHex && customBgHex.value) {
                    themeToApply.customBackgroundColor = customBgHex.value;
                    console.log('🎨 Custom Background 적용:', customBgHex.value);
                }
            }

            parent.postMessage({
                pluginMessage: {
                    type: 'apply-theme-colors-to-frame',
                    theme: themeToApply
                }
            }, '*');
            
            showMessage('Custom Theme 적용 중...');
        }

        // Background 옵션 선택 이벤트 핸들러
        function initBackgroundSelection() {
            const bgCards = document.querySelectorAll('.bg-card, .custom-bg-card');
            bgCards.forEach(card => {
                card.addEventListener('click', () => {
                    // 모든 카드에서 selected 클래스 제거 및 라디오 버튼 상태 업데이트
                    bgCards.forEach(c => {
                        c.classList.remove('selected');
                        const radioButton = c.querySelector('.bg-radio-button');
                        if (radioButton) {
                            radioButton.classList.remove('selected');
                            const radioIcon = radioButton.querySelector('.radio-icon');
                            const radioCircle = radioButton.querySelector('.radio-circle');
                            if (radioIcon) radioIcon.style.display = 'none';
                            if (radioCircle) radioCircle.style.display = 'block';
                        }
                    });
                    
                    // 선택된 카드에 selected 클래스 추가 및 라디오 버튼 상태 업데이트
                    card.classList.add('selected');
                    const radioButton = card.querySelector('.bg-radio-button');
                    if (radioButton) {
                        radioButton.classList.add('selected');
                        const radioIcon = radioButton.querySelector('.radio-icon');
                        const radioCircle = radioButton.querySelector('.radio-circle');
                        if (radioIcon) radioIcon.style.display = 'block';
                        if (radioCircle) radioCircle.style.display = 'none';
                    }
                });
            });

            // 초기 추천 배경색 설정
            const wizardBaseColor = document.getElementById('wizardThemeBaseColor');
            if (wizardBaseColor && wizardBaseColor.value) {
                updateRecommendedBackground(wizardBaseColor.value);
            }

            // Custom background 색상 변경 이벤트
            const customBgColor = document.getElementById('customBgColor');
            const customBgHex = document.getElementById('customBgHex');
            const customBgPreview = document.getElementById('customBgPreview');
            const customBgHexDisplay = document.getElementById('customBgHexDisplay');
            const customBgOption = document.getElementById('customBgOption');
            
            function updateCustomBgDisplay(color) {
                if (customBgPreview) {
                    customBgPreview.style.background = color;
                }
                if (customBgHexDisplay) {
                    customBgHexDisplay.textContent = color;
                }
                
                // Custom 옵션이 선택되어 있다면 자동으로 선택 유지
                if (customBgOption && customBgOption.classList.contains('selected')) {
                    // 이미 선택된 상태이므로 유지
                }
            }
            
            if (customBgColor) {
                customBgColor.addEventListener('change', (e) => {
                    const color = e.target.value.toUpperCase();
                    customBgHex.value = color;
                    updateCustomBgDisplay(color);
                    
                    // Custom 옵션 자동 선택 및 라디오 버튼 상태 업데이트
                    const bgCards = document.querySelectorAll('.bg-card, .custom-bg-card');
                    bgCards.forEach(card => {
                        card.classList.remove('selected');
                        const radioButton = card.querySelector('.bg-radio-button');
                        if (radioButton) {
                            radioButton.classList.remove('selected');
                            const radioIcon = radioButton.querySelector('.radio-icon');
                            const radioCircle = radioButton.querySelector('.radio-circle');
                            if (radioIcon) radioIcon.style.display = 'none';
                            if (radioCircle) radioCircle.style.display = 'block';
                        }
                    });
                    if (customBgOption) {
                        customBgOption.classList.add('selected');
                        const radioButton = customBgOption.querySelector('.bg-radio-button');
                        if (radioButton) {
                            radioButton.classList.add('selected');
                            const radioIcon = radioButton.querySelector('.radio-icon');
                            const radioCircle = radioButton.querySelector('.radio-circle');
                            if (radioIcon) radioIcon.style.display = 'block';
                            if (radioCircle) radioCircle.style.display = 'none';
                        }
                    }
                });
            }
            
            if (customBgHex) {
                customBgHex.addEventListener('input', (e) => {
                    const hex = e.target.value;
                    if (/^#[0-9A-Fa-f]{6}$/.test(hex)) {
                        customBgColor.value = hex;
                        updateCustomBgDisplay(hex);
                        
                        // Custom 옵션 자동 선택 및 라디오 버튼 상태 업데이트
                        const bgCards = document.querySelectorAll('.bg-card, .custom-bg-card');
                        bgCards.forEach(card => {
                            card.classList.remove('selected');
                            const radioButton = card.querySelector('.bg-radio-button');
                            if (radioButton) {
                                radioButton.classList.remove('selected');
                                const radioIcon = radioButton.querySelector('.radio-icon');
                                const radioCircle = radioButton.querySelector('.radio-circle');
                                if (radioIcon) radioIcon.style.display = 'none';
                                if (radioCircle) radioCircle.style.display = 'block';
                            }
                        });
                        if (customBgOption) {
                            customBgOption.classList.add('selected');
                            const radioButton = customBgOption.querySelector('.bg-radio-button');
                            if (radioButton) {
                                radioButton.classList.add('selected');
                                const radioIcon = radioButton.querySelector('.radio-icon');
                                const radioCircle = radioButton.querySelector('.radio-circle');
                                if (radioIcon) radioIcon.style.display = 'block';
                                if (radioCircle) radioCircle.style.display = 'none';
                            }
                        }
                    }
                });
            }
        }

        // 추천 배경색 업데이트 함수
        function updateRecommendedBackground(keyColor) {
            console.log('🎨 updateRecommendedBackground 호출됨:', keyColor);
            
            // Mode 1 (accent-on-bg-off) 로직 기반으로 추천 배경색 생성
            try {
                // themeGenerator를 사용하여 임시 테마 생성
                const tempTheme = themeGenerator.generateTheme(keyColor, 'temp', 'accent-on-bg-off', 0);
                if (!tempTheme || !tempTheme.scaleColors || !tempTheme.scaleColors.light) {
                    console.error('❌ 테마 생성 실패');
                    return;
                }
                
                const lightColors = tempTheme.scaleColors.light;
                console.log('📊 생성된 라이트 컬러:', lightColors);
                
                // Step 찾기 - 기존 로직과 동일
                var inputHsl = ColorUtils.hexToHsl(keyColor);
                var inputLightness = inputHsl[2];
                var closestStep = themeGenerator.findClosestStep(lightColors, inputLightness);
                
                console.log('🎯 Closest step:', closestStep, 'Input lightness:', inputLightness);
                
                // 컬러 분류 (bright/medium/dark)
                let colorRange;
                if (closestStep >= 700) {
                    colorRange = 'bright';
                } else if (closestStep >= 400) {
                    colorRange = 'medium';
                } else {
                    colorRange = 'dark';
                }
                
                console.log('🌈 Color range:', colorRange);
                
                // Mode 1 배경색 결정 로직
                let recommendedBg = '#F5F5F5'; // 기본값
                
                if (colorRange === 'bright') {
                    recommendedBg = lightColors[200] || '#F5F5F5';
                } else if (colorRange === 'medium') {
                    recommendedBg = lightColors[100] || '#F8F9FA';
                } else { // dark
                    recommendedBg = '#FFFFFF';
                }
                
                console.log('🎨 추천 배경색:', recommendedBg);
                
                // UI 업데이트
                const recommendedBgPreview = document.getElementById('recommendedBgPreview');
                const recommendedBgHex = document.getElementById('recommendedBgHex');
                
                console.log('🔍 UI 요소 확인:', {
                    preview: !!recommendedBgPreview,
                    hex: !!recommendedBgHex
                });
                
                if (recommendedBgPreview) {
                    recommendedBgPreview.style.background = recommendedBg;
                    console.log('✅ Preview 업데이트됨');
                }
                if (recommendedBgHex) {
                    recommendedBgHex.textContent = recommendedBg;
                    console.log('✅ Hex 업데이트됨:', recommendedBg);
                }
                
            } catch (error) {
                console.error('❌ 추천 배경색 생성 실패:', error);
            }
        }

        function generateScaleColors(baseColor) {
            // CustomThemeGenerator를 사용하여 색상 생성
            const tempTheme = themeGenerator.generateTheme(baseColor, 'temp', 'accent-on-bg-off', 0);
            return tempTheme && tempTheme.scaleColors ? tempTheme.scaleColors : { light: {} };
        }


        // Custom Theme 생성기 
        class CustomThemeGenerator {
            constructor() {
                // 고정 매핑만 남기기 (preserve tokens)
                this.fixedMappings = {
                    'fill/surface-floating': { light: 900, dark: 900 },
                    'fill/surface-dialog': { light: 50, dark: 75 },
                    'fill/surface-sheet': { light: 50, dark: 75 },
                    'fill/surface-black': { light: 950, dark: 50 },
                    'background/black': { light: 950, dark: 50 },
                    'common/on-white': { light: 50, dark: 950 },
                    'common/on-white-hover': { light: 75, dark: 900 },
                    'common/on-white-pressed': { light: 75, dark: 900 },
                    'common/on-black': { light: 900, dark: 75 },
                    'common/on-black-hover': { light: 950, dark: 50 },
                    'common/on-black-pressed': { light: 950, dark: 50 },
                    'overlay/dimmed': { light: 700, dark: 700 }
                };
            }

            generateTheme(baseHex, themeName, applicationMode, tuningValue = 0) {
                var colorGenerator = new ColorGenerator();
                var lightColors = colorGenerator.generateColors(baseHex, 'light', tuningValue);
                var darkColors = colorGenerator.generateColors(baseHex, 'dark', tuningValue);
                
                // 입력 색상의 명도로 closest step 찾기
                var inputHsl = ColorUtils.hexToHsl(baseHex);
                var inputLightness = inputHsl[2];
                var closestStepLight = this.findClosestStep(lightColors, inputLightness);
                var closestStepDark = this.findClosestStep(darkColors, inputLightness);
                
                // 색상 분류 결정 (code.js와 동일한 로직)
                var colorRange = this.getColorClassification(baseHex, closestStepLight);
                
                // 테마 객체 생성 (백엔드 형식과 일치)
                return {
                    themeName,
                    baseColor: baseHex,
                    applicationMode,
                    selectedStep: closestStepLight,
                    colorRange: colorRange, // 추가
                    scaleColors: { 
                        light: lightColors, 
                        dark: darkColors 
                    },
                    // semanticTokens는 백엔드에서 처리하므로 빈 배열
                    semanticTokens: []
                };
            }
            
            findClosestStep(colors, inputLightness) {
                var closestStep = 500;
                var minDifference = Infinity;
                
                colors.forEach(color => {
                    var colorLightness = ColorUtils.hexToHsl(color.hex)[2];
                    var diff = Math.abs(inputLightness - colorLightness);
                    
                    if (diff < minDifference) {
                        minDifference = diff;
                        closestStep = color.step;
                    }
                });
                
                return closestStep;
            }
            
            // 색상 분류 메서드 (code.js와 동일한 로직)
            getColorClassification(baseHex, closestStep) {
                var hsl = ColorUtils.hexToHsl(baseHex);
                var hue = hsl[0];
                var saturation = hsl[1];
                var lightness = hsl[2];
                
                var isInherentlyBright = false;
                
                // Hue의 본질적 밝기 판단
                function getHueBrightness(hue) {
                    // 매우 밝은 색상군
                    if (hue >= 50 && hue <= 70) return 'very-bright';     // 노랑
                    if (hue >= 170 && hue <= 190) return 'very-bright';   // 청록
                    
                    // 밝은 색상군  
                    if (hue >= 70 && hue <= 150) return 'bright';         // 연두-초록
                    if (hue >= 150 && hue <= 170) return 'bright';        // 청록-초록 경계
                    if (hue >= 30 && hue <= 50) return 'bright';          // 주황
                    
                    // 중간 색상군
                    if (hue >= 0 && hue <= 30) return 'medium';           // 빨강
                    if (hue >= 330 && hue <= 360) return 'medium';        // 빨강
                    if (hue >= 190 && hue <= 250) return 'medium';        // 파랑
                    
                    // 어두운 색상군
                    return 'dark';  // 보라 (250-330)
                }
                
                if (saturation < 20) {
                    // 회색조는 lightness로만 판단
                    isInherentlyBright = (lightness >= 50);
                } else {
                    if (lightness >= 75) {
                        isInherentlyBright = true;
                    } else {
                        var hueBrightness = getHueBrightness(hue);
                        isInherentlyBright = (hueBrightness === 'very-bright' || hueBrightness === 'bright');
                    }
                }
                
                // 색상 범위 결정
                var colorRange;
                if (isInherentlyBright) {
                    // 태생이 밝은 색상
                    if (closestStep <= 400) {
                        colorRange = 'light';
                    } else if (closestStep >= 500 && closestStep <= 700) {
                        colorRange = 'medium';
                    } else {
                        colorRange = 'dark';  // 800-950
                    }
                } else {
                    // 태생이 어두운 색상
                    if (closestStep < 300) {
                        colorRange = 'light';
                    } else if (closestStep >= 300 && closestStep <= 700) {
                        colorRange = 'medium';
                    } else {
                        colorRange = 'dark';  // 800-950
                    }
                }
                
                
                return colorRange;
            }
        }

        // 인스턴스 생성
        var colorGenerator = new ColorGenerator();
        var themeGenerator = new CustomThemeGenerator();

        // 탭 전환 함수
        function switchTab(tabName) {
            console.log('switchTab called with:', tabName);
            const tabNavigation = document.querySelector('.tab-navigation');
            
            // 모든 탭 버튼 비활성화
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // 모든 탭 콘텐츠 숨기기
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // 슬라이딩 애니메이션을 위한 클래스 제거
            tabNavigation.classList.remove('second-active', 'third-active');
            
            if (tabName === 'generator') {
                document.getElementById('generatorTab').classList.add('active');
                document.getElementById('generatorContent').classList.add('active');
                tabNavigation.classList.add('second-active');
            } else if (tabName === 'tone-matching') {
                document.getElementById('toneMatchingTab').classList.add('active');
                document.getElementById('toneMatchingContent').classList.add('active');
                tabNavigation.classList.add('third-active');
            } else if (tabName === 'custom-theme') {
                document.getElementById('customThemeTab').classList.add('active');
                document.getElementById('customThemeContent').classList.add('active');
                // 첫 번째 탭이므로 기본 위치 (클래스 추가 안 함)
                
                // Custom Theme 탭 전환 시 색상 동기화 리스너 다시 설정
                setTimeout(() => {
                    setupWizardColorSync();
                }, 100);
            }
        }

        // Wizard 색상 동기화 설정 함수
        function setupWizardColorSync() {
            
            const wizardBaseColor = document.getElementById('wizardThemeBaseColor');
            const wizardBaseHex = document.getElementById('wizardThemeBaseHex');
            
            
            if (wizardBaseColor && wizardBaseHex) {
                
                // 기존 리스너 제거 (중복 방지)
                wizardBaseColor.removeEventListener('input', handleColorPickerChange);
                wizardBaseHex.removeEventListener('input', handleHexInputChange);
                
                // 새 리스너 추가 - input 이벤트로 실시간 반응
                wizardBaseColor.addEventListener('input', handleColorPickerChange);
                wizardBaseHex.addEventListener('input', handleHexInputChange);
                
                // change 이벤트도 추가 (마지막 확정값)
                wizardBaseColor.addEventListener('change', handleColorPickerChange);
                wizardBaseHex.addEventListener('change', handleHexInputChange);
                
                // 키보드 입력 시 더 즉각적인 반응을 위한 keyup 이벤트
                wizardBaseHex.addEventListener('keyup', (e) => {
                    const value = e.target.value.toUpperCase();
                    // Enter 키나 완전한 hex 값일 때 즉시 업데이트
                    if (e.key === 'Enter' || /^#[0-9A-F]{6}$/i.test(value)) {
                        clearTimeout(window.colorUpdateTimeout);
                        optimizedPreviewUpdate(value);
                    }
                });
                
                // 초기 미리보기 업데이트
                const initialColor = wizardBaseColor.value || wizardBaseHex.value;
                if (initialColor) {
                    setTimeout(() => {
                        updateAllModePreviewsWithColor(initialColor);
                        updateWizardStepIndicator(initialColor);
                    }, 100);
                }
                
            } else {
                console.error('❌ Wizard color elements not found!');
                document.querySelectorAll('[id*="wizard"]').forEach(el => {
                });
            }
        }

        function handleColorPickerChange() {
            const wizardBaseColor = document.getElementById('wizardThemeBaseColor');
            const wizardBaseHex = document.getElementById('wizardThemeBaseHex');
            
            if (wizardBaseColor && wizardBaseHex) {
                const oldHexValue = wizardBaseHex.value;
                const newColorValue = wizardBaseColor.value.toUpperCase();
                
                wizardBaseHex.value = newColorValue;
                
                // 실시간 미리보기 업데이트 (성능 최적화)
                clearTimeout(window.colorUpdateTimeout);
                window.colorUpdateTimeout = setTimeout(() => {
                    optimizedPreviewUpdate(newColorValue);
                    updateRecommendedBackground(newColorValue);
                }, 30); // 30ms 디바운스로 더 빠른 반응
                
            } else {
                console.error('❌ Elements not found in handleColorPickerChange');
            }
        }

        function handleHexInputChange() {
            const wizardBaseColor = document.getElementById('wizardThemeBaseColor');
            const wizardBaseHex = document.getElementById('wizardThemeBaseHex');
            
            if (wizardBaseColor && wizardBaseHex) {
                const hexValue = wizardBaseHex.value.toUpperCase();
                
                if (/^#[0-9A-F]{6}$/i.test(hexValue)) {
                    wizardBaseColor.value = hexValue;
                    
                    // 실시간 미리보기 업데이트 (성능 최적화)
                    clearTimeout(window.colorUpdateTimeout);
                    window.colorUpdateTimeout = setTimeout(() => {
                        optimizedPreviewUpdate(hexValue);
                        updateRecommendedBackground(hexValue);
                    }, 80); // 타이핑 시에는 조금 더 긴 디바운스
                    
                } else if (hexValue.length >= 3) { // 최소 3자리 이상일 때만 경고
                    console.warn('⚠️ Invalid hex format:', hexValue);
                }
            } else {
                console.error('❌ Elements not found in handleHexInputChange');
            }
        }

        // 모드 설정 함수
        function setMode(mode) {
            currentMode = mode;
            
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            event.target.classList.add('active');
            updateDisplay();
        }

        // 디스플레이 업데이트
        function updateDisplay() {
            var baseColor = document.getElementById('baseColor');
            if (!baseColor) return;

            var inputHex = baseColor.value;
            var tuningVal = 0;
            
            console.log('updateDisplay called with:', inputHex);
            
            // Fine Tuning 값 가져오기
            if (document.getElementById('autoTuning').checked) {
                tuningVal = colorGenerator.getAutoTuningValue(inputHex);
                document.getElementById('tuningSlider').value = tuningVal;
                document.getElementById('tuningValue').textContent = tuningVal;
            } else {
                tuningVal = parseInt(document.getElementById('tuningSlider').value) || 0;
            }
            
            console.log('Generating colors with tuningVal:', tuningVal);
            
            // tuning 값을 포함하여 색상 생성
            try {
                generatedColors = colorGenerator.generateColors(inputHex, currentMode, tuningVal);
                console.log('Generated colors:', generatedColors);
            } catch (error) {
                console.error('Error generating colors:', error);
                return;
            }
            
            displayColors();
        }

        // 색상 표시
        function displayColors() {
            var container = document.getElementById('colorResults');
            console.log('displayColors called, container found:', !!container);
            console.log('generatedColors length:', generatedColors.length);
            
            if (!container) return;

            container.innerHTML = '';
            
            generatedColors.forEach(color => {
                console.log('Creating row for color:', color);
                var row = createColorRow(color);
                container.appendChild(row);
            });
        }

        // 색상 행 생성
        function createColorRow(color) {
            var row = document.createElement('div');
            row.className = color.isClosest ? 'color-row closest' : 'color-row';
            
            var rgb = ColorUtils.hexToRgb(color.hex);
            var textColor = ColorUtils.getLuminance(rgb.r, rgb.g, rgb.b) > 0.5 ? '#000' : '#fff';
            
            // 접근성 배지 추가
            var badge = '';
            if (color.contrast >= 7) {
                badge = '<span style="background: #28a745; color: white; padding: 1px 4px; border-radius: 2px; font-size: 7px; margin-left: 4px;">AAA</span>';
            } else if (color.contrast >= 4.5) {
                badge = '<span style="background: #ffc107; color: black; padding: 1px 4px; border-radius: 2px; font-size: 7px; margin-left: 4px;">AA</span>';
            } else if (color.contrast >= 3) {
                badge = '<span style="background: #fd7e14; color: white; padding: 1px 4px; border-radius: 2px; font-size: 7px; margin-left: 4px;">A</span>';
            }
            
            row.innerHTML = `
                <div class="color-swatch" style="background: ${color.hex}; color: ${textColor}">
                    ${color.step}${color.isClosest ? ' ★' : ''}
                </div>
                <div class="color-info">
                    <span class="color-hex" onclick="copyColor('${color.hex}')">${color.hex.toUpperCase()}</span>
                    <span>${color.contrast.toFixed(2)}:1 ${badge}</span>
                </div>
            `;
            
            return row;
        }

        // 스텝 분류 표시 업데이트 (Scale Generator용)
        function updateStepIndicator(hex) {
            var stepIndicator = document.getElementById('stepIndicator');
            var classificationBadge = document.getElementById('classificationBadge');
            var classificationInfo = document.getElementById('stepClassificationInfo');
            var classificationText = document.getElementById('stepClassificationText');
            
            if (!stepIndicator || !classificationBadge) return;
            
            // ColorGenerator에서 생성된 색상들과 일치시키기
            var colors = colorGenerator.generateColors(hex, 'light', 0);
            var closestColor = colors.find(color => color.isClosest);
            var closestStep = closestColor ? closestColor.step : 500;
            var colorRange = getColorRangeFromStep(closestStep, hex);
            
            stepIndicator.textContent = `Step: ${closestStep}`;
            
            if (colorRange === 'light') {
                stepIndicator.className = 'step-indicator step-light';
                classificationBadge.textContent = '밝음';
                classificationBadge.className = 'classification-badge classification-light';
                
                if (classificationInfo) classificationInfo.style.display = 'block';
                if (classificationText) classificationText.textContent = `입력 색상이 Step ${closestStep}에 해당합니다. 밝은 범위로 분류되어 Mode별로 다른 매핑이 적용됩니다.`;
            } else if (colorRange === 'medium') {
                stepIndicator.className = 'step-indicator step-medium';
                classificationBadge.textContent = '중간';
                classificationBadge.className = 'classification-badge classification-medium';
                
                if (classificationInfo) classificationInfo.style.display = 'block';
                if (classificationText) classificationText.textContent = `입력 색상이 Step ${closestStep}에 해당합니다. 중간 범위로 분류되어 Mode별로 다른 매핑이 적용됩니다.`;
            } else {
                stepIndicator.className = 'step-indicator step-dark';
                classificationBadge.textContent = '어두움';
                classificationBadge.className = 'classification-badge classification-dark';
                
                if (classificationInfo) classificationInfo.style.display = 'block';
                if (classificationText) classificationText.textContent = `입력 색상이 Step ${closestStep}에 해당합니다. 어두운 범위로 분류되어 Mode별로 다른 매핑이 적용됩니다.`;
            }
        }

        // 스텝 분류 표시 업데이트 (Custom Theme Wizard용)
        function updateWizardStepIndicator(hex) {
            var stepIndicator = document.getElementById('wizardStepIndicator');
            var classificationBadge = document.getElementById('wizardClassificationBadge');
            var classificationInfo = document.getElementById('wizardStepClassificationInfo');
            var classificationText = document.getElementById('wizardStepClassificationText');
            
            if (!stepIndicator || !classificationBadge) return;
            
            // ColorGenerator에서 생성된 색상들과 일치시키기
            var colors = colorGenerator.generateColors(hex, 'light', 0);
            var closestColor = colors.find(color => color.isClosest);
            var closestStep = closestColor ? closestColor.step : 500;
            var colorRange = getColorRangeFromStep(closestStep, hex);
            
            stepIndicator.textContent = `Step: ${closestStep}`;
            
            if (colorRange === 'light') {
                stepIndicator.className = 'step-indicator step-light';
                classificationBadge.textContent = '밝음';
                classificationBadge.className = 'classification-badge classification-light';
                
                if (classificationInfo) classificationInfo.style.display = 'block';
                if (classificationText) classificationText.textContent = `입력 색상이 Step ${closestStep}에 해당합니다. 밝은 범위로 분류되어 Mode별로 다른 매핑이 적용됩니다.`;
            } else if (colorRange === 'medium') {
                stepIndicator.className = 'step-indicator step-medium';
                classificationBadge.textContent = '중간';
                classificationBadge.className = 'classification-badge classification-medium';
                
                if (classificationInfo) classificationInfo.style.display = 'block';
                if (classificationText) classificationText.textContent = `입력 색상이 Step ${closestStep}에 해당합니다. 중간 범위로 분류되어 Mode별로 다른 매핑이 적용됩니다.`;
            } else {
                stepIndicator.className = 'step-indicator step-dark';
                classificationBadge.textContent = '어두움';
                classificationBadge.className = 'classification-badge classification-dark';
                
                if (classificationInfo) classificationInfo.style.display = 'block';
                if (classificationText) classificationText.textContent = `입력 색상이 Step ${closestStep}에 해당합니다. 어두운 범위로 분류되어 Mode별로 다른 매핑이 적용됩니다.`;
            }
        }

        function generateCustomTheme() {
            var baseColor = document.getElementById('themeBaseColor').value;
            var themeName = document.getElementById('themeNameInput').value || 'brand-theme';
            var applicationMode = document.querySelector('input[name="applicationMode"]:checked').value;
            
            // Fine Tuning 값 가져오기
            var tuningValue = document.getElementById('autoTuning').checked ? 
                colorGenerator.getAutoTuningValue(baseColor) :
                parseInt(document.getElementById('tuningSlider').value) || 0;
            
            
            // themeGenerator에 tuning 값 전달
            currentTheme = themeGenerator.generateTheme(baseColor, themeName, applicationMode, tuningValue);
            
            // 모드 카드 미리보기 업데이트
            updateModeCardPreviews();
            
            displayThemePreview(currentTheme);
            
            showMessage(`${themeName} 테마가 생성되었습니다!`);
        }

            function displayThemePreview(theme) {
                var container = document.getElementById('themePreviewContainer');
                
                let modeDescription = '';
                if (theme.applicationMode === 'accent-on-bg-off') {
                    modeDescription = 'Mode 1: 강조 요소 ON / 배경 요소 OFF';
                } else if (theme.applicationMode === 'accent-on-bg-fixed') {
                    modeDescription = 'Mode 2: 강조 요소 ON / 배경 Light 고정';
                } else if (theme.applicationMode === 'accent-off-bg-on') {
                    modeDescription = 'Mode 3: 강조 요소 OFF / 배경 요소 ON';
                } else if (theme.applicationMode === 'accent-on-bg-black') {
                    modeDescription = 'Mode 4: 강조 요소 ON / 배경 Dark 고정';
                }
                
                container.innerHTML = `
                    <div style="background: #e8f5e8; border: 1px solid #d4edda; border-radius: 4px; padding: 8px; margin-top: 8px;">
                        <p style="font-size: 10px; color: #155724; margin: 0;">
                            <strong>적용된 Mode:</strong> ${modeDescription}<br>
                            <strong>Closest Step:</strong> Light: ${theme.selectedStep || 'N/A'}, Dark: ${theme.selectedStep || 'N/A'}
                        </p>
                    </div>
                    
                    <button class="action-btn btn-success" onclick="createCustomThemeVariables()">
                        모든 테마 변수 생성
                    </button>
                    
                    <div style="margin-top: 8px;">
                        <button class="action-btn btn-secondary" onclick="applyCustomMode('CustomLight')" style="width: 100%;">
                            Custom Theme 적용하기
                        </button>
                    </div>
                `;
            }

        function createCustomThemeVariables() {
            if (!currentTheme) {
                showMessage('먼저 테마를 생성해주세요!');
                return;
            }
            
            
            parent.postMessage({
                pluginMessage: {
                    type: 'create-custom-theme',
                    theme: currentTheme
                }
            }, '*');
            
            showMessage('Custom Theme Variables 생성 중...');
        }

        // Custom Mode 적용 함수
        function applyCustomMode(modeName) {
            
            if (!currentTheme) {
                showMessage('먼저 테마를 생성해주세요!');
                return;
            }
            
            parent.postMessage({
                pluginMessage: {
                    type: 'apply-theme-colors-to-frame',
                    theme: currentTheme
                }
            }, '*');
            
            showMessage('테마 토큰을 Frame에 적용 중...');
        }
        // 아코디언 토글 함수 추가
        function toggleThemePreview() {
        var header = document.getElementById('themePreviewAccordion');
        var content = document.getElementById('themePreviewContent');
        
        header.classList.toggle('active');
        content.classList.toggle('expanded');
        }
        // 색상 복사
        function copyColor(hex) {
            // 클릭된 요소 찾기
            var elements = document.querySelectorAll('.color-hex');
            elements.forEach(function(el) {
                if (el.textContent === hex.toUpperCase()) {
                    el.classList.add('copied');
                    setTimeout(function() {
                        el.classList.remove('copied');
                    }, 500);
                }
            });
            
            navigator.clipboard.writeText(hex).then(function() {
                showMessage(`📋 ${hex} 복사됨!`);
            }).catch(function() {
                showMessage('복사 실패');
            });
        }

        // 변수 생성 함수들
function createVariables() {
    var variableName = document.getElementById('variableName').value.trim();
    
    if (!variableName) {
        showMessage('변수 이름을 입력해주세요!');
        return;
    }
    
    if (generatedColors.length === 0) {
        showMessage('먼저 색상을 생성해주세요!');
        return;
    }

    // Fine Tuning 값 포함
    var tuningValue = document.getElementById('autoTuning').checked ? 
        colorGenerator.getAutoTuningValue(document.getElementById('baseColor').value) :
        parseInt(document.getElementById('tuningSlider').value) || 0;

    parent.postMessage({
        pluginMessage: {
            type: 'create-variables',
            colors: generatedColors,
            variableName: variableName,
            mode: currentMode,
            dualMode: false,
            tuningValue: tuningValue  // 추가
        }
    }, '*');
    
    showMessage('Variables 생성 중...');
}

function createDualModeVariables() {
    var variableName = document.getElementById('variableName').value.trim();
    
    if (!variableName) {
        showMessage('변수 이름을 입력해주세요!');
        return;
    }

    var baseColor = document.getElementById('baseColor').value;
    
    // Fine Tuning 값 포함
    var tuningValue = document.getElementById('autoTuning').checked ? 
        colorGenerator.getAutoTuningValue(baseColor) :
        parseInt(document.getElementById('tuningSlider').value) || 0;
    
    // Light 모드 색상 생성 (tuning 값 포함)
    var lightColors = colorGenerator.generateColors(baseColor, 'light', tuningValue);
    // Dark 모드 색상 생성 (tuning 값 포함)
    var darkColors = colorGenerator.generateColors(baseColor, 'dark', tuningValue);
    
    parent.postMessage({
        pluginMessage: {
            type: 'create-variables',
            lightColors: lightColors,
            darkColors: darkColors,
            variableName: variableName,
            dualMode: true,
            tuningValue: tuningValue  // 추가
        }
    }, '*');
    
    showMessage('Light + Dark Variables 생성 중...');
}

function createStyles() {
    var variableName = document.getElementById('variableName').value.trim() || 'color';
    
    if (generatedColors.length === 0) {
        showMessage('먼저 색상을 생성해주세요!');
        return;
    }

    parent.postMessage({
        pluginMessage: {
            type: 'create-styles',
            colors: generatedColors,
            styleName: variableName,
            mode: currentMode
        }
    }, '*');
    
    showMessage('Color Styles 생성 중...');
}

// 메시지 수신 처리 수정
window.addEventListener('message', (event) => {
    var msg = event.data.pluginMessage;
    if (!msg) return;

    
    switch(msg.type) {
        case 'plugin-ready':
            break;
        case 'variable-created':
            if (msg.success) {
                var modeText = msg.dualMode ? 'Light + Dark' : currentMode;
                showMessage(`✅ ${msg.count}개의 ${modeText} Variables 생성 완료!`);
            } else {
                showMessage('에러: ' + msg.error);
            }
            break;
        case 'style-created':
            if (msg.success) {
                showMessage(`✅ ${msg.count}개의 Color Styles 생성 완료!`);
            } else {
                showMessage('에러: ' + msg.error);
            }
            break;
        case 'custom-theme-created':
            if (msg.success) {
                showMessage(`${msg.themeName} 테마 생성 완료! (${msg.count || 0}개 변수)`);
            } else {
                showMessage('테마 생성 에러: ' + msg.error);
            }
            break;
        case 'custom-mode-applied':
            if (msg.success) {
                var message = msg.modeName + ' 모드 적용 완료!';
                if (msg.cleared && msg.cleared > 0) {
                    message += ' (' + msg.count + '개 적용, ' + msg.cleared + '개 자식 상속)';
                } else {
                    message += ' (' + msg.count + '개 적용)';
                }
                showMessage(message);
            } else {
                showMessage('모드 적용 에러: ' + msg.error);
            }
            break;
        case 'error':
            showMessage('에러: ' + msg.message);
            break;
    }
});

        // 톤 매칭 관련 함수들
        function setReferenceColor() {
            var picker = document.getElementById('referenceColorPicker');
            var hex = document.getElementById('referenceColorHex');
            
            referenceColor = {
                hex: picker.value.toUpperCase(),
                hsl: ColorUtils.hexToHsl(picker.value)
            };
            
            updateReferenceDisplay();
            showMessage('기준 색상이 설정되었습니다!');
        }

        function clearReference() {
            referenceColor = null;
            updateReferenceDisplay();
            clearToneMatchingResults();
            showMessage('기준 색상이 초기화되었습니다.');
        }

        function updateReferenceDisplay() {
            var statusElement = document.getElementById('referenceStatus');
            var displayElement = document.getElementById('referenceDisplay');
            
            if (!referenceColor) {
                statusElement.textContent = '현재 설정된 기준 컬러가 없습니다.';
                statusElement.style.color = '#666';
                displayElement.innerHTML = '';
                return;
            }
            
            statusElement.textContent = `Reference Set: ${referenceColor.hex}`;
            statusElement.style.color = '#28a745';
            
            var [h, s, l] = referenceColor.hsl;
            displayElement.innerHTML = `
                <div class="reference-display">
                    <div class="reference-color" style="background: ${referenceColor.hex};"></div>
                    <div class="reference-info">
                        <h4>Reference Active</h4>
                        <p><strong>${referenceColor.hex}</strong></p>
                        <p>HSL(${Math.round(h)}°, ${Math.round(s)}%, ${Math.round(l)}%)</p>
                    </div>
                </div>
            `;
        }

        function generateToneMatching() {
            if (!referenceColor) {
                showMessage('먼저 기준 색상을 설정해주세요!');
                return;
            }
            
            var newColorHex = document.getElementById('newColorPicker').value;
            
            // 백엔드에 톤 매칭 요청
            parent.postMessage({
                pluginMessage: {
                    type: 'generate-tone-matching',
                    referenceColor: referenceColor.hex,
                    inputColor: newColorHex
                }
            }, '*');
            
            showMessage('톤 매칭 제안을 생성하는 중...');
        }

        function displayToneMatchingSuggestions(originalHex, suggestions) {
            var container = document.getElementById('toneMatchingResults');
            
            container.innerHTML = `
                <div style="background: white; border: 2px solid #17a2b8; border-radius: 6px; padding: 12px; margin: 8px 0;">
                    <h4 style="color: #17a2b8; margin-bottom: 8px; font-size: 11px;">🎨 Tone Matching Results</h4>
                    <p style="margin-bottom: 8px; font-size: 9px;">
                        Original: <strong>${originalHex.toUpperCase()}</strong><br>
                        → Adjusted to match reference tone:
                    </p>
                    
                    <div class="tone-suggestions">
                        ${suggestions.map((suggestion, index) => `
                            <div class="tone-suggestion" onclick="applyToneToGenerator('${suggestion.hex}')">
                                <div class="tone-color-display" style="background: ${suggestion.hex};"></div>
                                <div class="tone-suggestion-title">${suggestion.type}</div>
                                <div class="tone-suggestion-hex">${suggestion.hex.toUpperCase()}</div>
                                <div class="tone-suggestion-desc">${suggestion.explanation}</div>
                            </div>
                        `).join('')}
                    </div>
                </div>
                
                <div class="info-box">
                    <h5>💡 Tone Matching:</h5>
                    <p>• 제안은 기준 색상의 톤과 매칭됩니다.<br>
                    • 색상을 클릭하면 Scale Generator에 적용됩니다.<br>
                    • 일관된 브랜드 톤으로 13단계 스케일 생성이 가능합니다.</p>
                </div>
            `;
        }

        function applyToneToGenerator(hex) {
            switchTab('generator');
            document.getElementById('baseColor').value = hex;
            document.getElementById('hexInput').value = hex.toUpperCase();
            updateDisplay();
            showMessage(`${hex} 색상이 Generator에 적용되었습니다!`);
        }

        function clearToneMatchingResults() {
            var container = document.getElementById('toneMatchingResults');
            if (container) container.innerHTML = '';
        }

        // 메시지 표시
        function showMessage(message) {
            var el = document.getElementById('successMessage');
            if (el) {
                el.textContent = message;
                el.classList.add('show');
                setTimeout(() => el.classList.remove('show'), 3000);
            }
        }

        // 이벤트 리스너 설정
        function setupEventListeners() {

            // 탭 버튼들
            const generatorTab = document.getElementById('generatorTab');
            const toneMatchingTab = document.getElementById('toneMatchingTab');
            const customThemeTab = document.getElementById('customThemeTab');
            
            if (generatorTab) {
                generatorTab.addEventListener('click', () => {
                    console.log('Generator tab clicked');
                    switchTab('generator');
                });
            } else {
                console.warn('generatorTab not found');
            }
            
            if (toneMatchingTab) {
                toneMatchingTab.addEventListener('click', () => {
                    console.log('Tone matching tab clicked');
                    switchTab('tone-matching');
                });
            } else {
                console.warn('toneMatchingTab not found');
            }
            
            if (customThemeTab) {
                customThemeTab.addEventListener('click', () => {
                    console.log('Custom theme tab clicked');
                    switchTab('custom-theme');
                });
            } else {
                console.warn('customThemeTab not found');
            }

            // 색상 입력
            var baseColor = document.getElementById('baseColor');
            var hexInput = document.getElementById('hexInput');

            if (baseColor && hexInput) {
                baseColor.addEventListener('input', () => {
                    hexInput.value = baseColor.value.toUpperCase();
                    updateDisplay();
                    updateStepIndicator(baseColor.value);
                    // 모드 미리보기도 업데이트
                    if (document.getElementById('wizardStep3').classList.contains('active')) {
                        updateAllModePreviewsWithColor(baseColor.value);
                    }
                });

                hexInput.addEventListener('input', () => {
                    if (/^#[0-9A-F]{6}$/i.test(hexInput.value)) {
                        baseColor.value = hexInput.value;
                        updateDisplay();
                        updateStepIndicator(hexInput.value);
                        // 모드 미리보기도 업데이트
                        if (document.getElementById('wizardStep3').classList.contains('active')) {
                            updateAllModePreviewsWithColor(hexInput.value);
                        }
                    }
                });
            }

            // Fine Tuning 이벤트 리스너
            var autoTuning = document.getElementById('autoTuning');
            var tuningSlider = document.getElementById('tuningSlider');
            var tuningValue = document.getElementById('tuningValue');
            var tuningStatus = document.getElementById('tuningStatus');

            if (autoTuning && tuningSlider && tuningValue && tuningStatus) {
                autoTuning.addEventListener('change', function() {
                if (this.checked) {
                    // Auto 모드
                    var baseColor = document.getElementById('baseColor').value;
                    var autoValue = colorGenerator.getAutoTuningValue(baseColor);
                    tuningSlider.value = autoValue;
                    tuningSlider.disabled = true;
                    tuningValue.textContent = autoValue;
                    tuningStatus.textContent = 'Auto: ' + autoValue;
                    tuningStatus.className = 'auto';
                } else {
                    // Manual 모드
                    tuningSlider.disabled = false;
                    tuningStatus.textContent = 'Manual: ' + tuningSlider.value;
                    tuningStatus.className = '';
                }
                updateDisplay();
            });

                tuningSlider.addEventListener('input', function() {
                    if (!autoTuning.checked) {
                        tuningValue.textContent = this.value;
                        tuningStatus.textContent = 'Manual: ' + this.value;
                        updateDisplay();
                    }
                });
            } else {
                console.warn('Fine Tuning elements not found');
            }

            // 톤 매칭 관련
            const setRefBtn = document.getElementById('setRefBtn');
            const clearRefBtn = document.getElementById('clearRefBtn');
            const getSuggestionsBtn = document.getElementById('getSuggestionsBtn');
            
            if (setRefBtn) {
                setRefBtn.addEventListener('click', setReferenceColor);
            } else {
                console.warn('setRefBtn not found');
            }
            
            if (clearRefBtn) {
                clearRefBtn.addEventListener('click', clearReference);
            } else {
                console.warn('clearRefBtn not found');
            }
            
            if (getSuggestionsBtn) {
                getSuggestionsBtn.addEventListener('click', generateToneMatching);
            } else {
                console.warn('getSuggestionsBtn not found');
            }

            // Reference 색상 입력 동기화
            var refPicker = document.getElementById('referenceColorPicker');
            var refHex = document.getElementById('referenceColorHex');
            
            if (refPicker && refHex) {
                refPicker.addEventListener('input', () => {
                    refHex.value = refPicker.value.toUpperCase();
                });
                
                refHex.addEventListener('input', () => {
                    if (/^#[0-9A-F]{6}$/i.test(refHex.value)) {
                        refPicker.value = refHex.value;
                    }
                });
            } else {
                console.warn('Reference color elements not found');
            }

            // New 색상 입력 동기화
            var newPicker = document.getElementById('newColorPicker');
            var newHex = document.getElementById('newColorHex');
            
            if (newPicker && newHex) {
                newPicker.addEventListener('input', () => {
                    newHex.value = newPicker.value.toUpperCase();
                });
                
                newHex.addEventListener('input', () => {
                    if (/^#[0-9A-F]{6}$/i.test(newHex.value)) {
                        newPicker.value = newHex.value;
                    }
                });
            } else {
                console.warn('New color elements not found');
            }

            // Custom Theme 관련 (구버전)
            var themeBaseColor = document.getElementById('themeBaseColor');
            var themeBaseHex = document.getElementById('themeBaseHex');
            
            if (themeBaseColor && themeBaseHex) {
                themeBaseColor.addEventListener('input', () => {
                    themeBaseHex.value = themeBaseColor.value.toUpperCase();
                    updateStepIndicator(themeBaseColor.value);
                });
                
                themeBaseHex.addEventListener('input', () => {
                    if (/^#[0-9A-F]{6}$/i.test(themeBaseHex.value)) {
                        themeBaseColor.value = themeBaseHex.value;
                        updateStepIndicator(themeBaseHex.value);
                    }
                });
            } else {
                console.warn('Custom Theme (old version) elements not found');
            }

            // Radio button 스타일 업데이트
            document.querySelectorAll('input[name="applicationMode"]').forEach(radio => {
                radio.addEventListener('change', (e) => {
                    document.querySelectorAll('.radio-option').forEach(option => {
                        option.classList.remove('selected');
                    });
                    e.target.parentElement.classList.add('selected');
                });
            });

            // Wizard 이벤트 리스너
            
            // Step 1 색상 입력 동기화
            setupWizardColorSync();
            
            // Mode 카드 클릭 이벤트
            document.querySelectorAll('.mode-card').forEach(card => {
                card.addEventListener('click', () => {
                    const mode = card.dataset.mode;
                    selectModeCard(card, mode);
                });
            });

            // 초기화 완료
        }

        // 플러그인 메시지 수신
        window.addEventListener('message', (event) => {
            var msg = event.data.pluginMessage;
            if (!msg) return;

                    
            switch(msg.type) {
                case 'plugin-ready':
                            break;
                case 'variable-created':
                    if (msg.success) {
                        showMessage(`Variables 생성 완료! (${msg.count || 0}개)`);
                    } else {
                        showMessage('에러: ' + msg.error);
                    }
                    break;
                case 'custom-theme-created':
                    if (msg.success) {
                        showMessage(`${msg.themeName} 테마 생성 완료! (${msg.count || 0}개 변수)`);
                    } else {
                        showMessage('테마 생성 에러: ' + msg.error);
                    }
                    break;
                case 'custom-mode-applied':
                    if (msg.success) {
                        var message = msg.modeName + ' 모드 적용 완료!';
                        if (msg.cleared && msg.cleared > 0) {
                            message += ' (' + msg.count + '개 적용, ' + msg.cleared + '개 자식 상속)';
                        } else {
                            message += ' (' + msg.count + '개 적용)';
                        }
                        showMessage(message);
                    } else {
                        showMessage('모드 적용 에러: ' + msg.error);
                    }
                    break;
                case 'tone-matching-complete':
                    displayToneMatchingSuggestions(msg.originalColor, msg.suggestions);
                    showMessage('톤 매칭 제안이 완료되었습니다!');
                    break;
                case 'tone-matching-error':
                    showMessage('톤 매칭 에러: ' + msg.error);
                    break;
                case 'error':
                    showMessage('에러: ' + msg.message);
                    break;
            }
        });

        // 초기화
        function init() {
            setupEventListeners();
            updateDisplay();
            
            // 초기 컬러 분류 표시
            const baseColor = document.getElementById('baseColor');
            if (baseColor) {
                updateStepIndicator(baseColor.value);
            }
            
            // Custom Theme 탭이 기본이므로 초기화 시에도 wizard 색상 동기화 설정
            setTimeout(() => {
                setupWizardColorSync();
                initBackgroundSelection();
                
                // 초기 추천 배경색 설정
                const wizardBaseColor = document.getElementById('wizardThemeBaseColor');
                if (wizardBaseColor && wizardBaseColor.value) {
                    updateRecommendedBackground(wizardBaseColor.value);
                }
            }, 200);
            
        }
        
        
        // =====================================
        // Annotation 제어 함수들
        // =====================================
        
        function showMappingInfo() {
            // 현재 테마 정보와 함께 메시지 전송
            parent.postMessage({
                pluginMessage: {
                    type: 'annotation-control',
                    action: 'show-mapping',
                    theme: currentTheme // 현재 테마 정보 포함
                }
            }, '*');
        }
        
        // Mapping 정보 표시 상태 업데이트
        function updateMappingStatus(message, color = '#666') {
            const statusSpan = document.getElementById('mappingStatus');
            if (statusSpan) {
                statusSpan.textContent = message;
                statusSpan.style.color = color;
            }
        }

        // DOM 로드 완료 후 초기화
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }

        // Backend에서 오는 메시지 처리
        window.addEventListener('message', function(event) {
            const msg = event.data.pluginMessage;
            if (msg && msg.type === 'frame-selection-result') {
                console.log('📨 Frame 선택 결과 수신:', msg.frameInfo);
                if (typeof window.handleFrameSelectionResult === 'function') {
                    window.handleFrameSelectionResult(msg.frameInfo);
                }
            }
        });

        // 페이지 로드 완료 후에도 확인
        window.addEventListener('load', () => {
            if (generatedColors.length === 0) {
                updateDisplay();
            }
        });
    </script>