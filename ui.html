<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Generator</title>
    <!-- Fonts: Bricolage Grotesque (Latin, digits) and Pretendard (KR) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,200..800&display=swap" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/variable/pretendardvariable.css" rel="stylesheet">
    <style>
        /* CSS Variables - Design System */
        :root {
            /* Colors */
            --basicwhite: #ffffff;
            --basicblack: #000000;
            --basicblack-3: #666666;
            --basicblack-8: #333333;
            --basicgray: #f0f0f0;
            --specialblack-1: #e0e0e0;
            --specialblue-3: #e3f2fd;
            --accentblue: #007aff;
            
            /* Primary Color Scale */
            --primary-50: #eff6ff;
            --primary-100: #dbeafe;
            --primary-200: #bfdbfe;
            --primary-300: #93c5fd;
            --primary-400: #60a5fa;
            --primary-500: #3b82f6;
            --primary-600: #2563eb;
            --primary-700: #1d4ed8;
            --primary-800: #1e40af;
            --primary-900: #1e3a8a;
            
            /* Typography */
            --body-1-regular-font-family: 'Bricolage Grotesque', 'Pretendard Variable', Pretendard, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Noto Sans KR', 'Apple SD Gothic Neo', 'Malgun Gothic', Helvetica, Arial, sans-serif;
            --body-1-regular-font-size: 12px;
            --body-1-regular-font-weight: 400;
            --body-1-regular-line-height: 16px;
            
            --body-1-semi-bold-font-family: 'Bricolage Grotesque', 'Pretendard Variable', Pretendard, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Noto Sans KR', 'Apple SD Gothic Neo', 'Malgun Gothic', Helvetica, Arial, sans-serif;
            --body-1-semi-bold-font-size: 12px;
            --body-1-semi-bold-font-weight: 600;
            --body-1-semi-bold-line-height: 16px;
            
            --heading-2-semi-bold-font-family: 'Bricolage Grotesque', 'Pretendard Variable', Pretendard, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Noto Sans KR', 'Apple SD Gothic Neo', 'Malgun Gothic', Helvetica, Arial, sans-serif;
            --heading-2-semi-bold-font-size: 14px;
            --heading-2-semi-bold-font-weight: 600;
            --heading-2-semi-bold-line-height: 20px;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: var(--body-1-regular-font-family);
            background: #ffffff;
            color: var(--basicblack-8);
            font-size: var(--body-1-regular-font-size);
            line-height: var(--body-1-regular-line-height);
            overflow-x: hidden;
        }

        .container {
            padding: 0;
            width: 100%;
            max-width: 100%;
            background: var(--basicwhite);
            border-radius: 8px;
            margin: 0;
            box-sizing: border-box;
            overflow: visible;
        }

        .tab-navigation {
            position: sticky;
            top: 0;
            z-index: 20;
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            padding: 0 8px 0 12px;
            gap: 16px;
            width: 100%;
            height: 40px;
            background: #FFFFFF;
            box-sizing: border-box;
        }

        .tab-btn {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            padding: 0;
            gap: 4px;
            height: 40px;
            border: none;
            background: transparent;
            cursor: pointer;
            font-weight: 400;
            font-size: 11px;
            line-height: 16px;
            letter-spacing: 0.005em;
            color: rgba(0, 0, 0, 0.3);
            flex: none;
        }

        .tab-btn:nth-child(1) {
            width: fit-content;
        }

        .tab-btn:nth-child(2) {
            width:  fit-content;
        }

        .tab-btn:nth-child(3) {
            width:  fit-content;
        }

        .tab-btn.active {
            font-weight: 600;
            color: #000000;
        }

        .tab-btn:active {
            transform: scale(0.98);
        }

        .tab-home-btn {
            margin-left: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 40px;
            border: none;
            background: transparent;
            cursor: pointer;
            padding: 0;
        }

        .tab-home-btn svg {
            width: 16px;
            height: 16px;
        }

        .tab-content {
            display: none;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
            overflow: hidden;
        }

        .tab-content.active {
            display: block;
            animation: fadeIn 0.3s ease-in;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
            overflow: hidden;
        }
        

        .section {
            background: var(--basicwhite);
            border-radius: 8px;
            border: 0.5px solid #00000010;
            padding: 12px;
            margin-bottom: 10px;
            box-shadow: 0 6px 4px rgba(0,0,0,0.04);
            box-sizing: border-box;
            width: 100%;
            max-width: 100%;
            overflow: hidden;
        }

        .section-title {
            font-size: 14px;
            font-weight: 600;
            color: #333;
        }

        /* Color Input - outer control */
        .color-input-group,
        .color-input-container {
            /* Color control */
            box-sizing: border-box;
            display: flex;
            flex-direction: row;
            justify-content: flex-start;
            align-items: center;
            padding: 0px 0px 0px 8px; /* inner left padding */

            width: 100%;
            max-width: 100%;
            height: 32px;
            gap: 8px;

            background: #FFFFFF; /* Basic/White */
            border: 1px solid rgba(0, 0, 0, 0.1); /* Special/Black 1 */
            border-radius: 4px;

            /* Inside auto layout */
            flex: none;
            order: 0;
            align-self: stretch;
            flex-grow: 0;
        }

        .inline-input-btn {
            border: none;
            background: transparent;
            color: #888;
            font-size: 10px;
            cursor: pointer;
            flex-shrink: 0;
            padding: 0 16px;
            height: auto;
        }

        .inline-input-btn:hover {
            color: #333;
            text-decoration: underline;
        }

        .custom-bg-hint {
            margin-top: 6px;
            font-size: 10px;
            color: #666;
            line-height: 1.4;
        }

        /* Swatch (input[type=color]) */
        .color-picker {
            box-sizing: border-box;
            width: 20px;
            height: 20px;
            border: 1px solid #FFFFFF; /* Basic/White */
            filter: drop-shadow(0px 1px 3px rgba(0, 0, 0, 0.08)); /* Shadow/Small */
            border-radius: 3px;
            cursor: pointer;
            flex-shrink: 0;
            appearance: none;
            -webkit-appearance: none;
            background: none;
            padding: 0;
        }


        /* WebKit color swatch normalization */
        .color-picker::-webkit-color-swatch-wrapper {
            padding: 0;
            border: none;
            border-radius: 4px;
        }

        .color-picker::-webkit-color-swatch {
            border: none;
        }

        /* Text (HEX) */
        .hex-input {
            flex: 1;
            text-transform: uppercase;
            height: 32px;
            min-width: 0; /* allow shrinking within 328px container */
            padding: 0 8px 0 0; /* right padding to mirror left gap */
            border: none; /* sits inside bordered container */
            background: transparent;
            font-family: var(--body-1-regular-font-family);
            font-weight: 400;
            font-size: 11px;
            line-height: 16px;
            letter-spacing: 0.005em;
            color: #000000; /* Basic/Black */
        }

        .hex-input:focus { outline: none; }

        .action-btn {
            /* Layout */
            width: 100%;
            height: 32px;
            padding: 0 12px;
            gap: 4px;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            white-space: nowrap;

            /* Visual */
            background: #F0F0F0; /* Basic/Gray */
            color: rgba(0, 0, 0, 0.8);
            border: none;
            border-radius: 3px;
            cursor: pointer;
            transition: background-color 0.2s ease, color 0.2s ease;

            /* Typography */
            font-family: var(--body-1-semi-bold-font-family);
            font-size: 11px;
            font-weight: 600;
            line-height: 16px;
            letter-spacing: 0.005em;
        }

        .btn-secondary {
            background: #F0F0F0; /* Basic/Gray */
            color: rgba(0, 0, 0, 0.8);
        }

        .btn-primary {
            background: #000;
            color: #fff;
        }
        .btn-success {
            background: #18A0FB; /* Accent/Blue */
            color: #FFFFFF; /* Basic/White */
        }

        .btn-primary:hover { background: #CCC; color:#FFF; }
        .btn-success:hover { background: #008be7; color: #FFFFFF; }

        .color-grid {
            flex-direction: column;
            gap: 4px;
            overflow-y: auto;
        }

        .color-row {
            display: flex;
            overflow: hidden;
            font-size: 10px;
        }

        .color-row.closest {
            background-color: #18A0FB10;
        }

        .color-swatch {
            width: 64px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 10px;
            color: white;
        }

        .color-info {
            flex: 1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 6px;
            height: auto;
        }

        .color-hex {
            font-family: 'Monaco', monospace;
            font-size: 9px;
            cursor: pointer;
            padding: 1px 3px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .color-hex:hover {
            background: #f0f8ff;
            transform: scale(1.05);
        }

        .success-message {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #00000095;
            color: white;
            padding: 8px 20px;
            border-radius: 4px;
            font-size: 12px;
            text-align: center;
            z-index: 9999;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            opacity: 0;
            transform: translateX(-50%) translateY(20px);
            transition: all 0.3s ease;
            pointer-events: none;
            width: calc(100% - 40px);
        }

        .success-message.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        /* 톤 매칭 스타일 */
        .reference-display {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: #18a0fb22;    
            border-radius: 6px;
            margin-bottom: 8px;
        }

        .reference-color {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .reference-info {
            flex: 1;
        }

        .reference-info h4 {
            font-size: 11px;
            color: #28a745;
            margin-bottom: 2px;
        }

        .reference-info p {
            font-size: 9px;
            color: #155724;
            margin: 0;
        }

        .tone-input-area {

            background: #f8f9fa;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            box-sizing: border-box;
            width: 100%;
            max-width: 100%;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            gap: 8px;

        }
        
        .button-group {
            display: flex;
            gap: 6px;
            margin-top: 8px;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
        }
        
        .button-group .action-btn {
            flex: 1;
            min-width: 0;
            white-space: nowrap;
            max-width: calc(50% - 3px);
        }

        .tone-suggestions {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
            margin-top: 8px;
        }

        .tone-suggestion {
            background: white;
            border-radius: 6px;
            padding: 8px;
            text-align: center;
            transition: all 0.2s ease;
            cursor: pointer;
            border: 1px solid #e0e0e0;
        }

        .tone-suggestion:hover {
            border-color: #000;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .tone-color-display {
            width: 40px;
            height: 24px;
            border-radius: 4px;
            margin: 0 auto 6px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.15);
        }

        .tone-suggestion-title {
            font-weight: 600;
            font-size: 10px;
            color: #333;
            margin-bottom: 3px;
        }

        .tone-suggestion-hex {
            font-family: 'Monaco', monospace;
            font-size: 9px;
            font-weight: 600;
            margin-bottom: 3px;
        }

        .tone-suggestion-desc {
            font-size: 8px;
            color: #666;
            line-height: 1.2;
        }

        .info-box {
            background: #f0f0f0;
            border: 1px solid #c7c7c7;
            border-radius: 4px;
            padding: 12px;
            margin-top: 8px;
        }

        .info-box h5 {
            color: #000000;
            font-size: 10px;
            margin-bottom: 4px;
        }

        .info-box p {
            font-size: 9px;
            color: #888;
            margin: 0;
            line-height: 1.3;
        }

        /* Custom Theme Wizard 스타일 */
        .wizard-progress {
            margin-top: 20px;
            margin-bottom: 20px;
            padding: 0 4px;
        }

        .simple-progress-bar {
            display: flex;
            height: 4px;
            background: var(--specialblack-1);
            border-radius: 2px;
            overflow: hidden;
        }

        .progress-segment {
            flex: 1;
            background: var(--specialblack-1);
            margin-right: 2px;
            border-radius: 2px;
            position: relative;
            overflow: hidden;
        }
        
        .progress-segment::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: var(--accentblue);
            transition: left 0.6s ease-out;
        }

        .progress-segment:last-child {
            margin-right: 0;
        }

        .progress-segment.active::before {
            left: 0;
        }

        .progress-segment.completed::before {
            left: 0;
            transition: none;
        }

        .wizard-step {
            display: none;
            animation: fadeIn 0.3s ease-in;
        }

        .wizard-step.active {
            display: block;
        }

        /* Make Custom Theme Step 1 and 2 render as sections side-by-side on one page */
        #customThemeContent .wizard-progress { display: none; }
        #customThemeContent #wizardStep1,
        #customThemeContent #wizardStep2 {
            display: block; /* show both */
            background: var(--basicwhite);
            border-radius: 8px;
            border: 0.5px solid #00000010;
            padding: 12px;
            margin-bottom: 10px;
            box-shadow: 0 6px 4px rgba(0,0,0,0.04);
            box-sizing: border-box;
            width: 100%;
            max-width: 100%;
            overflow: hidden;
        }
        #customThemeContent #wizardStep1 .step-header .step-title,
        #customThemeContent #wizardStep2 .step-header .step-title {
            color: #333;
            background: none;
            -webkit-background-clip: initial;
            -webkit-text-fill-color: initial;
            background-clip: initial;
        }
        /* Hide only Step 2 '이전' when both steps are visible */
        #customThemeContent #wizardStep2 .step-actions .btn-secondary { display: none; }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .step-header {
            text-align: left;
            margin-bottom: 12px;
            padding: 0px;
        }

        .section-title,
        .step-header .step-title {
            font-size: 13px;
            color: #1a202c;
            margin-bottom: 4px;
            font-weight: 600;
            background: #1a202c;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .step-header p {
            font-size: 12px;
            color: #888;
            margin: 0;
        }


        .input-group label {
            display: block;
            font-size: 11px;
            font-weight: 500;
            color: #333;
        }

        .color-preview {
            margin-top: 6px;
        }

        .preview-swatch {
            width: 40px;
            height: 20px;
            border-radius: 3px;
            background: #667eea;
            border: 1px solid #ccc;
        }

        .token-preview {
            background: #f5f5f5;
            border-radius: 4px;
            padding: 12px;
        }

        .token-item {
            display: block;
            margin-bottom: 8px;
            padding: 0;
            border: none;
        }

        .token-item:last-child {
            margin-bottom: 0;
        }

        .token-label {
            font-size: 11px;
            color: #333;
            font-weight: 500;
            margin-bottom: 2px;
        }

        .token-value {
            font-size: 11px;
            font-family: 'Monaco', monospace;
            color: #667eea;
            background: transparent;
            padding: 0;
            border-radius: 0;
            display: block;
        }

        /* Recent Colors */
        .recent-colors {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            padding: 0 12px 12px;
            margin-top: 10px;
            background: #FFFFFF;
            border: 1px solid rgba(0,0,0,0.06);
            border-radius: 6px;
        }
        .recent-header {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: space-between;
            padding: 12px 0px 8px 0px;
            gap: 7px;
            width: 100%;
        }
        .recent-title {
            font-family: var(--body-1-semi-bold-font-family);
            font-weight: 600;
            font-size: 11px;
            line-height: 16px;
            letter-spacing: 0.005em;
            color: rgba(0,0,0,0.8);
        }
        .recent-clear {
            border: none; background: transparent; color: #888; font-size: 10px; cursor: pointer;
        }
        .recent-clear:hover { color: #333; text-decoration: underline; }
        .recent-swatches { display: flex; flex-wrap: wrap; gap: 8px; padding-left:2px;  }
        .recent-swatch {
            width: 24px; height: 24px; border-radius: 20px;
            border: 0.5px solid rgba(0,0,0,0.2);
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            cursor: pointer;
        }
        .recent-swatch:hover { outline: 2px solid #18A0FB; outline-offset: 1px; }

        /* Force-hide wizard and generator step classification info */
        #wizardStepClassificationInfo { display: none !important; }
        #stepClassificationInfo { display: none !important; }

        .mode-cards {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 40px 12px;
            margin-bottom: 30px;
            padding:8px;
            width: 100%;
            justify-content: center;
            padding-bottom: 20px;
        }


        .mode-card {
            background: var(--basicwhite);
            border: 1px solid #00000010;
            border-radius: 6px;
            box-sizing: border-box;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            position: relative;
            width: 100%;
            height: 168px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 10px;
            overflow: visible;
        }

        .mode-card:hover {
            border-color: var(--accentblue);
            box-shadow: 0 4px 12px rgba(0, 122, 255, 0.15);
            transform: translateY(-1px);
        }

        .mode-card.selected {
            outline: 2px solid var(--accentblue);
            outline-offset: 2px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .card-checkbox {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 24px;
            height: 24px;
            border-radius: 14px;
            background: #ffffff80;
            border: 1px solid #00000010;
            box-sizing: border-box;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2px;
            transition: all 0.2s;
            z-index: 10;
        }

        .mode-card.selected .card-checkbox {
            background: #1f1f1f;
            border: 2px solid #000;
        }

        .checkbox-icon {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .checkbox-icon.unselected {
            opacity: 0.0;
        }

        .mode-card.selected .checkbox-icon.unselected {
            display: none;
        }
        
        /* 새로운 아이콘 구조 CSS */
        .mode-card .selected-icon {
            display: none !important;
        }
        .mode-card .unselected-icon {
            display: none !important;
        }
        .mode-card.selected .selected-icon {
            display: block !important;
        }
        .mode-card.selected .unselected-icon {
            display: none !important;
        }
        
        /* accent-on-bg-off 모드 배경색 적용 */
        .mode-card[data-mode="accent-on-bg-off"] {
            background: #e8edff;
        }
        
        /* accent-on-bg-black 모드 배경색 적용 */
        .mode-card[data-mode="accent-on-bg-black"] {
            background: #1f1f1f;
        }
        .mode-card[data-mode="accent-on-bg-black"] .preview-frame {
            background: none !important;
        }
        .mode-card[data-mode="accent-on-bg-black"] .card-label,
        .mode-card[data-mode="accent-on-bg-black"] .card-sub-label {
            color: white;
        }

        .card-preview {
            
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            width: 100%;
        }

        .preview-frame {
            width: 100%;
            height: 100%;
            
            border-radius: 3px;
            position: relative;
            transition: all 0.2s ease-in-out; /* 부드러운 색상 전환 애니메이션 */
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            box-sizing: border-box;
        }


        .frame-header {
            font-size: 8px;
            font-weight: 600;
            color: #333;
            text-align: left;
            padding: 8px 6px 12px 6px;
            width : 100%;
            
            display: flex;
            justify-content: flex-start;
            align-items: center;
        }
        .frame-header svg path {
            fill: #000000;
            transition: fill 0.3s ease;
        }

        .frame-header.white {
            color: white;
        }


        .preview-frame.black-bg .frame-header {
            color: white;
            background: transparent;
            border-bottom-color: rgba(255,255,255,0.2);
        }

        .frame-content-area {
            justify-content: center;
            
            grid-template-columns: 1fr 1fr;
            flex: 1;
            align-items: stretch;
            width:100%;
        }

        .content-block {
            flex: 1;
            height:48px;
            margin-bottom: 8px;
            background: #f8f9fa;
            border-radius: 4px;
        }

        .content-block.light {
            background: #f8f9fa;
        }

        .content-block.white {
            background: rgba(255,255,255,0.8);
        }


        .preview-frame.black-bg .content-block.white {
            background: rgba(255,255,255,0.8);
        }

        .frame-button {
            background: #bcc8ff;
            transition: background-color 0.2s ease-in-out; /* 버튼 색상 전환 애니메이션 */
            border-radius: 4px;
            width: calc(100% - 16px);
            height: 26px;
            position: absolute;
            bottom: 0px;
            left: 10px;
            right: 10px;
            transition: background-color 0.3s ease;
        }

        .frame-button.accent {
            background: #667eea;
        }

        .frame-button.dark {
            background: #333;
        }

        .card-footer {
            position: absolute;
            bottom: -30px;
            left: 0;
            right: 0;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            line-height: 1.2;
            min-height: 20px;
        }

        .card-label {
            font-size: 8px;
            font-weight: 400;
            color: #333;
            transition: color 0.3s ease;
            text-align: center;
            width: 100%;
        }

        .card-description {
            font-size: 9px;
            color: #777;
            line-height: 1.2;
        }

        /* 색상 분류 정보 스타일 */
        .color-classification-info {
            margin-top: 8px;
            background: #f8f9fa;
            border-radius: 6px;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: row;
            padding: 12px;
            font-size: 10px;
        }

        .classification-result {
            
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: all 0.3s ease;
        }

        .classification-result.light {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .classification-result.dark {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .classification-details {
            font-size: 10px;
            color: #666;
            text-align: center;
        }

        .classification-reasons {
            font-size: 9px;
            color: #888;
            font-style: italic;
            line-height: 1.2;
        }

        .color-classification-info.light {
            border-left-color: #ffc107;
            background: #fff9e6;
        }

        .color-classification-info.dark {
            border-left-color: #17a2b8;
            background: #e6f7ff;
        }

        .step-actions {
            display: flex;
            justify-content: space-between;
            gap: 8px;
        }

        .step-actions button {
            flex: 1;
            height: 32px;
            font-size: 11px;
        }

        .theme-preview {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 12px;
        }

        .theme-mode-preview {
            background: white;
            border-radius: 6px;
            padding: 8px;
            border: 1px solid #e0e0e0;
        }

        .theme-mode-title {
            font-size: 10px;
            font-weight: 600;
            margin-bottom: 6px;
            text-align: center;
        }

        .theme-semantic-list {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .semantic-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 8px;
        }

        .semantic-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            border: 1px solid rgba(0,0,0,0.1);
        }

        .semantic-name {
            flex: 1;
            font-family: 'Monaco', monospace;
            color: #666;
        }

        .theme-name-input {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            font-size: 11px;
            margin-bottom: 12px;
            background: white;
            max-width: 100%;
            height: 32px;
        }

        .theme-name-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
        }



        .step-indicator {
            display: inline-block;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: 600;
        }

        .step-light {
            background: #fff3cd;
            color: #856404;
        }

        .step-medium {
            background: #e2e3e5;
            color: #41464b;
        }

        .step-dark {
            background: #343a40;
            color: #f8f9fa;
        }

        .classification-badge {
            display: inline-block;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: 600;
            
        }

        .classification-light {
            background: #cfe2ff;
            color: #084298;
            border: 1px solid #b6d4fe;
        }

        .classification-medium {
            background: #fff3cd;
            color: #664d03;
            border: 1px solid #ffecb5;
        }

        .classification-dark {
            background: #f8d7da;
            color: #842029;
            border: 1px solid #f5c2c7;
        }

        .warning-box {
            background: #fff7dd;
            border: 1px solid #ffeaa7;
            border-radius: 4px;
            padding: 8px 20px;
            margin-bottom: 8px;
        }

        .warning-box p {
            font-size: 9px;
            color: #856404;
            margin: 0;
        }

        /* 아코디언 스타일 추가 */
        .accordion-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 12px;
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 12px;
        }

        .accordion-header:hover {
            background: #e9ecef;
            border-color: #667eea;
        }

        .accordion-header.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .accordion-icon {
            font-size: 14px;
            transition: transform 0.2s;
        }

        .accordion-header.active .accordion-icon {
            transform: rotate(180deg);
        }

        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .accordion-content.expanded {
            max-height: 2000px;
            transition: max-height 0.5s ease-in;
        }

        .accordion-body {
            padding: 12px;
            border: 1px solid #e0e0e0;
            border-top: none;
            border-radius: 0 0 6px 6px;
            background: white;
        }

        #tuningSlider {
            width: 100%;
            -webkit-appearance: none;
            height: 4px;
            border-radius: 2px;
            background: #e0e0e0;
            outline: none;
        }

        #tuningSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }

        #tuningSlider:disabled {
            opacity: 0.5;
        }

        #tuningStatus {
            padding: 2px 6px;
            border-radius: 3px;
            background: #f0f0f0;
        }

        #tuningStatus.auto {
            background: #e8f5e8;
            color: #28a745;
        }

        /* 색상 복사 애니메이션 */
        @keyframes copyFlash {
            0% { 
                background: #4CAF50; 
                color: white;
                transform: scale(1.1);
            }
            100% { 
                background: transparent; 
                transform: scale(1);
            }
        }

        .color-hex.copied {
            animation: copyFlash 0.5s ease;
        }

        /* Background Selection Styles */
        .background-selection {
            width: 100%;
        }

        .bg-accordion {
            display: flex;
            flex-direction: column;
        }

        .bg-accordion-toggle {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 8px;
            padding: 8px 1px;
            width: 100%;
            max-width: 100%;
            height: 32px;
            border: none;
            background: #FFFFFF;
            cursor: pointer;
            font-family: 'Inter', sans-serif;
            font-size: 11px;
            font-weight: 400;
            color: rgba(0,0,0,0.8);
        }

        .bg-accordion-title {
            display: flex;
            align-items: center;
            gap: 8px;
            pointer-events: none;
        }

        .bg-accordion-caret {
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s ease;
        }

        .bg-accordion-toggle:not(.expanded) .bg-accordion-caret svg {
            transform: rotate(0deg);
        }

        .bg-accordion-toggle.expanded .bg-accordion-caret svg {
            transform: rotate(180deg);
        }

        .bg-accordion-panel {
            display: none;
            padding-left: 24px;
        }

        .bg-accordion-panel.expanded {
            display: block;
        }

        .bg-swatch-row {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .bg-swatch-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            max-width: 100%;
            padding: 8px 0 8px;
        }


        .bg-swatch {
            position: relative;
            width: 36px;
            height: 36px;
            border: none;
            background: transparent;
            cursor: pointer;
            padding: 0;
        }

        .bg-swatch::after {
            content: '';
            position: absolute;
            inset: -2px;
            border: 2px solid transparent;
            border-radius: 999px;
            pointer-events: none;
            transition: border-color 0.15s ease;
        }

        .bg-swatch.selected::after {
            border-color: #18A0FB;
        }

        .bg-swatch-chip {
            position: absolute;
            inset: 0;
            width: 32px;
            height: 32px;
            margin: auto;
            border-radius: 999px;
            border: 1px #0000001a solid;
            overflow: hidden;
            box-shadow: inset 0 0 0 0.5px rgba(0, 0, 0, 0.2);
        }

        .bg-swatch-chip::before {
            content: '';
            position: absolute;
            inset: 0;
            background-image: linear-gradient(45deg, #f1f1f1 25%, transparent 25%),
                              linear-gradient(-45deg, #f1f1f1 25%, transparent 25%),
                              linear-gradient(45deg, transparent 75%, #f1f1f1 75%),
                              linear-gradient(-45deg, transparent 75%, #f1f1f1 75%);
            background-size: 6px 6px;
            background-position: 0 0, 0 3px, 3px -3px, -3px 0;
            opacity: 0.5;
        }

        .bg-swatch-chip::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 100px;
            background: var(--swatch-color, #ffffff);
        }

        .bg-swatch[data-mode="accent-on-bg-black"] .bg-swatch-chip::after {
            --swatch-color: #000000;
        }

        .bg-swatch[data-mode="accent-on-bg-fixed"] .bg-swatch-chip::after {
            --swatch-color: #ffffff;
        }

        .bg-extra-swatch {
            width: 36px;
            height: 36px;
            border-radius: 999px;
            border: 1px solid rgba(0,0,0,0.15);
            background: var(--extra-color, #ffffff);
            box-shadow: 0 1px 3px rgba(0,0,0,0.12);
        }

        /* UI Preview Card */
        .ui-preview-section {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .ui-preview-title-label {
            font-size: 11px;
            font-weight: 600;
            color: #1f2937;
        }

        .ui-preview-card {
            border-radius: 10px;
            padding: 16px;
            border: 1px solid rgba(15, 23, 42, 0.1);
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.15);
            display: flex;
            flex-direction: column;
            gap: 12px;
            transition: background-color 0.2s ease, color 0.2s ease;
        }

        .ui-preview-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            font-weight: 600;
        }

        .ui-preview-badge {
            font-size: 10px;
            padding: 4px 10px;
            border-radius: 999px;
            background: rgba(59,130,246,0.15);
            color: #1d4ed8;
            font-weight: 600;
        }

        .ui-preview-body {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .ui-preview-primary-text {
            font-size: 13px;
            font-weight: 700;
            letter-spacing: -0.01em;
        }

        .ui-preview-secondary-text {
            font-size: 11px;
            line-height: 1.45;
        }

        .ui-preview-actions {
            display: flex;
            gap: 8px;
        }

        .ui-preview-btn {
            flex: 0 0 auto;
            min-width: 92px;
            height: 30px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        .ui-preview-btn.primary {
            border: none;
            color: #ffffff;
        }

        .ui-preview-btn.secondary {
            background: transparent;
            border: 1px solid rgba(59,130,246,0.4);
            color: #1d4ed8;
        }

        .ui-preview-hint {
            font-size: 10px;
            color: #64748b;
        }

        /* optional checkboard background for transparency preview (when using a custom swatch element) */
        .swatch-checkboard {
            position: relative;
            width: 20px;
            height: 20px;
            border-radius: 3px;
            overflow: hidden;
        }
        .swatch-checkboard::before {
            content: '';
            position: absolute;
            inset: 0;
            background-size: 8px 8px;
            background-image:
                linear-gradient(45deg, #eee 25%, transparent 25%),
                linear-gradient(-45deg, #eee 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #eee 75%),
                linear-gradient(-45deg, transparent 75%, #eee 75%);
            background-position: 0 0, 0 4px, 4px -4px, -4px 0px;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- 탭 네비게이션 -->
        <div class="tab-navigation">
            <button class="tab-btn active" id="customThemeTab">
                Custom Theme
            </button>
            <button class="tab-btn" id="generatorTab">
                Scale Generator
            </button>
            <button class="tab-btn" id="toneMatchingTab">
                Tone Matching
            </button>
            <button type="button" class="tab-home-btn" id="tabHomeBtn" aria-label="Home">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12.0707 3.45682L20.6442 12.0303C20.663 12.0491 20.6735 12.0745 20.6735 12.1011V20.5138C20.6735 20.5691 20.6288 20.6138 20.5735 20.6138H14.8912V16.7589C14.8912 15.1622 13.5968 13.8678 12 13.8678C10.4032 13.8678 9.10883 15.1622 9.10883 16.7589V20.6138H3.42648C3.37125 20.6138 3.32648 20.5691 3.32648 20.5138V12.1011C3.32648 12.0745 3.33701 12.0491 3.35577 12.0303L11.9293 3.45682C11.9683 3.41777 12.0317 3.41777 12.0707 3.45682Z" stroke="#19191A" stroke-width="1.8"/>
                </svg>
            </button>
        </div>

        <!-- Custom Theme 탭 -->
        <div id="customThemeContent" class="tab-content active">
            <!-- 프로그레스 바 -->
            <div class="wizard-progress">
                <div class="simple-progress-bar">
                    <div class="progress-segment active" data-step="1"></div>
                    <div class="progress-segment" data-step="3"></div>
                </div>
            </div>

            <!-- Step 1: Key Color 선택 -->
            <div id="wizardStep1" class="wizard-step active">
                <div class="step-header">
                    <div class="step-title">Step 1. Key Color 선택</div>
                    <p>Theme을 구성할 주요 색상을 선택하세요.</p>
                </div>
                
                <div class="step-content">
                    <div class="input-group">
                        <label>Color Name</label>
                        <input type="text" id="wizardThemeNameInput" class="theme-name-input" 
                               placeholder="예: custom-theme" value="custom-theme">
                    </div>
                    
                    <div class="input-group">
                        <label>Key Color</label>
                        <div class="color-input-group">
                            <input type="color" id="wizardThemeBaseColor" class="color-picker" value="#ff4800">
                            <input type="text" id="wizardThemeBaseHex" class="hex-input" value="#FF4800">
                        </div>
                        
                        <!-- 컬러 분류 표시 -->
                        <div style="margin-top: 8px; display: flex; align-items: center; gap: 8px;">
                            <span id="wizardStepIndicator" class="step-indicator">Step: 500</span>
                            <span id="wizardClassificationBadge" class="classification-badge classification-medium">중간</span>
                        </div>
                        <div id="wizardStepClassificationInfo" class="color-classification-info" style="margin-top: 8px; display: none;">
                            <span id="wizardStepClassificationText">입력 색상이 Step 500에 해당합니다. 중간 범위(400-600)로 분류되어 Mode별로 다른 매핑이 적용됩니다.</span>
                        </div>

                        <!-- 최근 사용한 컬러 -->
                        <div id="recentColorsSection" class="recent-colors" style="display: none;">
                            <div class="recent-header">
                                <span class="recent-title">최근 사용한 컬러</span>
                                <button id="clearRecentBtn" class="recent-clear" type="button" title="목록 비우기">지우기</button>
                            </div>
                            <div id="recentColorsContainer" class="recent-swatches"></div>
                        </div>
                    </div>
                </div>
                
                <div class="step-actions">
                    <button class="action-btn btn-success" style="margin-top:8px;" onclick="goToStep(2)">변수 생성 후 계속</button>
                </div>
            </div>

            <!-- Step 2: Background 선택 -->
            <div id="wizardStep2" class="wizard-step">
                <div class="step-header">
                    <div class="step-title">Step 2. Background 선택</div>
                </div>

                <div class="step-content">
                    <div class="bg-accordion">
                        <button type="button" class="bg-accordion-toggle expanded" id="recommendedBgToggle" aria-expanded="true">
                            <span class="bg-accordion-caret">
                                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M8 10L11 6L5 6L8 10Z" fill="black"/>
                                </svg>
                            </span>
                            <span class="bg-accordion-title">추천 컬러</span>
                        </button>
                        <div class="bg-accordion-panel expanded" id="recommendedBgPanel">
                            <div class="bg-swatch-row">
                                <div class="bg-swatch-grid">
                                    <button type="button" class="bg-swatch selected" data-mode="accent-on-bg-fixed">
                                        <span class="bg-swatch-chip" style="--swatch-color: #FFFFFF;"></span>
                                    </button>
                                    <button type="button" class="bg-swatch" data-mode="accent-on-bg-black">
                                        <span class="bg-swatch-chip" style="--swatch-color: #000000;"></span>
                                    </button>
                                    <button type="button" class="bg-swatch" data-mode="accent-on-bg-off" id="recommendedBgCard">
                                        <span class="bg-swatch-chip" id="recommendedBgPreview" style="--swatch-color: #F5F5F5;"></span>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="bg-accordion">
                        <button type="button" class="bg-accordion-toggle" id="customBgToggle" aria-expanded="false">
                            <span class="bg-accordion-caret">
                                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M8 10L11 6L5 6L8 10Z" fill="black"/>
                                </svg>
                            </span>
                            <span class="bg-accordion-title">배경색 직접 입력하기</span>
                        </button>
                        <div class="bg-accordion-panel" id="customBgPanel">
                            <div class="custom-bg-color-input" id="customBgColorContainer">
                                <div class="color-input-container">
                                    <input type="color" id="customBgColor" class="color-picker" value="#ff4800">
                                    <input type="text" id="customBgHex" class="hex-input" value="#FF4800" style="text-transform: uppercase;">
                                    <button type="button" id="customBgCreateBtn" class="inline-input-btn">입력</button>
                                </div>
                                <div id="customBgHint" class="custom-bg-hint" style="display: none;"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="step-actions" style="display: block;">
                    <button class="action-btn btn-secondary" onclick="goToStep(1)">이전</button>
                    <div style="padding: 8px; background: #18a0fb0c; text-align: center; font-size: 10px; color: #18A0FB; border-radius: 4px; margin-top: 8px;">Frame을 선택하고 적용하기 버튼을 클릭하세요.</div>
                    <button class="action-btn btn-success" onclick="applyCustomThemeWithBackground()">적용하기</button>
                </div>

                <div class="ui-preview-section" style="display: none;">
                    <div class="ui-preview-title-label">미리보기</div>
                    <div id="themePreviewContainer" class="ui-preview-card">
                        <div class="ui-preview-card-header">
                            <span>UI Preview</span>
                            <span class="ui-preview-badge">New</span>
                        </div>
                        <div class="ui-preview-body">
                            <div class="ui-preview-primary-text">Primary text content</div>
                            <div class="ui-preview-secondary-text">Step 2에서 테마를 생성하면 이곳에서 미리보기 색상을 확인할 수 있어요.</div>
                        </div>
                        <div class="ui-preview-actions">
                            <button class="ui-preview-btn primary" type="button">Action</button>
                            <button class="ui-preview-btn secondary" type="button">Cancel</button>
                        </div>
                    </div>
                    <div class="ui-preview-hint" id="uiPreviewHint">현재 선택된 모드에 맞춰 기본 프리뷰를 표시하고 있어요.</div>
                </div>
            </div>

            <!-- Step 3: Mode 선택 및 적용 -->
            <div id="wizardStep3" class="wizard-step">
                <div class="step-header">
                    <div class="step-title">Step 2. Mode 선택</div>
                    <p>선택한 Frame에 Theme을 적용합니다.</p>
                </div>
                
                <div class="step-content">
                    <div class="mode-selection">
                        <div class="mode-cards">
                            <!-- Mode 1: foreground 중심 -->
                            <div class="mode-card selected" data-mode="accent-on-bg-off">
                                <div class="card-checkbox">
                                    <svg class="checkbox-icon selected-icon" width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <path d="M4.0332 10.0227L8.69951 15.0004L15.9589 5.03613" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                    </svg>
                                    <svg class="checkbox-icon unselected-icon" width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" style="display: none;">
                                        <circle cx="10" cy="10" r="8" stroke="#ddd" stroke-width="2" fill="none"/>
                                    </svg>
                                </div>
                                <div class="card-preview">
                                    <div class="preview-frame">
                                        <div class="frame-header">
                                            <svg width="48" height="14" viewBox="0 0 60 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                                                <path fill-rule="evenodd" clip-rule="evenodd" d="M18.3088 0.55957C15.5807 0.55957 13.3688 2.70342 13.3688 5.34814C13.3688 7.92637 15.5253 10.0165 18.1852 10.0165C18.2997 10.0165 18.4097 10.0021 18.5197 9.98764C18.5724 9.98073 18.6251 9.97381 18.6783 9.96847L14.9751 15.1993H17.4012L22.4563 7.88935C22.973 7.14237 23.2492 6.25583 23.2492 5.34814C23.2492 2.70342 21.0375 0.55957 18.3088 0.55957ZM18.3088 8.30514C16.6757 8.30514 15.3518 6.98118 15.3518 5.34814C15.3518 3.71478 16.6757 2.39081 18.3088 2.39081C19.9418 2.39081 21.2658 3.71478 21.2658 5.34814C21.2658 6.98118 19.9418 8.30514 18.3088 8.30514Z" />
                                                <path d="M39.3951 4.05236C38.3724 3.02899 36.9648 2.39064 35.4071 2.39064C32.2922 2.39064 29.7579 4.92496 29.7579 8.03979C29.7579 11.1546 32.2922 13.6888 35.4071 13.6888C36.9648 13.6888 38.3724 13.0506 39.3951 12.0271L40.7388 13.3707C39.362 14.6942 37.4839 15.5183 35.4071 15.5183C31.1984 15.5183 27.7743 12.1633 27.7743 8.03979C27.7743 3.91633 31.1984 0.561317 35.4071 0.561317C37.4839 0.561317 39.362 1.38521 40.7388 2.70885L39.3951 4.05236Z" />
                                                <path d="M52.6666 7.91318L57.6453 0.879978H59.8262V15.1995H57.8408V3.90107L52.6666 11.3855L47.492 3.90107V15.1995H45.5068V0.879978H47.6878L52.6666 7.91318Z" />
                                                <path d="M4.5399 0.559586C7.0473 0.559586 9.07995 2.52526 9.07995 4.94999C9.07995 6.0115 8.67185 7.03231 7.94025 7.80124L2.64392 13.3682H9.07995V15.1993H0V13.3682L6.43603 6.60338C6.86032 6.15747 7.09681 5.56558 7.09681 4.94999C7.09681 3.53662 5.95214 2.39083 4.5399 2.39083C3.12781 2.39083 1.98298 3.53662 1.98298 4.94999H0C0 2.52526 2.03249 0.559586 4.5399 0.559586Z" />
                                            </svg>
                                        </div>
                                        <div class="frame-content-area">
                                            <div class="content-block light"></div>
                                            <div class="content-block light"></div>
                                        </div>
  
                                        <div class="frame-button accent"></div>
                                    </div>
                                </div>
                                <div class="card-footer">
                                    <div class="card-label">foreground 중심</div>
                                </div>
                            </div>
       
                            <!-- Mode 2: foreground 중심 white bg -->
                            <div class="mode-card" data-mode="accent-on-bg-fixed">
                                <div class="card-checkbox">
                                    <svg class="checkbox-icon selected-icon" width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" style="display: none;">
                                        <path d="M4.0332 10.0227L8.69951 15.0004L15.9589 5.03613" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                    </svg>
                                    <svg class="checkbox-icon unselected-icon" width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <circle cx="10" cy="10" r="8" stroke="#ddd" stroke-width="2" fill="none"/>
                                    </svg>
                                </div>
                                <div class="card-preview">
                                    <div class="preview-frame white-bg">
                                        <div class="frame-header">
                                            <svg width="48" height="14" viewBox="0 0 60 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                                                <path fill-rule="evenodd" clip-rule="evenodd" d="M18.3088 0.55957C15.5807 0.55957 13.3688 2.70342 13.3688 5.34814C13.3688 7.92637 15.5253 10.0165 18.1852 10.0165C18.2997 10.0165 18.4097 10.0021 18.5197 9.98764C18.5724 9.98073 18.6251 9.97381 18.6783 9.96847L14.9751 15.1993H17.4012L22.4563 7.88935C22.973 7.14237 23.2492 6.25583 23.2492 5.34814C23.2492 2.70342 21.0375 0.55957 18.3088 0.55957ZM18.3088 8.30514C16.6757 8.30514 15.3518 6.98118 15.3518 5.34814C15.3518 3.71478 16.6757 2.39081 18.3088 2.39081C19.9418 2.39081 21.2658 3.71478 21.2658 5.34814C21.2658 6.98118 19.9418 8.30514 18.3088 8.30514Z" />
                                                <path d="M39.3951 4.05236C38.3724 3.02899 36.9648 2.39064 35.4071 2.39064C32.2922 2.39064 29.7579 4.92496 29.7579 8.03979C29.7579 11.1546 32.2922 13.6888 35.4071 13.6888C36.9648 13.6888 38.3724 13.0506 39.3951 12.0271L40.7388 13.3707C39.362 14.6942 37.4839 15.5183 35.4071 15.5183C31.1984 15.5183 27.7743 12.1633 27.7743 8.03979C27.7743 3.91633 31.1984 0.561317 35.4071 0.561317C37.4839 0.561317 39.362 1.38521 40.7388 2.70885L39.3951 4.05236Z" />
                                                <path d="M52.6666 7.91318L57.6453 0.879978H59.8262V15.1995H57.8408V3.90107L52.6666 11.3855L47.492 3.90107V15.1995H45.5068V0.879978H47.6878L52.6666 7.91318Z" />
                                                <path d="M4.5399 0.559586C7.0473 0.559586 9.07995 2.52526 9.07995 4.94999C9.07995 6.0115 8.67185 7.03231 7.94025 7.80124L2.64392 13.3682H9.07995V15.1993H0V13.3682L6.43603 6.60338C6.86032 6.15747 7.09681 5.56558 7.09681 4.94999C7.09681 3.53662 5.95214 2.39083 4.5399 2.39083C3.12781 2.39083 1.98298 3.53662 1.98298 4.94999H0C0 2.52526 2.03249 0.559586 4.5399 0.559586Z" />
                                            </svg>
                                        </div>
                                        <div class="frame-content-area">
                                            <div class="content-block light"></div>
                                            <div class="content-block light"></div>
                                        </div>
                                        <div class="frame-button accent"></div>
                                    </div>
                                </div>
                                <div class="card-footer">
                                    <div class="card-label">foreground 중심 <br> white bg</div>
                                </div>
                            </div>
                            
                            <!-- Mode 3: foreground 중심 black bg -->
                            <div class="mode-card" data-mode="accent-on-bg-black">
                                <div class="card-checkbox">
                                    <svg class="checkbox-icon selected-icon" width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" style="display: none;">
                                        <path d="M4.0332 10.0227L8.69951 15.0004L15.9589 5.03613" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                    </svg>
                                    <svg class="checkbox-icon unselected-icon" width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <circle cx="10" cy="10" r="8" stroke="#ddd" stroke-width="2" fill="none"/>
                                    </svg>
                                </div>
                                <div class="card-preview">
                                    <div class="preview-frame black-bg">
                                        <div class="frame-header">
                                            <svg width="48" height="14" viewBox="0 0 60 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                                                <path fill-rule="evenodd" clip-rule="evenodd" d="M18.3088 0.55957C15.5807 0.55957 13.3688 2.70342 13.3688 5.34814C13.3688 7.92637 15.5253 10.0165 18.1852 10.0165C18.2997 10.0165 18.4097 10.0021 18.5197 9.98764C18.5724 9.98073 18.6251 9.97381 18.6783 9.96847L14.9751 15.1993H17.4012L22.4563 7.88935C22.973 7.14237 23.2492 6.25583 23.2492 5.34814C23.2492 2.70342 21.0375 0.55957 18.3088 0.55957ZM18.3088 8.30514C16.6757 8.30514 15.3518 6.98118 15.3518 5.34814C15.3518 3.71478 16.6757 2.39081 18.3088 2.39081C19.9418 2.39081 21.2658 3.71478 21.2658 5.34814C21.2658 6.98118 19.9418 8.30514 18.3088 8.30514Z" />
                                                <path d="M39.3951 4.05236C38.3724 3.02899 36.9648 2.39064 35.4071 2.39064C32.2922 2.39064 29.7579 4.92496 29.7579 8.03979C29.7579 11.1546 32.2922 13.6888 35.4071 13.6888C36.9648 13.6888 38.3724 13.0506 39.3951 12.0271L40.7388 13.3707C39.362 14.6942 37.4839 15.5183 35.4071 15.5183C31.1984 15.5183 27.7743 12.1633 27.7743 8.03979C27.7743 3.91633 31.1984 0.561317 35.4071 0.561317C37.4839 0.561317 39.362 1.38521 40.7388 2.70885L39.3951 4.05236Z" />
                                                <path d="M52.6666 7.91318L57.6453 0.879978H59.8262V15.1995H57.8408V3.90107L52.6666 11.3855L47.492 3.90107V15.1995H45.5068V0.879978H47.6878L52.6666 7.91318Z" />
                                                <path d="M4.5399 0.559586C7.0473 0.559586 9.07995 2.52526 9.07995 4.94999C9.07995 6.0115 8.67185 7.03231 7.94025 7.80124L2.64392 13.3682H9.07995V15.1993H0V13.3682L6.43603 6.60338C6.86032 6.15747 7.09681 5.56558 7.09681 4.94999C7.09681 3.53662 5.95214 2.39083 4.5399 2.39083C3.12781 2.39083 1.98298 3.53662 1.98298 4.94999H0C0 2.52526 2.03249 0.559586 4.5399 0.559586Z" />
                                            </svg>
                                        </div>
                                        <div class="frame-content-area">
                                            <div class="content-block white"></div>
                                            <div class="content-block white"></div>
                                        </div>
                                        <div class="frame-button accent"></div>
                                    </div>
                                </div>
                                <div class="card-footer">
                                    <div class="card-label">foreground 중심<br> black bg</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="step-actions">
                    <button class="action-btn btn-secondary" onclick="goToStep(1)">이전</button>
                    <button class="action-btn btn-success" onclick="applyCustomTheme()">custom theme 적용하기</button>
                </div>
                
                <!-- Mapping 정보보기 컨트롤 -->
                <div class="mapping-info-controls" style="margin: 8px; padding: 12px; border: 1px solid #00000010; border-radius: 8px; background: #f8f9fa;">
                    <div style="display: flex; gap: 6px; align-items: center; flex-direction: column; ">
                        <button 
                            id="showMappingBtn" 
                            onclick="showMappingInfo()" 
                            style="padding: 8px 16px; background: #000; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 10px;">
                            선택된 Frame의 Mapping 정보보기
                        </button>
                        <span id="mappingStatus" style="font-size: 10px; color: #666; margin-left: 8px;">Frame을 선택하고 버튼을 눌러주세요</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Scale Generator 탭 부분 수정 -->
        <div id="generatorContent" class="tab-content">
            <div class="section">
                <div class="step-header">
                <div class="section-title">Base Color Input</div>
                <p>팔레트를 생성할 색상을 입력하세요.</p>
                </div>
                <div class="color-input-group">
                    <input type="color" id="baseColor" class="color-picker" value="#ff4800">
                    <input type="text" id="hexInput" class="hex-input" value="#FF4800">
                </div>
                
                <!-- 컬러 분류 표시 -->
                <div style="margin-top: 12px; display: flex; align-items: center; gap: 8px;">
                    <span id="stepIndicator" class="step-indicator">Step: 500</span>
                    <span id="classificationBadge" class="classification-badge classification-medium">중간</span>
                </div>
                <div id="stepClassificationInfo" class="color-classification-info" style="margin-top: 8px; display: none;">
                    <span id="stepClassificationText">입력 색상이 Step 500에 해당합니다. 중간 범위(400-600)로 분류되어 Mode별로 다른 매핑이 적용됩니다.</span>
                </div>
            </div>

            <!-- Base Color Input 섹션 다음에 추가 -->
            <div class="section" style="display: none;">
                <div class="section-title">Fine Tuning</div>
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <div style="display: flex; gap: 8px;">
                        <label style="font-size: 11px;">Auto Mode</label>
                        <input type="checkbox" id="autoTuning">
                    </div>
                    <span id="tuningStatus" style="font-size: 10px; color: #666;">Manual: 0</span>
                </div>
                <div style="display: flex; gap: 8px; align-items: center;">
                    <input type="range" id="tuningSlider" min="-10" max="10" value="0" style="flex: 1;">
                    <span id="tuningValue" style="min-width: 30px; text-align: center;">0</span>
                </div>
            </div>

            <div class="section">
                <div class="section-title">Background Mode</div>
                <div class="mode-buttons">
                    <button class="mode-btn active" onclick="setMode('light')">Light Mode</button>
                    <button class="mode-btn" onclick="setMode('dark')">Dark Mode</button>
                </div>
            </div>

            <div class="section">
                <div class="section-title">Variable Name</div>
                <input type="text" id="variableName" class="hex-input" placeholder="예: primary, brand, blue" style="width: 100%;">
                <p style="font-size: 9px; color: #666; margin-top: 4px;">
                    변수 이름 형식: {name}-50, {name}-100, {name}-200...
                </p>
            </div>

            <div class="section">
                <div class="section-title">Generated Color Palette</div>
                <div class="color-grid" id="colorResults">
                    <!-- 색상들이 여기에 표시됩니다 -->
                </div>
            </div>

            <!-- 액션 버튼들 추가 -->
            <div class="action-buttons" style="display: flex; flex-direction: column; gap: 2px; margin-top: 4px; padding: 12px;">
                <button class="action-btn btn-primary" onclick="createVariables()">
                    Create Variables (현재 모드)
                </button>
                <button class="action-btn btn-success" onclick="createDualModeVariables()">
                    Create Light + Dark Variables
                </button>
                <button class="action-btn btn-secondary" onclick="createStyles()">
                    Create Color Styles
                </button>
            </div>
        </div>

        <!-- Tone Matching 탭 -->
        <div id="toneMatchingContent" class="tab-content">
            <div class="header">
                
            </div>

            <!-- 기준 색상 설정 -->
            <div class="section">
                <div class="step-header">
                <div class="section-title">Step 1. 기준 색상 정하기</div>
                <p>기준이 될 색상을 입력하세요.</p>
                </div>
                <div class="color-input-group">
                    <input type="color" id="referenceColorPicker" class="color-picker" value="#ff4800">
                    <input type="text" id="referenceColorHex" class="hex-input" value="#FF4800">
                </div>
                
                <div class="button-group">
                    <button id="setRefBtn" class="action-btn btn-primary">Set Reference</button>
                    <button id="clearRefBtn" class="action-btn btn-secondary">Clear</button>
                </div>

                <div id="referenceStatus" style="color: #666; font-size: 10px; margin: 8px 0px 8px 0px;">현재 설정된 기준 컬러가 없습니다.</div>
                
                <div id="toneRecentColorsSection" class="recent-colors" style="display: none; margin-top: 12px;">
                    <div class="recent-header">
                        <span class="recent-title">최근 사용한 컬러</span>
                        <button id="clearToneRecentBtn" class="recent-clear" type="button" title="목록 비우기">지우기</button>
                    </div>
                    <div id="toneRecentColorsContainer" class="recent-swatches"></div>
                </div>
                <div id="referenceDisplay"></div>
            </div>
            
            <!-- 새 색상 입력 -->
            <div class="section">
                <div class="step-header">
                <div class="section-title">Step 2. 새로운 컬러 입력하기</div>
                <p>색상을 입력하면 톤 매칭이 시작돼요.</p>
                </div>
                <div class="tone-input-area">
                    <div class="color-input-group">
                        <input type="color" id="newColorPicker" class="color-picker" value="#ff4800">
                        <input type="text" id="newColorHex" class="hex-input" value="#FF4800">
                    </div>
                    <button id="getSuggestionsBtn" class="action-btn btn-success">추천받기</button>
                    <p style="font-size: 10px; color: #666; margin-top: 4px;">이 색상은 기준 톤에 맞게 조정됩니다.</p>
                </div>
                
                <div id="toneMatchingResults"></div>
            </div>
        </div>

        <!-- 성공 메시지 -->
        <div class="success-message" id="successMessage"></div>
    </div>

    <script>
        
        // 전역 변수
        let currentMode = 'light';
        let generatedColors = [];
        let referenceColor = null;
        let currentTheme = null;
        let customBackgroundTheme = null;
        let recommendedSelection = { type: 'mode', value: 'accent-on-bg-fixed', step: null };
        let eyedropperState = { active: false, targetId: null };
        let eyedropperSupported = false;
        const EYEDROPPER_PROMPT_MESSAGE = '스포이드 모드: 캔버스에서 색상을 선택하세요!';
        const EYEDROPPER_CANCEL_MESSAGE = '스포이드가 취소되었습니다.';

        function normalizeThemeName(name) {
            if (!name) return '';
            const trimmed = name.trim();
            if (!trimmed) return '';
            return trimmed.replace(/\s+/g, '-');
        }

        // 색상 유틸리티
        class ColorUtils {
            static hexToRgb(hex) {
                var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : { r: 0, g: 0, b: 0 };
            }

            static rgbToHex(r, g, b) {
                return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
            }

            static hexToHsl(hex) {
                var rgb = this.hexToRgb(hex);
                return this.rgbToHsl(rgb.r / 255, rgb.g / 255, rgb.b / 255);
            }

            static rgbToHsl(r, g, b) {
                var max = Math.max(r, g, b);
                var min = Math.min(r, g, b);
                let h, s, l = (max + min) / 2;

                if (max === min) {
                    h = s = 0;
                } else {
                    var d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    switch (max) {
                        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                        case g: h = (b - r) / d + 2; break;
                        case b: h = (r - g) / d + 4; break;
                    }
                    h /= 6;
                }

                return [h * 360, s * 100, l * 100];
            }

            static hslToRgb(h, s, l) {
                h /= 360; s /= 100; l /= 100;
                var a = s * Math.min(l, 1 - l);
                var f = n => {
                    var k = (n + h * 12) % 12;
                    return l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
                };
                return [
                    Math.round(f(0) * 255),
                    Math.round(f(8) * 255),
                    Math.round(f(4) * 255)
                ];
            }

            static hslToHex(h, s, l) {
                var [r, g, b] = this.hslToRgb(h, s, l);
                return this.rgbToHex(r, g, b);
            }

            // === Contrast <-> Luminance 도우미 (white/dark 배경) ===
            static luminanceFromContrastVsWhite(contrast) {
                // contrast = (1.0 + 0.05) / (Y + 0.05)  →  Y = (1.05 / C) - 0.05
                return (1.05 / contrast) - 0.05;
            }

            static luminanceFromContrastVsBlack(contrast) {
                // contrast = (Y + 0.05) / 0.05  →  Y = 0.05 * contrast - 0.05
                return 0.05 * contrast - 0.05;
            }

            static luminanceFromContrastVsDarkBg(contrast) {
                // #0c0c0c의 luminance 계산
                const darkBgLuminance = this.getLuminance(12, 12, 12);
                // contrast = (Y + 0.05) / (darkBgLuminance + 0.05)  →  Y = contrast * (darkBgLuminance + 0.05) - 0.05
                return contrast * (darkBgLuminance + 0.05) - 0.05;
            }

            // HSL(h,s,L)에서 L을 이진탐색해서 목표 Y에 최대근접
            static solveLForY(h, s, targetY) {
                let lo = 0, hi = 100, bestL = 50, bestErr = 1e9;
                for (let i = 0; i < 24; i++) {
                    const mid = (lo + hi) / 2;
                    const [r, g, b] = this.hslToRgb(h, s, mid);
                    const Y = this.getLuminance(r, g, b);
                    const err = Math.abs(Y - targetY);
                    if (err < bestErr) { bestErr = err; bestL = mid; }
                    // white 기준: Y가 높으면 더 어둡게(hi 내림)
                    if (Y > targetY) hi = mid; else lo = mid;
                }
                return { L: bestL, err: bestErr };
            }

            // (가능하면 채도 보존) 목표 대비를 만족하는 HSL 찾기
            static solveHSLForContrast(h, sInput, contrastTarget, background = 'light') {
                const bgRgb = background === 'light' 
                    ? { r: 255, g: 255, b: 255 }
                    : { r: 12, g: 12, b: 12 };

                // 채도는 입력값 우선, 불가시 극소폭 보정
                const SAT_CAND = [1.0, 0.95, 0.9, 0.85].map(f => Math.max(5, Math.min(100, sInput * f)));
                let best = null;

                for (const s of SAT_CAND) {
                    // L값을 이진탐색으로 목표 대비에 맞춤
                    let lo = 0, hi = 100, bestL = 50, bestErr = 1e9;
                    
                    for (let i = 0; i < 24; i++) {
                        const mid = (lo + hi) / 2;
                        const [r, g, b] = this.hslToRgb(h, s, mid);
                        const actualContrast = this.getContrast({ r, g, b }, bgRgb);
                        const err = Math.abs(actualContrast - contrastTarget);
                        
                        if (err < bestErr) { 
                            bestErr = err; 
                            bestL = mid; 
                        }
                        
                        if (actualContrast > contrastTarget) {
                            if (background === 'light') {
                                lo = mid; // Light: 대비가 높으면 L을 높여서 대비를 줄임 (밝게)
                            } else {
                                hi = mid; // Dark: 대비가 높으면 L을 낮춰서 대비를 줄임 (어둡게)
                            }
                        } else {
                            if (background === 'light') {
                                hi = mid; // Light: 대비가 낮으면 L을 낮춰서 대비를 높임 (어둡게)
                            } else {
                                lo = mid; // Dark: 대비가 낮으면 L을 높여서 대비를 높임 (밝게)
                            }
                        }
                    }
                    
                    if (!best || bestErr < best.err) {
                        best = { h, s, l: bestL, err: bestErr };
                    }
                    if (bestErr < 0.01) break; // 충분히 근접하면 조기 종료
                }
                return best; // {h,s,l,err}
            }

            static getLuminance(r, g, b) {
                var [rs, gs, bs] = [r, g, b].map(c => {
                    c = c / 255;
                    return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
                });
                return 0.2126 * rs + 0.7152 * gs + 0.0722 * bs;
            }

            static getContrast(rgb1, rgb2) {
                var l1 = this.getLuminance(rgb1.r, rgb1.g, rgb1.b);
                var l2 = this.getLuminance(rgb2.r, rgb2.g, rgb2.b);
                var lighter = Math.max(l1, l2);
                var darker = Math.min(l1, l2);
                return (lighter + 0.05) / (darker + 0.05);
            }

            // 가장 가까운 스텝 찾기
            static findClosestStep(hex, mode) {
                mode = mode || 'light';  // 기본값 설정
                var [h, s, l] = this.hexToHsl(hex);
                var steps = [50, 75, 100, 150, 200, 300, 400, 500, 600, 700, 800, 900, 950];
                let closestStep = 500;
                let minDiff = Infinity;
                
                steps.forEach(function(step) {
                    let targetLightness;
                    if (mode === 'light') {
                        // ColorGenerator와 동일한 로직 사용
                        switch(step) {
                            case 50:  targetLightness = 95; break;
                            case 75:  targetLightness = 90; break;
                            case 100: targetLightness = 85; break;
                            case 150: targetLightness = 78; break;
                            case 200: targetLightness = 70; break;
                            case 300: targetLightness = 60; break;
                            case 400: targetLightness = 50; break;
                            case 500: targetLightness = 40; break;
                            case 600: targetLightness = 32; break;
                            case 700: targetLightness = 25; break;
                            case 800: targetLightness = 18; break;
                            case 900: targetLightness = 12; break;
                            case 950: targetLightness = 8; break;
                            default: targetLightness = 50;
                        }
                    } else {
                        // Dark mode 명도 매핑
                        switch(step) {
                            case 50:  targetLightness = 5; break;
                            case 75:  targetLightness = 10; break;
                            case 100: targetLightness = 15; break;
                            case 150: targetLightness = 22; break;
                            case 200: targetLightness = 30; break;
                            case 300: targetLightness = 40; break;
                            case 400: targetLightness = 50; break;
                            case 500: targetLightness = 60; break;
                            case 600: targetLightness = 68; break;
                            case 700: targetLightness = 75; break;
                            case 800: targetLightness = 82; break;
                            case 900: targetLightness = 88; break;
                            case 950: targetLightness = 92; break;
                            default: targetLightness = 50;
                        }
                    }
                    
                    var diff = Math.abs(l - targetLightness);
                    if (diff < minDiff) {
                        minDiff = diff;
                        closestStep = step;
                    }
                });
                
                return closestStep;
            }
        }

        // Hue의 본질적 밝기 판단 함수
        function getHueBrightness(hue) {
            // Hue 범위별 본질적 밝기 분류
            
            // 매우 밝은 색상군
            if (hue >= 50 && hue <= 70) return 'very-bright';     // 노랑 (Yellow)
            if (hue >= 170 && hue <= 190) return 'very-bright';   // 청록 (Cyan)
            
            // 밝은 색상군  
            if (hue >= 70 && hue <= 150) return 'bright';         // 연두-초록 (Yellow-Green to Green)
            if (hue >= 150 && hue <= 170) return 'bright';        // 청록-초록 경계 (Green-Cyan)
            if (hue >= 30 && hue <= 50) return 'bright';          // 주황 (Orange)
            
            // 중간 색상군
            if (hue >= 190 && hue <= 210) return 'medium';        // 청록-파랑 경계 (Cyan-Blue)
            if (hue >= 20 && hue <= 30) return 'medium';          // 주황-빨강 경계
            
            // 어두운 색상군
            if (hue >= 210 && hue <= 240) return 'dark';          // 파랑 (Blue)
            if (hue >= 240 && hue <= 300) return 'dark';          // 보라 (Purple/Violet)
            if (hue >= 0 && hue <= 20 || hue >= 300) return 'dark'; // 빨강-자주 (Red-Magenta)
            
            return 'medium'; // 기본값
        }

        // 새로운 컬러 범위 분류 로직
        function getColorRangeFromStep(closestStep, hex) {
            // 본질적 밝기 판단
            var isInherentlyBright = false;
            if (hex) {
                var hsl = ColorUtils.hexToHsl(hex);
                var hue = hsl[0];
                var saturation = hsl[1];
                var lightness = hsl[2];
                var hueBrightness = getHueBrightness(hue);
                
                if (saturation < 20) {
                    // 회색조는 lightness로만 판단
                    isInherentlyBright = (lightness >= 50);
                } else {
                    // 1) Lightness가 75% 이상이면 무조건 밝은 색상으로 분류
                    if (lightness >= 75) {
                        isInherentlyBright = true;
                    } 
                    // 2) 그렇지 않으면 Hue의 본질적 밝기로 판단
                    else {
                        // very-bright, bright까지를 본질적으로 밝은 색상으로 분류
                        isInherentlyBright = (hueBrightness === 'very-bright' || hueBrightness === 'bright');
                    }
                }
            }
            
            // 색상 범위 결정 (본질적 밝기에 따라 기준 조정)
            if (isInherentlyBright) {
                // 태생이 밝은 색상
                if (closestStep <= 400) {
                    return 'light';
                } else if (closestStep >= 500 && closestStep <= 700) {
                    return 'medium';
                } else {
                    return 'dark';  // 800-950
                }
            } else {
                // 태생이 어두운 색상
                if (closestStep < 300) {
                    return 'light';
                } else if (closestStep >= 300 && closestStep <= 700) {
                    return 'medium';
                } else {
                    return 'dark';  // 800-950
                }
            }
        }

        // 색상 생성기
        class ColorGenerator {
    constructor() {
        this.steps = [50, 75, 100, 150, 200, 300, 400, 500, 600, 700, 800, 900, 950];
        
        // Light Mode 회색 톤 (기존 규칙대로)
        this.lightModeGrayTones = [
            '#FFFFFF', // 50
            '#F7F7F7', // 75
            '#F0F0F0', // 100
            '#E8E8E8', // 150
            '#DDDDDD', // 200
            '#CCCCCC', // 300
            '#B4B4B4', // 400
            '#9E9E9E', // 500
            '#8A8A8A', // 600
            '#6A6A6A', // 700
            '#464646', // 800
            '#1F1F1F', // 900
            '#000000'  // 950
        ];
        
        // Dark Mode 회색 톤
        this.darkModeGrayTones = [
            '#0C0C0C', // 50
            '#141414', // 75
            '#1C1C1C', // 100
            '#242424', // 150
            '#313131', // 200
            '#414141', // 300
            '#525252', // 400
            '#626262', // 500
            '#808080', // 600
            '#ADADAD', // 700
            '#E3E3E3', // 800
            '#F4F4F4', // 900
            '#FCFCFC'  // 950
        ];

        // Dark Mode 대비값 (#0c0c0c 배경 기준)
        this.darkModeContrastRatios = [
            1.00, // 50
            1.06, // 75
            1.15, // 100
            1.26, // 150
            1.50, // 200
            1.92, // 300
            2.50, // 400
            3.21, // 500
            4.95, // 600
            8.72, // 700
            15.24, // 800
            17.79, // 900
            20.0   // 950
        ];
    }

    getAutoTuningValue(hex) {
        var [h, s, l] = ColorUtils.hexToHsl(hex);
        let tuning = 0;
        
        // 색상별 조정
        if (h >= 45 && h <= 75) tuning = -3;      // 노란색: 더 어둡게
        else if (h >= 15 && h <= 45) tuning = -2; // 주황색
        else if (h >= 210 && h <= 270) tuning = 2; // 파란색: 더 밝게
        else if (h >= 180 && h <= 210) tuning = 1; // 청록색
        
        // 채도에 따른 추가 조정
        if (s > 80) tuning -= 1;
        else if (s < 30) tuning += 1;
        
        return Math.max(-10, Math.min(10, tuning));
    }

    generateColors(inputHex, mode, tuningValue = 0) {
        const [hInput, sInput, lInput] = ColorUtils.hexToHsl(inputHex);
        const backgroundRgb = (mode === 'light') ? { r: 255, g: 255, b: 255 } : { r: 12, g: 12, b: 12 };

        // 무채색은 기존 회색 톤 그대로 (UI 의도 유지)
        if (sInput < 5) {
            const toneSet = (mode === 'light') ? this.lightModeGrayTones : this.darkModeGrayTones;
            return this.steps.map((step, i) => {
                const hex = toneSet[i];
                const rgb = ColorUtils.hexToRgb(hex);
                const contrast = ColorUtils.getContrast(rgb, backgroundRgb);
                return { step, hex, contrast, isClosest: false };
            });
        }

        // 1) grayscale 분포를 기반으로 현재 모드의 "목표 대비" 산출
        const targets = this.buildTargetContrasts(mode, hInput);

        // 2) 각 스텝에서 목표 대비를 만족하도록 HSL 계산 (hue 고정, 채도 보존)
        const colors = this.steps.map((step, i) => {
            const targetContrast = targets[i];
            const solved = ColorUtils.solveHSLForContrast(hInput, sInput, targetContrast, mode);

            // 튜닝: 최종 L에 소폭 가감
            let L = Math.max(0, Math.min(100, solved.l + (tuningValue || 0)));
            const [r, g, b] = ColorUtils.hslToRgb(solved.h, solved.s, L);
            const hex = ColorUtils.rgbToHex(r, g, b);
            const contrast = ColorUtils.getContrast({ r, g, b }, backgroundRgb);

            return { step, hex, contrast, isClosest: false };
        });

        // 3) 새로운 Hue 기반 로직으로 가장 가까운 step 찾기
        const inputColorHex = ColorUtils.hslToHex(hInput, sInput * 100, lInput);
        
        // 모든 step에 대해 새로운 분류 로직을 적용하여 가장 적절한 step 찾기
        let bestStepIndex = 0;
        let minDiff = Infinity;
        
        colors.forEach((color, index) => {
            // 각 step이 입력 색상과 얼마나 유사한 범위에 속하는지 계산
            const colorRange = getColorRangeFromStep(color.step, inputColorHex);
            const actualLightness = lInput;
            const stepLightness = ColorUtils.hexToHsl(color.hex)[2];
            
            // lightness 차이와 범위 일치도를 종합적으로 고려
            let diff = Math.abs(actualLightness - stepLightness);
            
            // 같은 범위(light/medium/dark)에 속한 경우 가중치 부여 
            if (colorRange === getColorRangeFromStep(color.step, inputColorHex)) {
                diff *= 0.5; // 같은 범위면 우선순위 높임
            }
            
            if (diff < minDiff) {
                minDiff = diff;
                bestStepIndex = index;
            }
        });
        
        colors[bestStepIndex].isClosest = true;

        return colors;
    }

    // 목표 대비 빌더 - 각 스텝의 목표 대비비율 계산
    buildTargetContrasts(mode, inputHue) {
        const steps = this.steps;
        const bg = (mode === 'light') ? { r: 255, g: 255, b: 255 } : { r: 12, g: 12, b: 12 };

        // 1) Grayscale 대비율 분포 계산
        const grayContrast = (mode === 'light') ? 
            steps.map((_, i) => {
                const hex = this.lightModeGrayTones[i];
                const rgb = ColorUtils.hexToRgb(hex);
                return ColorUtils.getContrast(rgb, { r: 255, g: 255, b: 255 });
            }) :
            this.darkModeContrastRatios;

        // 2) 입력 hue의 anchor 대비 계산 (Step50/Step950)
        let hueMinContrast, hueMaxContrast;
        
        if (mode === 'light') {
            // Light: Step50=1.03 고정, Step950=20.0 고정
            hueMinContrast = 1.03; // Step50 anchor
            hueMaxContrast = 20.0; // Step950 anchor
        } else {
            // Dark: Step50=가장어둠(L=0), Step950=최대 19.0으로 제한 (완전 흰색 방지)
            const darkestRgb = ColorUtils.hexToRgb(ColorUtils.hslToHex(inputHue, 100, 0));
            const brightestRgb = ColorUtils.hexToRgb(ColorUtils.hslToHex(inputHue, 100, 100));
            hueMinContrast = ColorUtils.getContrast(darkestRgb, bg);   // Step50 anchor
            const theoreticalMax = ColorUtils.getContrast(brightestRgb, bg);
            hueMaxContrast = Math.min(19.0, theoreticalMax); // Step950을 19.0으로 제한
        }

        // 3) Grayscale 분포의 비율로 hue 범위에 보간
        const grayMinContrast = grayContrast[0];
        const grayMaxContrast = grayContrast[grayContrast.length - 1];
        
        return grayContrast.map(grayC => {
            const ratio = (grayC - grayMinContrast) / (grayMaxContrast - grayMinContrast);
            return hueMinContrast + ratio * (hueMaxContrast - hueMinContrast);
        });
    }
}

        // Wizard 관련 함수들
        let currentWizardStep = 1;
        let wizardThemeData = null;

        function goToStep(stepNumber) {

            // Step 1에서 Step 2로: 테마 변수 생성 (현재 스텝 상태와 무관하게 수행)
            if (stepNumber === 2) {
                createCustomThemeVariablesAndProceed();
                return; // 비동기 처리를 위해 여기서 리턴
            }

            // Step 2에서 Step 3로: 배경 선택 처리
            if (stepNumber === 3 && currentWizardStep === 2) {
                // 배경 선택 처리는 여기서 수행
                console.log('Step 2에서 Step 3로 이동');
            }

            // 프로그레스 업데이트
            updateProgressBar(stepNumber);

            // 스텝 콘텐츠 업데이트
            updateStepContent(stepNumber);

            // Step 2로 이동할 때 추천 배경색 업데이트
            if (stepNumber === 2) {
                setTimeout(() => {
                    const wizardBaseColor = document.getElementById('wizardThemeBaseColor');
                    if (wizardBaseColor && wizardBaseColor.value) {
                        updateRecommendedBackground(wizardBaseColor.value);
                    }
                }, 100);
            }

            currentWizardStep = stepNumber;
        }
        
        function updateProgressBar(stepNumber) {
            document.querySelectorAll('.progress-segment').forEach(segment => {
                const step = parseInt(segment.dataset.step);
                segment.classList.remove('active', 'completed');
                
                if (step < stepNumber) {
                    segment.classList.add('completed');
                } else if (step === stepNumber) {
                    segment.classList.add('active');
                }
            });
        }
        
        function updateStepContent(stepNumber) {
            document.querySelectorAll('.wizard-step').forEach(step => {
                step.classList.remove('active');
            });
            
            const targetStep = document.getElementById('wizardStep' + stepNumber);
            if (targetStep) {
                targetStep.classList.add('active');
                
                // Step 3에서 모드 미리보기 업데이트
                if (stepNumber === 3) {
                    setTimeout(() => {
                        const baseColorInput = document.getElementById('wizardThemeBaseHex');
                        if (baseColorInput && baseColorInput.value) {
                            updateAllModePreviewsWithColor(baseColorInput.value);
                        }
                    }, 100);
                }
            } else {
                console.error('Step element not found:', 'wizardStep' + stepNumber);
            }
        }
        
        function createCustomThemeVariablesAndProceed() {
            const themeNameInput = document.getElementById('wizardThemeNameInput');
            let themeName = normalizeThemeName(themeNameInput ? themeNameInput.value : '');
            if (!themeName) {
                themeName = 'custom-theme';
            }
            if (themeNameInput) {
                themeNameInput.value = themeName;
            }

            const baseColorInput = document.getElementById('wizardThemeBaseHex');
            const baseColor = baseColorInput ? baseColorInput.value : '';
            
            if (!baseColor) {
                showMessage('테마 이름과 색상을 입력해주세요!');
                return;
            }

            // 최근 사용한 컬러 업데이트 (중복 제거, 최대 10개)
            try { addCustomRecentColor(baseColor.toUpperCase()); } catch (e) { console.warn('최근 컬러 업데이트 실패', e); }

            customBackgroundTheme = null;
            try {
                const recommendedToggle = document.getElementById('recommendedBgToggle');
                const recommendedPanel = document.getElementById('recommendedBgPanel');
                const customBgToggle = document.getElementById('customBgToggle');
                const customBgPanel = document.getElementById('customBgPanel');
                const customBgContainer = document.getElementById('customBgColorContainer');
                if (recommendedToggle && recommendedPanel) {
                    recommendedPanel.classList.add('expanded');
                    recommendedPanel.style.display = 'block';
                    recommendedToggle.classList.add('expanded');
                    recommendedToggle.setAttribute('aria-expanded', 'true');
                }
                if (customBgToggle && customBgPanel) {
                    customBgPanel.classList.remove('expanded');
                    customBgPanel.style.display = 'none';
                    customBgToggle.classList.remove('expanded');
                    customBgToggle.setAttribute('aria-expanded', 'false');
                }
                if (customBgContainer) customBgContainer.style.display = 'none';
                const recSwatch = document.getElementById('recommendedBgCard');
                document.querySelectorAll('.bg-swatch').forEach(s => s.classList.remove('selected'));
                if (recSwatch) recSwatch.classList.add('selected');
            } catch {}

            // 테마 생성
            const tuningValue = 0; // 기본값
            currentTheme = themeGenerator.generateTheme(baseColor, themeName, 'accent-on-bg-off', tuningValue);
            
            // Mode 1의 semantic-background-default 기반 추천 배경 미리보기 즉시 업데이트
            try {
                if (typeof updateRecommendedBackground === 'function') {
                    updateRecommendedBackground(currentTheme.baseColor || baseColor);
                }
                updateCustomBgHint();
            } catch (e) { console.warn('추천 배경 초기 업데이트 실패:', e); }
            
            // 모드 카드 미리보기 업데이트
            updateModeCardPreviews();
            
            // 백엔드에 테마 변수 생성 요청
            parent.postMessage({
                pluginMessage: {
                    type: 'create-custom-theme',
                    theme: currentTheme
                }
            }, '*');
            
            showMessage(`${themeName} 테마 변수를 생성 중...`);
            
            // 잠시 후 Step 2로 진행
            setTimeout(() => {
                generateWizardTheme(); // 토큰 미리보기 생성
                updateProgressBar(2);
                updateStepContent(2);
                currentWizardStep = 2;
                // Step2 UI가 활성화된 뒤 다시 한번 추천 배경 업데이트 (DOM 보장)
                try {
                    if (typeof updateRecommendedBackground === 'function') {
                        updateRecommendedBackground(currentTheme.baseColor || baseColor);
                    }
                    updateCustomBgHint();
                } catch (e) { console.warn('추천 배경 재업데이트 실패:', e); }
                showMessage('테마 변수가 생성되었습니다!');
            }, 1000);
        }

        function createCustomBackgroundVariables() {
            if (!currentTheme) {
                showMessage('먼저 Step 1에서 변수를 생성해주세요!');
                return;
            }

            const hexInput = document.getElementById('customBgHex');
            if (!hexInput) {
                showMessage('배경 색상 입력 필드를 찾을 수 없습니다.');
                return;
            }

            const hex = (hexInput.value || '').trim().toUpperCase();
            if (!/^#[0-9A-F]{6}$/i.test(hex)) {
                showMessage('유효한 HEX 색상을 입력해주세요 (예: #F5F5F5)');
                return;
            }

            if (!themeGenerator) {
                showMessage('테마 생성기를 초기화할 수 없습니다.');
                return;
            }

            const baseThemeName = currentTheme && currentTheme.themeName ? currentTheme.themeName : 'custom-theme';
            let backgroundThemeName = baseThemeName.endsWith('-bg') ? baseThemeName : baseThemeName + '-bg';
            backgroundThemeName = normalizeThemeName(backgroundThemeName) || (baseThemeName + '-bg');

            const backgroundTheme = themeGenerator.generateTheme(hex, backgroundThemeName, 'custom-background', 0);
            backgroundTheme.applicationMode = 'custom-background';

            customBackgroundTheme = backgroundTheme;

            parent.postMessage({
                pluginMessage: {
                    type: 'create-custom-theme',
                    theme: backgroundTheme
                }
            }, '*');

            showMessage(backgroundThemeName + ' 변수를 생성 중...');
        }

        // 최근 사용한 컬러 - Custom Theme용 저장/표시/상호작용
        window.customRecentColorsMem = window.customRecentColorsMem || [];
        function getCustomRecentColors() {
            try {
                const raw = localStorage.getItem('recentColorsCustom');
                if (!raw) return window.customRecentColorsMem;
                const arr = JSON.parse(raw);
                return Array.isArray(arr) ? arr : window.customRecentColorsMem;
            } catch {
                return window.customRecentColorsMem;
            }
        }
        function setCustomRecentColors(list) {
            window.customRecentColorsMem = Array.isArray(list) ? list.slice() : [];
            try { localStorage.setItem('recentColorsCustom', JSON.stringify(window.customRecentColorsMem)); } catch {}
        }
        function addCustomRecentColor(hex) {
            if (!hex || !/^#[0-9A-F]{6}$/i.test(hex)) return;
            const up = hex.toUpperCase();
            let list = getCustomRecentColors().filter(c => c !== up);
            list.unshift(up);
            if (list.length > 10) list = list.slice(0,10);
            setCustomRecentColors(list);
            renderRecentColors();
            const section = document.getElementById('recentColorsSection');
            if (section) {
                section.style.display = 'block';
            }
            try { showMessage(`최근 컬러에 추가됨: ${up}`); } catch {}
        }
        function clearRecentColors() { setCustomRecentColors([]); renderRecentColors(); }
        function renderRecentColors() {
            const section = document.getElementById('recentColorsSection');
            const container = document.getElementById('recentColorsContainer');
            if (!section || !container) return;
            const list = getCustomRecentColors();
            if (!list.length) { section.style.display = 'none'; return; }
            section.style.display = 'block';
            container.innerHTML = '';
            list.forEach(hex => {
                const sw = document.createElement('div');
                sw.className = 'recent-swatch';
                sw.title = hex;
                sw.style.background = hex;
                sw.addEventListener('click', () => {
                    const picker = document.getElementById('wizardThemeBaseColor');
                    const input = document.getElementById('wizardThemeBaseHex');
                    if (picker) picker.value = hex;
                    if (input) input.value = hex;
                    if (typeof optimizedPreviewUpdate === 'function') optimizedPreviewUpdate(hex);
                    try { updateRecommendedBackground(hex); } catch {}
                    updateCustomBgHint();
                });
                container.appendChild(sw);
            });
            const clearBtn = document.getElementById('clearRecentBtn');
            if (clearBtn) {
                clearBtn.onclick = clearRecentColors;
            }
        }

        // 최근 사용한 컬러 - Tone Matching용
        window.toneRecentColorsMem = window.toneRecentColorsMem || [];
        function getToneRecentColors() {
            try {
                const raw = localStorage.getItem('recentColorsTone');
                if (!raw) return window.toneRecentColorsMem;
                const arr = JSON.parse(raw);
                return Array.isArray(arr) ? arr : window.toneRecentColorsMem;
            } catch {
                return window.toneRecentColorsMem;
            }
        }
        function setToneRecentColors(list) {
            window.toneRecentColorsMem = Array.isArray(list) ? list.slice() : [];
            try { localStorage.setItem('recentColorsTone', JSON.stringify(window.toneRecentColorsMem)); } catch {}
        }
        function addToneRecentColor(hex) {
            if (!hex || !/^#[0-9A-F]{6}$/i.test(hex)) return;
            const up = hex.toUpperCase();
            let list = getToneRecentColors().filter(c => c !== up);
            list.unshift(up);
            if (list.length > 10) list = list.slice(0,10);
            setToneRecentColors(list);
            renderToneRecentColors();
            const section = document.getElementById('toneRecentColorsSection');
            if (section) section.style.display = 'block';
        }
        function clearToneRecentColors() {
            setToneRecentColors([]);
            renderToneRecentColors();
        }
        function renderToneRecentColors() {
            const section = document.getElementById('toneRecentColorsSection');
            const container = document.getElementById('toneRecentColorsContainer');
            if (!section || !container) return;
            const list = getToneRecentColors();
            if (!list.length) { section.style.display = 'none'; return; }
            section.style.display = 'block';
            container.innerHTML = '';
            list.forEach(hex => {
                const sw = document.createElement('div');
                sw.className = 'recent-swatch';
                sw.title = hex;
                sw.style.background = hex;
                sw.addEventListener('click', () => {
                    const picker = document.getElementById('referenceColorPicker');
                    const input = document.getElementById('referenceColorHex');
                    if (picker) picker.value = hex;
                    if (input) input.value = hex;
                    setReferenceColorFromHex(hex);
                });
                container.appendChild(sw);
            });
            const clearBtn = document.getElementById('clearToneRecentBtn');
            if (clearBtn) {
                clearBtn.onclick = () => { clearToneRecentColors(); };
            }
        }

        function generateWizardTheme() {
            
            // currentTheme가 이미 생성되어 있다면 그것을 사용
            if (currentTheme) {
                const themeName = currentTheme.themeName;
                const closestStep = currentTheme.selectedStep || 200;
                
                // Step 2가 제거되었으므로 토큰 미리보기 업데이트 생략

                // wizardThemeData와 동기화
                wizardThemeData = {
                    themeName: themeName,
                    baseColor: currentTheme.baseColor,
                    closestStep: closestStep,
                    applicationMode: currentTheme.applicationMode || 'accent-on-bg-off',
                    colorRange: currentTheme.colorRange || null
                };
            } else {
                // 기존 로직 (fallback)
                const nameInput = document.getElementById('wizardThemeNameInput');
                let themeName = normalizeThemeName(nameInput ? nameInput.value : '');
                if (!themeName) {
                    themeName = 'custom-theme';
                    if (nameInput) {
                        nameInput.value = themeName;
                    }
                }
                const baseColor = document.getElementById('wizardThemeBaseHex').value;
                
                // Scale Generator와 동일한 로직 사용
                const closestStep = ColorUtils.findClosestStep(baseColor, 'light');
                let colorRange = 'medium';
                try {
                    colorRange = themeGenerator.getColorClassification(baseColor, closestStep);
                } catch (e) {
                    console.warn('colorRange 계산 실패:', e);
                }


                wizardThemeData = {
                    themeName: themeName,
                    baseColor: baseColor,
                    closestStep: closestStep,
                    applicationMode: 'accent-on-bg-off',
                    colorRange: colorRange
                };
            }

        }

        function getRecommendedNeighborSteps(baseStep) {
            var results = [];
            if (!baseStep || !colorGenerator || !Array.isArray(colorGenerator.steps)) return results;
            var steps = colorGenerator.steps;
            var index = steps.indexOf(baseStep);
            if (index === -1) return results;

            function addByIndex(idx) {
                if (idx >= 0 && idx < steps.length) {
                    var candidate = steps[idx];
                    if (candidate !== baseStep && results.indexOf(candidate) === -1) {
                        results.push(candidate);
                    }
                }
            }

            if (index > 0) addByIndex(index - 1);

            if (baseStep < 500) {
                [index + 2, index + 3, index + 1, index + 4, index + 5].forEach(addByIndex);
            } else {
                [index - 2, index - 3, index - 4, index - 5, index - 6].forEach(addByIndex);
            }

            if (results.length < 3) {
                [index + 1, index + 2, index - 1, index - 2, index + 3, index - 3].forEach(addByIndex);
            }

            return results.slice(0, 3);
        }

        function getColorHexForStep(step) {
            if (!step || !currentTheme || !currentTheme.scaleColors || !Array.isArray(currentTheme.scaleColors.light)) {
                return null;
            }
            var match = currentTheme.scaleColors.light.find(function(c) { return c.step === step; });
            return match ? match.hex : null;
        }

        function selectBackgroundOption(button) {
            // 모든 bg-swatch에서 selected 클래스 제거
            var swatches = document.querySelectorAll('.bg-swatch');
            swatches.forEach(function(s) { s.classList.remove('selected'); });
            
            // 클릭된 버튼에 selected 클래스 추가
            button.classList.add('selected');
            
            var stepAttr = button.getAttribute('data-step');
            var modeAttr = button.getAttribute('data-mode');
            var step = stepAttr ? parseInt(stepAttr, 10) : null;
            
            if (step !== null && !isNaN(step)) {
                // 추천 인접 색상이 선택된 경우
                recommendedSelection = { type: 'step', value: 'accent-on-bg-off', step: step };
                if (currentTheme) {
                    currentTheme.overrideRecommendedStep = step;
                    currentTheme.applicationMode = 'accent-on-bg-off';
                    // backgroundTheme으로 설정하여 semantic/background/default가 이 색상으로 매핑되게 함
                    currentTheme.backgroundTheme = {
                        themeName: currentTheme.themeName,
                        scaleColors: currentTheme.scaleColors
                    };
                }
                if (wizardThemeData) {
                    wizardThemeData.applicationMode = 'accent-on-bg-off';
                    wizardThemeData.closestStep = step;
                }
                console.log('추천 인접 색상 선택됨:', step, '색상:', getColorHexForStep(step));
            } else if (modeAttr) {
                // 기본 모드가 선택된 경우
                recommendedSelection = { type: 'mode', value: modeAttr, step: null };
                if (currentTheme) {
                    currentTheme.overrideRecommendedStep = null;
                    currentTheme.applicationMode = modeAttr;
                    currentTheme.backgroundTheme = null; // 기본 모드는 backgroundTheme 사용 안함
                }
                if (wizardThemeData) {
                    wizardThemeData.applicationMode = modeAttr;
                }
                console.log('기본 모드 선택됨:', modeAttr);
            }

            displayThemePreview(currentTheme);
        }

        function renderRecommendedExtras(baseStep, steps) {
            // swatch-grid에서 기존 추천 색들 제거
            var swatchGrid = document.querySelector('.bg-swatch-grid');
            if (!swatchGrid) return;
            
            var existingRecommended = swatchGrid.querySelectorAll('.bg-swatch.recommended-extra');
            existingRecommended.forEach(function(el) { el.remove(); });
            
            if (!steps || !steps.length) return;
            
            steps.forEach(function(step) {
                var color = getColorHexForStep(step);
                if (!color) return;
                var button = document.createElement('button');
                button.type = 'button';
                button.className = 'bg-swatch recommended-extra';
                button.dataset.step = step;
                button.dataset.mode = 'accent-on-bg-off';
                button.addEventListener('click', function() {
                    selectBackgroundOption(this);
                });
                var chip = document.createElement('span');
                chip.className = 'bg-swatch-chip';
                chip.style.setProperty('--swatch-color', color);
                button.appendChild(chip);
                swatchGrid.appendChild(button);
            });
        }

        function applyRecommendedSelectionUI() {
            var swatches = document.querySelectorAll('#recommendedBgPanel .bg-swatch');
            swatches.forEach(function(s) { s.classList.remove('selected'); });

            var target = null;
            if (recommendedSelection.type === 'mode') {
                target = document.querySelector('#recommendedBgPanel .bg-swatch[data-mode="' + recommendedSelection.value + '"]');
            } else if (recommendedSelection.type === 'step') {
                target = document.querySelector('#recommendedBgPanel .bg-swatch[data-step="' + recommendedSelection.step + '"]');
                if (!target) {
                    target = document.querySelector('#recommendedBgPanel .bg-swatch[data-mode="accent-on-bg-off"]');
                }
            }

            if (!target) {
                target = document.querySelector('#recommendedBgPanel .bg-swatch[data-mode="accent-on-bg-fixed"]');
                recommendedSelection = { type: 'mode', value: 'accent-on-bg-fixed', step: null };
            }

            if (target) {
                target.classList.add('selected');
            }
        }

        function handleRecommendedSwatchSelection(button) {
            var stepAttr = button.getAttribute('data-step');
            var modeAttr = button.getAttribute('data-mode');
            var step = stepAttr ? parseInt(stepAttr, 10) : null;

            if (step !== null && !isNaN(step)) {
                recommendedSelection = { type: 'step', value: 'accent-on-bg-off', step: step };
                if (currentTheme) {
                    currentTheme.overrideRecommendedStep = step;
                    currentTheme.applicationMode = 'accent-on-bg-off';
                }
                if (wizardThemeData) {
                    wizardThemeData.applicationMode = 'accent-on-bg-off';
                    wizardThemeData.closestStep = step;
                }
            } else if (modeAttr) {
                recommendedSelection = { type: 'mode', value: modeAttr, step: null };
                if (currentTheme) {
                    currentTheme.overrideRecommendedStep = null;
                    currentTheme.applicationMode = modeAttr;
                }
                if (wizardThemeData) {
                    wizardThemeData.applicationMode = modeAttr;
                }
            }

            applyRecommendedSelectionUI();
            customBackgroundTheme = null;
            updateCustomBgHint();
        }

        function handleRecommendedPanelClick(event) {
            var panel = document.getElementById('recommendedBgPanel');
            if (!panel) return;
            var button = event.target.closest('.bg-swatch');
            if (!button || !panel.contains(button)) return;
            handleRecommendedSwatchSelection(button);
        }

        // 추천 배경색 업데이트 함수
        // code.js 매핑 규칙을 반영한 추천 배경 계산
        // 밝음(light)  -> semantic/background/default = REF:{themeName}950
        // 중간(medium) -> semantic/background/default = REF:{themeName}100
        // 어두움(dark) -> semantic/background/default = REF:{themeName}100
        function updateRecommendedBackground(keyColor) {
            let recommendedBg = '#F5F5F5'; // 기본 표시값

            // 1) 백엔드 semanticColors 우선 사용
            if (currentTheme && currentTheme.semanticColors && currentTheme.semanticColors['accent-on-bg-off']) {
                const mode1Semantics = currentTheme.semanticColors['accent-on-bg-off'];
                if (mode1Semantics['semantic-background-default']) {
                    recommendedBg = mode1Semantics['semantic-background-default'];
                }
            } else if (currentTheme && currentTheme.scaleColors && Array.isArray(currentTheme.scaleColors.light)) {
                // 2) 프론트에서 REF:{themeName}{step} 해석
                const range = currentTheme.colorRange || (function() {
                    const step = currentTheme.selectedStep || 500;
                    return step < 200 ? 'light' : (step >= 300 && step <= 700 ? 'medium' : 'dark');
                })();
                const targetStep = (range === 'light') ? 950 : 100;
                const swatch = currentTheme.scaleColors.light.find(c => c.step === targetStep);
                if (swatch && swatch.hex) {
                    recommendedBg = swatch.hex;
                }
            }

            // 추천 배경색 프리뷰 업데이트
            const recommendedBgPreview = document.getElementById('recommendedBgPreview');

            if (recommendedBgPreview) {
                recommendedBgPreview.style.setProperty('--swatch-color', recommendedBg);
            }

            var recommendedStep = null;
            if (currentTheme && currentTheme.scaleColors && Array.isArray(currentTheme.scaleColors.light)) {
                recommendedStep = findClosestStepFromColors(currentTheme.scaleColors.light, recommendedBg);
            }
            var extraSteps = getRecommendedNeighborSteps(recommendedStep);
            renderRecommendedExtras(recommendedStep, extraSteps);

            console.log('추천 배경색 업데이트:', recommendedBg);
        }

        function getKeyColorInfo() {
            let step = null;
            let range = null;

            if (currentTheme) {
                step = currentTheme.selectedStep || currentTheme.closestStep || step;
                range = currentTheme.colorRange || range;
            }

            if (!step && wizardThemeData && wizardThemeData.closestStep) {
                step = wizardThemeData.closestStep;
            }

            if (!range && wizardThemeData && wizardThemeData.colorRange) {
                range = wizardThemeData.colorRange;
            }

            if (!range && step) {
                if (step < 300) range = 'light';
                else if (step >= 300 && step <= 700) range = 'medium';
                else range = 'dark';
            }

            return { step, range };
        }

        function rangeToKoreanLabel(range) {
            switch(range) {
                case 'light': return '밝은 단계';
                case 'dark': return '어두운 단계';
                default: return '중간 단계';
            }
        }

        function updateCustomBgHint() {
            const hint = document.getElementById('customBgHint');
            const panel = document.getElementById('customBgPanel');
            if (!hint || !panel) return;

            const isVisible = panel.classList.contains('expanded');
            if (!isVisible) {
                hint.style.display = 'none';
                hint.textContent = '';
                return;
            }

            const info = getKeyColorInfo();
            if (!info.step) {
                hint.style.display = 'none';
                hint.textContent = '';
                return;
            }

            const label = rangeToKoreanLabel(info.range);
            hint.textContent = `현재 Key Color가 Step ${info.step}이니 ${label}의 배경색을 추천드려요.`;
            hint.style.display = 'block';
        }

        // Step 2에서 배경 선택 후 테마 적용
        function applyCustomThemeWithBackground() {
            // 선택된 배경 모드 확인
            let selectedMode = 'accent-on-bg-off'; // 기본값 (Mode 1)
            let customBackgroundColor = null;

            const customBgPanel = document.getElementById('customBgPanel');
            const useCustomBackground = customBgPanel && customBgPanel.classList.contains('expanded');
            if (useCustomBackground) {
                selectedMode = 'custom-background';
                const customBgHex = document.getElementById('customBgHex');
                if (customBgHex) {
                    const hex = customBgHex.value.toUpperCase();
                    if (!/^#[0-9A-F]{6}$/i.test(hex)) {
                        showMessage('유효한 HEX 색상을 입력해주세요 (예: #F5F5F5)');
                        return;
                    }
                    customBackgroundColor = hex;
                }
            } else {
                // 선택된 카드 확인
                const selectedSwatch = document.querySelector('.bg-swatch.selected');
                if (selectedSwatch) {
                    selectedMode = selectedSwatch.dataset.mode;
                }
            }

            // currentTheme 업데이트 (wizardThemeData 대신 currentTheme 사용)
            if (currentTheme) {
                currentTheme.applicationMode = selectedMode;
                if (customBackgroundColor) {
                    currentTheme.customBackgroundColor = customBackgroundColor;
                } else {
                    delete currentTheme.customBackgroundColor;
                }
                if (selectedMode === 'custom-background' && customBackgroundTheme) {
                    currentTheme.backgroundTheme = customBackgroundTheme;
                } else {
                    delete currentTheme.backgroundTheme;
                }
            } else {
                showMessage('먼저 테마를 생성해주세요!');
                return;
            }

            // 테마 적용 로그
            console.log('🎨 테마 적용 시작');
            console.log('- 선택된 모드:', selectedMode);
            console.log('- 커스텀 배경:', customBackgroundColor);
            console.log('- 테마 데이터:', currentTheme);

            // Figma로 테마 적용 메시지 전송 (성공/실패 스낵바는 message listener에서 처리)
            const themeToApply = {
                ...currentTheme,
                applicationMode: selectedMode
            };

            if (selectedMode === 'custom-background' && customBackgroundTheme) {
                themeToApply.backgroundTheme = customBackgroundTheme;
            }

            parent.postMessage({
                pluginMessage: {
                    type: 'apply-theme-colors-to-frame',
                    theme: themeToApply
                }
            }, '*');

            // 안내 스낵바 (성공 확정 전 상태 메시지)
            showMessage('테마 토큰을 Frame에 적용 중...');
        }

        function selectModeCard(card, mode) {
            
            // 모든 카드에서 selected 클래스 제거
            document.querySelectorAll('.mode-card').forEach(c => {
                c.classList.remove('selected');
            });
            
            // 클릭된 카드에 selected 클래스 추가
            card.classList.add('selected');
            
            // 테마 데이터 업데이트
            if (wizardThemeData) {
                wizardThemeData.applicationMode = mode;
            }
        }

        // 모드별 토큰 미리보기 업데이트
        function updateModeCardPreviews() {
            if (!currentTheme) return;
            
            
            const modes = ['accent-on-bg-off', 'accent-on-bg-fixed', 'accent-on-bg-black'];
            
            modes.forEach(mode => {
                const tokens = getTokensForMode(mode);
                updateModeCardPreview(mode, tokens);
            });
        }
        
        // 특정 모드의 토큰값 계산 (밝기 기준에 따른 매핑 규칙 적용)
        function getTokensForMode(mode) {
            if (!currentTheme || !currentTheme.scaleColors) return null;
            
            const lightColors = currentTheme.scaleColors.light;
            const darkColors = currentTheme.scaleColors.dark;
            const selectedStep = currentTheme.selectedStep || 500;
            
            // 밝기 기준 (백엔드 getDynamicMappings와 동일한 로직)
            let isBrightColor = selectedStep < 200; // 200 미만
            if (currentTheme.baseColor) {
                const hsl = ColorUtils.hexToHsl(currentTheme.baseColor);
                const lightness = hsl[2];
                // 밝기가 80% 이상이면 bright color로 분류
                if (lightness >= 80) {
                    isBrightColor = true;
                }
            }
            
            let backgroundLight, textPrimaryLight, fillPrimaryLight;
            // color range 결정 (이미 계산되어 있으면 우선 사용)
            let colorRangeFlag;
            if (currentTheme.colorRange) {
                colorRangeFlag = currentTheme.colorRange; // 'light' | 'medium' | 'dark'
            } else {
                colorRangeFlag = isBrightColor ? 'light' : (selectedStep >= 300 && selectedStep <= 700 ? 'medium' : 'dark');
            }

            // Neutral gray helper (Light Mode)
            const grayGen = new ColorGenerator();
            const stepToGray = (step) => {
                const idx = grayGen.steps.indexOf(step);
                return idx >= 0 ? grayGen.lightModeGrayTones[idx] : '#F5F5F5';
            };
            // 색상 범위 분류 사용 (있으면 우선)
            const colorRange = currentTheme.colorRange || (isBrightColor ? 'light' : (selectedStep >= 300 && selectedStep <= 700 ? 'medium' : 'dark'));
            
                switch(mode) {
                case 'accent-on-bg-off':
                    // Foreground 중심: neutral 배경, 색상 밝기군에 따른 단계 적용
                    // - light  -> GRAY:900
                    // - medium -> GRAY:100
                    // - dark   -> GRAY:50
                    if (colorRangeFlag === 'light') {
                        backgroundLight = stepToGray(900);
                    } else if (colorRangeFlag === 'medium') {
                        backgroundLight = stepToGray(100);
                    } else { // 'dark'
                        backgroundLight = stepToGray(50);
                    }
                    if (isBrightColor) {
                        textPrimaryLight = lightColors.find(c => c.step === 900)?.hex || '#000000';
                        fillPrimaryLight = lightColors.find(c => c.step === 600)?.hex;
                    } else {
                        textPrimaryLight = lightColors.find(c => c.step === selectedStep)?.hex;
                        fillPrimaryLight = lightColors.find(c => c.step === selectedStep)?.hex;
                    }
                    break;
                    
                case 'accent-on-bg-fixed':
                    // foreground 중심, white bg 고정
                    backgroundLight = '#FFFFFF';
                    if (isBrightColor) {
                        textPrimaryLight = lightColors.find(c => c.step === 900)?.hex || '#000000';
                        fillPrimaryLight = lightColors.find(c => c.step === 600)?.hex;
                    } else {
                        textPrimaryLight = lightColors.find(c => c.step === selectedStep)?.hex;
                        fillPrimaryLight = lightColors.find(c => c.step === selectedStep)?.hex;
                    }
                    break;
                    
                case 'accent-on-bg-black':
                    // foreground 중심, black bg 고정 (백엔드와 동일한 로직)
                    backgroundLight = '#1f1f1f';
                    // 실제 GRAY:50 색상 사용 (Light Mode gray scale의 50번째)
                    const colorGenerator = new ColorGenerator();
                    textPrimaryLight = colorGenerator.lightModeGrayTones[0]; // 50번째 = index 0 = '#FFFFFF'
                    if (isBrightColor) {
                        fillPrimaryLight = lightColors.find(c => c.step === selectedStep)?.hex;
                    } else {
                        fillPrimaryLight = lightColors.find(c => c.step === selectedStep)?.hex;
                    }
                    break;
            }
            
            
            // fillSurfaceContents는 항상 연한 회색 계열 (50-100 단계)
            const fillSurfaceContentsLight = lightColors.find(c => c.step === 50)?.hex || '#f9fafb';
            
            return {
                background: backgroundLight,
                textPrimary: textPrimaryLight,
                fillPrimary: fillPrimaryLight,
                fillSurfaceContents: fillSurfaceContentsLight
            };
        }
        
        // 모드 카드 미리보기 업데이트
        function updateModeCardPreview(mode, tokens) {
            if (!tokens) return;
            
            // Restrict to mode preview cards only (avoid touching bg-card)
            const card = document.querySelector(`.mode-card[data-mode="${mode}"]`);
            if (!card) return;
            
            const previewFrame = card.querySelector('.preview-frame');
            const frameHeader = card.querySelector('.frame-header');
            const frameButton = card.querySelector('.frame-button');
            
            // 모든 모드의 mode-card 자체에 배경색 적용
            card.style.backgroundColor = tokens.background;
            
            // 텍스트 색상 적용 (로고)
            if (frameHeader) {
                const svgPaths = frameHeader.querySelectorAll('svg path');
                svgPaths.forEach(path => {
                    path.setAttribute('fill', tokens.textPrimary);
                    path.style.setProperty('fill', tokens.textPrimary, 'important');
                });
            }
            
            // 버튼 색상 적용 (semantic/fill/primary)
            if (frameButton) {
                frameButton.style.backgroundColor = tokens.fillPrimary;
                frameButton.style.border = 'none';
                frameButton.style.boxShadow = 'none';
            }
            
            // content-block 색상 적용 (semantic/fill/surface-contents 미리보기)
            const contentBlocks = card.querySelectorAll('.content-block');
            contentBlocks.forEach(block => {
                block.style.backgroundColor = tokens.fillSurfaceContents || '#f1f5f9';
                block.style.border = 'none';
            });
            
            // 카드 라벨 텍스트 색상 고정 (카드 밖으로 나왔으므로 검은색 고정)
            const cardLabel = card.querySelector('.card-label');
            const cardSubLabel = card.querySelector('.card-sub-label');
            if (cardLabel) {
                cardLabel.style.setProperty('color', '#000000', 'important');
            }
            if (cardSubLabel) {
                cardSubLabel.style.setProperty('color', '#000000', 'important');
            }
        }

        // 현재 입력된 색상을 기반으로 모든 모드 카드의 미리보기를 실시간 업데이트하는 함수
        function updateAllModePreviewsWithColor(baseColor) {
            if (!baseColor || !baseColor.startsWith('#')) {
                return;
            }
            
            // 각 모드에 대해 색상 토큰 계산 및 미리보기 업데이트
            const modes = ['accent-on-bg-off', 'accent-on-bg-fixed', 'accent-on-bg-black'];
            
            modes.forEach(mode => {
                const tokens = calculatePreviewTokensForMode(baseColor, mode);
                if (tokens) {
                    updateModeCardPreview(mode, tokens);
                }
            });
        }

        // 현재 테마의 실시간 미리보기 업데이트
        function updateCurrentThemePreview(newBaseColor) {
            if (!currentTheme || !themeGenerator) return;
            
            // 현재 테마의 설정을 유지하면서 baseColor만 변경
            const themeName = currentTheme.themeName || 'preview-theme';
            const applicationMode = currentTheme.applicationMode || 'accent-on-bg-off';
            const tuningValue = 0; // 기본값
            
            try {
                const updatedTheme = themeGenerator.generateTheme(newBaseColor, themeName, applicationMode, tuningValue);
                currentTheme = updatedTheme;
                
                // 테마 미리보기 업데이트
                displayThemePreview(updatedTheme);
                
            } catch (error) {
                console.warn('테마 실시간 업데이트 중 오류:', error);
            }
        }

        // 미리보기 업데이트 성능 최적화
        function optimizedPreviewUpdate(baseColor) {
            // 이미 같은 색상으로 업데이트 중이면 스킵
            if (window.lastPreviewColor === baseColor) return;
            window.lastPreviewColor = baseColor;
            
            // 애니메이션 프레임 내에서 업데이트 실행
            requestAnimationFrame(() => {
                updateAllModePreviewsWithColor(baseColor);
                updateWizardStepIndicator(baseColor);
                
                if (currentTheme) {
                    updateCurrentThemePreview(baseColor);
                }
            });
        }

        // 각 모드별로 미리보기용 색상 토큰을 계산하는 함수 (실제 semantic token 매핑 기반)
        function calculatePreviewTokensForMode(baseColor, mode) {
            if (!baseColor) return null;
            
            try {
                // 임시 테마 생성하여 실제 매핑 규칙 사용
                const tempTheme = themeGenerator ? themeGenerator.generateTheme(baseColor, 'preview', mode, 0) : null;
                if (tempTheme && tempTheme.scaleColors) {
                    
                    // 실제 semantic token 매핑에서 값 추출
                    const lightColors = tempTheme.scaleColors.light;
                    const darkColors = tempTheme.scaleColors.dark;
                    
                    // 색상 분류 (실제 로직과 동일)
                    const hsl = ColorUtils.hexToHsl ? ColorUtils.hexToHsl(baseColor) : hexToHsl(baseColor);
                    const lightness = hsl[2];
                    const hue = hsl[0];
                    const saturation = hsl[1];
                    
                    // 색상 분류 로직 (75% 기준)
                    let isInherentlyBright = false;
                    if (saturation < 20) {
                        isInherentlyBright = (lightness >= 50);
                    } else {
                        if (lightness >= 75) {
                            isInherentlyBright = true;
                        } else {
                            // Hue 기반 판단
                            const isBrightHue = (hue >= 50 && hue <= 190);
                            isInherentlyBright = isBrightHue;
                        }
                    }
                    
                    // closestStep 계산
                    const closestStep = findClosestStepFromColors(lightColors, baseColor) || 500;
                    
                    // 색상 범위 결정
                    let colorRange;
                    if (isInherentlyBright) {
                        if (closestStep <= 400) colorRange = 'light';
                        else if (closestStep >= 500 && closestStep <= 700) colorRange = 'medium';
                        else colorRange = 'dark';
                    } else {
                        if (closestStep < 300) colorRange = 'light';
                        else if (closestStep >= 300 && closestStep <= 700) colorRange = 'medium';
                        else colorRange = 'dark';
                    }
                    
                    // 모드별 매핑 결정
                    return calculateTokensForModeAndRange(mode, colorRange, lightColors, darkColors, baseColor, closestStep);
                }
            } catch (error) {
                console.warn('임시 테마 생성 실패, 기본 로직 사용:', error);
            }
            
            // 폴백: 기본 로직
            return calculateBasicPreviewTokens(baseColor, mode);
        }

        // 실제 semantic token 매핑 기반 토큰 계산
        function calculateTokensForModeAndRange(mode, colorRange, lightColors, darkColors, baseColor, closestStep) {
            let tokens = {
                background: '#ffffff',
                textPrimary: '#000000',  
                fillPrimary: baseColor,
                fillSurfaceContents: '#f8fafc'
            };
            
            const getColorByStep = (step) => {
                const color = lightColors.find(c => c.step === step);
                return color ? color.hex : baseColor;
            };
            
            switch (mode) {
                case 'accent-on-bg-off': // foreground 중심
                    if (colorRange === 'light') {
                        // 밝은 색상: 어두운 배경 + 밝은 fillPrimary
                        tokens.background = getColorByStep(950);  
                        tokens.textPrimary = '#f9fafb'; // GRAY:50 (밝은 텍스트)
                        tokens.fillPrimary = getColorByStep(400); // 밝은 primary 색상
                        tokens.fillSurfaceContents = 'rgba(255,255,255,0.2)'; // STATIC-WHITE-ALPHA:200
                    } else if (colorRange === 'medium') {
                        // 중간 색상: 색상 배경 + 밝은 primary
                        tokens.background = getColorByStep(closestStep);
                        tokens.textPrimary = 'rgba(255,255,255,0.9)'; // STATIC-WHITE-ALPHA:900
                        tokens.fillPrimary = getColorByStep(50); // 밝은 primary
                        tokens.fillSurfaceContents = 'rgba(255,255,255,0.2)'; 
                    } else {
                        // 어두운 색상: 색상 배경 + 밝은 primary  
                        tokens.background = getColorByStep(closestStep);
                        tokens.textPrimary = 'rgba(255,255,255,0.9)'; // STATIC-WHITE-ALPHA:900
                        tokens.fillPrimary = getColorByStep(50); // 밝은 primary
                        tokens.fillSurfaceContents = 'rgba(255,255,255,0.2)';
                    }
                    break;
                    
                case 'accent-on-bg-fixed': // foreground 중심 white bg
                    tokens.background = '#ffffff'; // 항상 흰 배경으로 고정
                    tokens.textPrimary = '#1f2937'; // GRAY:900
                    tokens.fillPrimary = getColorByStep(closestStep);
                    tokens.fillSurfaceContents = 'rgba(107,114,128,0.1)'; // GRAY-ALPHA:100
                    break;
                    
                case 'accent-on-bg-black': // foreground 중심 black bg
                    tokens.background = '#1f1f1f';
                    tokens.textPrimary = '#f9fafb'; // GRAY:50
                    tokens.fillPrimary = baseColor;
                    tokens.fillSurfaceContents = 'rgba(255,255,255,0.2)'; // STATIC-WHITE-ALPHA:200
                    break;
            }
            
            return tokens;
        }

        // 기본 미리보기 토큰 계산 (폴백)
        function calculateBasicPreviewTokens(baseColor, mode) {
            const hsl = ColorUtils.hexToHsl ? ColorUtils.hexToHsl(baseColor) : hexToHsl(baseColor);
            const lightness = hsl[2];
            const isLightColor = lightness >= 75;
            
            let tokens = {
                background: '#ffffff',
                textPrimary: '#000000',
                fillPrimary: baseColor,
                fillSurfaceContents: '#f8fafc'
            };
            
            switch (mode) {
                case 'accent-on-bg-off':
                    if (isLightColor) {
                        tokens.background = adjustColorLightness(baseColor, 15);
                        tokens.textPrimary = '#ffffff';
                    } else {
                        tokens.background = adjustColorLightness(baseColor, 95);
                        tokens.textPrimary = '#000000';
                    }
                    break;
                    
                case 'accent-on-bg-fixed':
                    tokens.background = '#ffffff';
                    tokens.textPrimary = '#000000';
                    break;
                    
                case 'accent-on-bg-black':
                    tokens.background = '#1f1f1f';
                    tokens.textPrimary = '#ffffff';
                    break;
            }
            
            return tokens;
        }

        // 색상 배열에서 가장 가까운 step 찾기
        function findClosestStepFromColors(colors, targetColor) {
            if (!colors || !targetColor) return 500;
            
            const targetHsl = ColorUtils.hexToHsl ? ColorUtils.hexToHsl(targetColor) : hexToHsl(targetColor);
            const targetLightness = targetHsl[2];
            
            let closestStep = 500;
            let minDiff = Infinity;
            
            colors.forEach(color => {
                const colorHsl = ColorUtils.hexToHsl ? ColorUtils.hexToHsl(color.hex) : hexToHsl(color.hex);
                const diff = Math.abs(targetLightness - colorHsl[2]);
                
                if (diff < minDiff) {
                    minDiff = diff;
                    closestStep = color.step;
                }
            });
            
            return closestStep;
        }

        // 색상의 명도를 조정하는 헬퍼 함수
        function adjustColorLightness(hex, targetLightness) {
            const hsl = ColorUtils.hexToHsl ? ColorUtils.hexToHsl(hex) : hexToHsl(hex);
            return ColorUtils.hslToHex ? ColorUtils.hslToHex(hsl[0], hsl[1], targetLightness) : hslToHex(hsl[0], hsl[1], targetLightness);
        }

        // 배경 색상에 대한 적절한 텍스트 색상을 반환하는 함수
        function getContrastTextColor(backgroundColor) {
            const hsl = ColorUtils.hexToHsl ? ColorUtils.hexToHsl(backgroundColor) : hexToHsl(backgroundColor);
            return hsl[2] > 50 ? '#000000' : '#ffffff';
        }

        // 더 밝은 색조를 생성하는 함수
        function getLighterShade(baseColor) {
            const hsl = ColorUtils.hexToHsl ? ColorUtils.hexToHsl(baseColor) : hexToHsl(baseColor);
            const lighterLightness = Math.min(hsl[2] + 30, 90);
            const reducedSaturation = Math.max(hsl[1] - 20, 30);
            return ColorUtils.hslToHex ? ColorUtils.hslToHex(hsl[0], reducedSaturation, lighterLightness) : hslToHex(hsl[0], reducedSaturation, lighterLightness);
        }

        // 밝은 색상 판단 함수 (코드베이스의 isLightRange와 동일한 로직)
        function isLightColor(hex) {
            if (!hex || !hex.startsWith('#')) return false;
            
            const hsl = ColorUtils.hexToHsl ? ColorUtils.hexToHsl(hex) : hexToHsl(hex);
            const lightness = hsl[2];
            const hue = hsl[0];
            
            // 1) HSL 밝기 기준: 80% 이상
            if (lightness >= 80) return true;
            
            // 2) BornBright 색상: Hue 40°-190° (노랑~청록 계열)
            if (hue >= 40 && hue <= 190) return true;
            
            return false;
        }

        // 색상 분류 정보를 반환하는 함수
        function getColorClassification(hex) {
            if (!hex || !hex.startsWith('#')) return null;
            
            const hsl = ColorUtils.hexToHsl ? ColorUtils.hexToHsl(hex) : hexToHsl(hex);
            const lightness = hsl[2];
            const hue = hsl[0];
            const isLight = isLightColor(hex);
            
            let reasons = [];
            if (lightness >= 80) reasons.push(`밝기 ${Math.round(lightness)}%`);
            if (hue >= 40 && hue <= 190) reasons.push('본질적 밝은 색상 (노랑~청록 계열)');
            
            return {
                isLight: isLight,
                lightness: Math.round(lightness),
                hue: Math.round(hue),
                reasons: reasons,
                classification: isLight ? '밝은 범위' : '어두운 범위'
            };
        }

        // 색상 분류 정보 표시 업데이트 함수
        function updateColorClassificationDisplay(hex) {
            const classificationInfo = getColorClassification(hex);
            if (!classificationInfo) return;
            
            const classificationResult = document.getElementById('classificationResult');
            const lightnessValue = document.getElementById('lightnessValue');
            const hueValue = document.getElementById('hueValue');
            const classificationReasons = document.getElementById('classificationReasons');
            
            if (classificationResult) {
                classificationResult.textContent = classificationInfo.classification;
                classificationResult.className = `classification-result ${classificationInfo.isLight ? 'bright' : 'dark'}`;
            }
            
            if (lightnessValue) {
                lightnessValue.textContent = classificationInfo.lightness;
            }
            
            if (hueValue) {
                hueValue.textContent = classificationInfo.hue;
            }
            
            if (classificationReasons) {
                if (classificationInfo.reasons.length > 0) {
                    classificationReasons.textContent = '분류 근거: ' + classificationInfo.reasons.join(', ');
                    classificationReasons.style.display = 'block';
                } else {
                    classificationReasons.style.display = 'none';
                }
            }
        }

        // HSL 변환 함수들 (ColorUtils가 없는 경우 대비)
        function hexToHsl(hex) {
            const r = parseInt(hex.slice(1, 3), 16) / 255;
            const g = parseInt(hex.slice(3, 5), 16) / 255;
            const b = parseInt(hex.slice(5, 7), 16) / 255;

            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }

            return [h * 360, s * 100, l * 100];
        }

        function hslToHex(h, s, l) {
            h = h % 360;
            if (h < 0) h += 360;
            s = Math.max(0, Math.min(100, s));
            l = Math.max(0, Math.min(100, l));
            
            h /= 360;
            s /= 100;
            l /= 100;
            
            const a = s * Math.min(l, 1 - l);
            const f = n => {
                const k = (n + h * 12) % 12;
                return l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
            };
            
            const r = Math.round(f(0) * 255);
            const g = Math.round(f(8) * 255);
            const b = Math.round(f(4) * 255);
            
            return "#" + [r, g, b].map(x => {
                const hex = x.toString(16);
                return hex.length === 1 ? "0" + hex : hex;
            }).join("");
        }

        function applyCustomTheme() {
            if (!currentTheme && !wizardThemeData) {
                showMessage('먼저 테마를 생성해주세요!');
                return;
            }

            // 현재 선택된 모드로 테마 업데이트
            const selectedMode = document.querySelector('.mode-card.selected')?.dataset.mode || 'accent-on-bg-off';
            
            let themeToApply;
            if (currentTheme) {
                // currentTheme 사용 (이미 변수가 생성된 경우)
                themeToApply = {
                    ...currentTheme,
                    applicationMode: selectedMode
                };
            } else {
                // wizardThemeData 사용 (fallback)
                themeToApply = {
                    themeName: wizardThemeData.themeName,
                    baseColor: wizardThemeData.baseColor,
                    applicationMode: selectedMode,
                    scaleColors: { light: generateScaleColors(wizardThemeData.baseColor) }
                };
            }

            parent.postMessage({
                pluginMessage: {
                    type: 'apply-theme-colors-to-frame',
                    theme: themeToApply
                }
            }, '*');
            
            // 적용하기 후 annotation 자동 활성화
            const annotationCheckbox = document.getElementById('annotationToggle');
            if (annotationCheckbox) {
                // 체크박스 활성화 및 체크
                annotationCheckbox.disabled = false;
                annotationCheckbox.checked = true;
                
                // 라벨 텍스트 업데이트
                const labelSpan = annotationCheckbox.parentElement.querySelector('span');
                if (labelSpan) {
                    labelSpan.textContent = '선택된 요소의 색상 매핑 표시';
                    labelSpan.style.color = '#333';
                }
                
                toggleAnnotation(); // annotation 활성화 함수 호출
            }
            
            showMessage('Custom Theme 적용 중...');
        }

        function generateScaleColors(baseColor) {
            // 기존 ScaleColorGenerator 로직 사용
            const generator = new ScaleColorGenerator();
            return generator.generate(baseColor, 'light');
        }


        // Custom Theme 생성기 
        class CustomThemeGenerator {
            constructor() {
                // 고정 매핑만 남기기 (preserve tokens)
                this.fixedMappings = {
                    'fill/surface-floating': { light: 900, dark: 900 },
                    'fill/surface-dialog': { light: 50, dark: 75 },
                    'fill/surface-sheet': { light: 50, dark: 75 },
                    'fill/surface-black': { light: 950, dark: 50 },
                    'background/black': { light: 950, dark: 50 },
                    'common/on-white': { light: 50, dark: 950 },
                    'common/on-white-hover': { light: 75, dark: 900 },
                    'common/on-white-pressed': { light: 75, dark: 900 },
                    'common/on-black': { light: 900, dark: 75 },
                    'common/on-black-hover': { light: 950, dark: 50 },
                    'common/on-black-pressed': { light: 950, dark: 50 },
                    'overlay/dimmed': { light: 700, dark: 700 }
                };
            }

            generateTheme(baseHex, themeName, applicationMode, tuningValue = 0) {
                var colorGenerator = new ColorGenerator();
                var lightColors = colorGenerator.generateColors(baseHex, 'light', tuningValue);
                var darkColors = colorGenerator.generateColors(baseHex, 'dark', tuningValue);
                
                // 입력 색상의 명도로 closest step 찾기
                var inputHsl = ColorUtils.hexToHsl(baseHex);
                var inputLightness = inputHsl[2];
                var closestStepLight = this.findClosestStep(lightColors, inputLightness);
                var closestStepDark = this.findClosestStep(darkColors, inputLightness);
                
                // 색상 분류 결정 (code.js와 동일한 로직)
                var colorRange = this.getColorClassification(baseHex, closestStepLight);
                
                // 테마 객체 생성 (백엔드 형식과 일치)
                return {
                    themeName,
                    baseColor: baseHex,
                    applicationMode,
                    selectedStep: closestStepLight,
                    colorRange: colorRange, // 추가
                    scaleColors: { 
                        light: lightColors, 
                        dark: darkColors 
                    },
                    // semanticTokens는 백엔드에서 처리하므로 빈 배열
                    semanticTokens: []
                };
            }
            
            findClosestStep(colors, inputLightness) {
                var closestStep = 500;
                var minDifference = Infinity;
                
                colors.forEach(color => {
                    var colorLightness = ColorUtils.hexToHsl(color.hex)[2];
                    var diff = Math.abs(inputLightness - colorLightness);
                    
                    if (diff < minDifference) {
                        minDifference = diff;
                        closestStep = color.step;
                    }
                });
                
                return closestStep;
            }
            
            // 색상 분류 메서드 (code.js와 동일한 로직)
            getColorClassification(baseHex, closestStep) {
                var hsl = ColorUtils.hexToHsl(baseHex);
                var hue = hsl[0];
                var saturation = hsl[1];
                var lightness = hsl[2];
                
                var isInherentlyBright = false;
                
                // Hue의 본질적 밝기 판단
                function getHueBrightness(hue) {
                    // 매우 밝은 색상군
                    if (hue >= 50 && hue <= 70) return 'very-bright';     // 노랑
                    if (hue >= 170 && hue <= 190) return 'very-bright';   // 청록
                    
                    // 밝은 색상군  
                    if (hue >= 70 && hue <= 150) return 'bright';         // 연두-초록
                    if (hue >= 150 && hue <= 170) return 'bright';        // 청록-초록 경계
                    if (hue >= 30 && hue <= 50) return 'bright';          // 주황
                    
                    // 중간 색상군
                    if (hue >= 0 && hue <= 30) return 'medium';           // 빨강
                    if (hue >= 330 && hue <= 360) return 'medium';        // 빨강
                    if (hue >= 190 && hue <= 250) return 'medium';        // 파랑
                    
                    // 어두운 색상군
                    return 'dark';  // 보라 (250-330)
                }
                
                if (saturation < 20) {
                    // 회색조는 lightness로만 판단
                    isInherentlyBright = (lightness >= 50);
                } else {
                    if (lightness >= 75) {
                        isInherentlyBright = true;
                    } else {
                        var hueBrightness = getHueBrightness(hue);
                        isInherentlyBright = (hueBrightness === 'very-bright' || hueBrightness === 'bright');
                    }
                }
                
                // 색상 범위 결정
                var colorRange;
                if (isInherentlyBright) {
                    // 태생이 밝은 색상
                    if (closestStep <= 400) {
                        colorRange = 'light';
                    } else if (closestStep >= 500 && closestStep <= 700) {
                        colorRange = 'medium';
                    } else {
                        colorRange = 'dark';  // 800-950
                    }
                } else {
                    // 태생이 어두운 색상
                    if (closestStep < 300) {
                        colorRange = 'light';
                    } else if (closestStep >= 300 && closestStep <= 700) {
                        colorRange = 'medium';
                    } else {
                        colorRange = 'dark';  // 800-950
                    }
                }
                
                
                return colorRange;
            }
        }

        // 인스턴스 생성
        var colorGenerator = new ColorGenerator();
        var themeGenerator = new CustomThemeGenerator();

        // 탭 전환 함수
        function switchTab(tabName) {
            console.log('switchTab called with:', tabName);
            const tabNavigation = document.querySelector('.tab-navigation');
            
            // 모든 탭 버튼 비활성화
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // 모든 탭 콘텐츠 숨기기
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // 슬라이딩 애니메이션을 위한 클래스 제거
            if (tabName === 'generator') {
                document.getElementById('generatorTab').classList.add('active');
                document.getElementById('generatorContent').classList.add('active');
            } else if (tabName === 'tone-matching') {
                document.getElementById('toneMatchingTab').classList.add('active');
                document.getElementById('toneMatchingContent').classList.add('active');
            } else if (tabName === 'custom-theme') {
                document.getElementById('customThemeTab').classList.add('active');
                document.getElementById('customThemeContent').classList.add('active');
                // Custom Theme 탭 전환 시 색상 동기화 리스너 다시 설정
                setTimeout(() => {
                    setupWizardColorSync();
                }, 100);
            }
        }

        // Wizard 색상 동기화 설정 함수
        function setupWizardColorSync() {
            
            const wizardBaseColor = document.getElementById('wizardThemeBaseColor');
            const wizardBaseHex = document.getElementById('wizardThemeBaseHex');
            
            
            if (wizardBaseColor && wizardBaseHex) {
                
                // 기존 리스너 제거 (중복 방지)
                wizardBaseColor.removeEventListener('input', handleColorPickerChange);
                wizardBaseHex.removeEventListener('input', handleHexInputChange);
                
                // 새 리스너 추가 - input 이벤트로 실시간 반응
                wizardBaseColor.addEventListener('input', handleColorPickerChange);
                wizardBaseHex.addEventListener('input', handleHexInputChange);
                
                // change 이벤트도 추가 (마지막 확정값)
                wizardBaseColor.addEventListener('change', handleColorPickerChange);
                wizardBaseHex.addEventListener('change', handleHexInputChange);
                
                // 키보드 입력 시 더 즉각적인 반응을 위한 keyup 이벤트
                wizardBaseHex.addEventListener('keyup', (e) => {
                    const value = e.target.value.toUpperCase();
                    // Enter 키나 완전한 hex 값일 때 즉시 업데이트
                    if (e.key === 'Enter' || /^#[0-9A-F]{6}$/i.test(value)) {
                        clearTimeout(window.colorUpdateTimeout);
                        optimizedPreviewUpdate(value);
                    }
                });
                
                // 초기 미리보기 업데이트
                const initialColor = wizardBaseColor.value || wizardBaseHex.value;
                if (initialColor) {
                    setTimeout(() => {
                        updateAllModePreviewsWithColor(initialColor);
                        updateWizardStepIndicator(initialColor);
                        // Step 2 추천 배경색도 함께 초기화
                        if (typeof updateRecommendedBackground === 'function') {
                            updateRecommendedBackground(initialColor);
                        }
                        updateCustomBgHint();
                        // 최근 컬러 렌더링
                        renderRecentColors();
                        displayThemePreview(currentTheme);
                    }, 100);
                }
                
            } else {
                console.error('❌ Wizard color elements not found!');
                document.querySelectorAll('[id*="wizard"]').forEach(el => {
                });
            }
        }

        function handleColorPickerChange() {
            const wizardBaseColor = document.getElementById('wizardThemeBaseColor');
            const wizardBaseHex = document.getElementById('wizardThemeBaseHex');
            
            if (wizardBaseColor && wizardBaseHex) {
                const oldHexValue = wizardBaseHex.value;
                const newColorValue = wizardBaseColor.value.toUpperCase();
                
                wizardBaseHex.value = newColorValue;
                
                // 실시간 미리보기 업데이트 (성능 최적화)
                clearTimeout(window.colorUpdateTimeout);
                window.colorUpdateTimeout = setTimeout(() => {
                    optimizedPreviewUpdate(newColorValue);
                }, 30); // 30ms 디바운스로 더 빠른 반응
                
                // 추천 배경색도 동기화
                if (typeof updateRecommendedBackground === 'function') {
                    updateRecommendedBackground(newColorValue);
                }
                updateCustomBgHint();
                displayThemePreview(currentTheme);
                
            } else {
                console.error('❌ Elements not found in handleColorPickerChange');
            }
        }

        function handleHexInputChange() {
            const wizardBaseColor = document.getElementById('wizardThemeBaseColor');
            const wizardBaseHex = document.getElementById('wizardThemeBaseHex');
            
            if (wizardBaseColor && wizardBaseHex) {
                const hexValue = wizardBaseHex.value.toUpperCase();
                
                if (/^#[0-9A-F]{6}$/i.test(hexValue)) {
                    wizardBaseColor.value = hexValue;
                    
                    // 실시간 미리보기 업데이트 (성능 최적화)
                    clearTimeout(window.colorUpdateTimeout);
                    window.colorUpdateTimeout = setTimeout(() => {
                        optimizedPreviewUpdate(hexValue);
                    }, 80); // 타이핑 시에는 조금 더 긴 디바운스
                    
                    // 추천 배경색도 동기화
                    if (typeof updateRecommendedBackground === 'function') {
                        updateRecommendedBackground(hexValue);
                    }
                    updateCustomBgHint();
                    displayThemePreview(currentTheme);
                    
                } else if (hexValue.length >= 3) { // 최소 3자리 이상일 때만 경고
                    console.warn('⚠️ Invalid hex format:', hexValue);
                }
            } else {
                console.error('❌ Elements not found in handleHexInputChange');
            }
        }

        // 모드 설정 함수
        function setMode(mode) {
            currentMode = mode;
            
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            event.target.classList.add('active');
            updateDisplay();
        }

        // 디스플레이 업데이트
        function updateDisplay() {
            var baseColor = document.getElementById('baseColor');
            if (!baseColor) return;

            var inputHex = baseColor.value;
            var tuningVal = 0;
            
            console.log('updateDisplay called with:', inputHex);
            
            // Fine Tuning 값 가져오기
            if (document.getElementById('autoTuning').checked) {
                tuningVal = colorGenerator.getAutoTuningValue(inputHex);
                document.getElementById('tuningSlider').value = tuningVal;
                document.getElementById('tuningValue').textContent = tuningVal;
            } else {
                tuningVal = parseInt(document.getElementById('tuningSlider').value) || 0;
            }
            
            console.log('Generating colors with tuningVal:', tuningVal);
            
            // tuning 값을 포함하여 색상 생성
            try {
                generatedColors = colorGenerator.generateColors(inputHex, currentMode, tuningVal);
                console.log('Generated colors:', generatedColors);
            } catch (error) {
                console.error('Error generating colors:', error);
                return;
            }
            
            displayColors();
        }

        // 색상 표시
        function displayColors() {
            var container = document.getElementById('colorResults');
            console.log('displayColors called, container found:', !!container);
            console.log('generatedColors length:', generatedColors.length);
            
            if (!container) return;

            container.innerHTML = '';
            
            generatedColors.forEach(color => {
                console.log('Creating row for color:', color);
                var row = createColorRow(color);
                container.appendChild(row);
            });
        }

        // 색상 행 생성
        function createColorRow(color) {
            var row = document.createElement('div');
            row.className = color.isClosest ? 'color-row closest' : 'color-row';
            
            var rgb = ColorUtils.hexToRgb(color.hex);
            var textColor = ColorUtils.getLuminance(rgb.r, rgb.g, rgb.b) > 0.5 ? '#000' : '#fff';
            
            // 접근성 배지 추가
            var badge = '';
            if (color.contrast >= 7) {
                badge = '<span style="background: #28a745; color: white; padding: 1px 4px; border-radius: 2px; font-size: 7px; margin-left: 4px;">AAA</span>';
            } else if (color.contrast >= 4.5) {
                badge = '<span style="background: #ffc107; color: black; padding: 1px 4px; border-radius: 2px; font-size: 7px; margin-left: 4px;">AA</span>';
            } else if (color.contrast >= 3) {
                badge = '<span style="background: #fd7e14; color: white; padding: 1px 4px; border-radius: 2px; font-size: 7px; margin-left: 4px;">A</span>';
            }
            
            row.innerHTML = `
                <div class="color-swatch" style="background: ${color.hex}; color: ${textColor}">
                    ${color.step}${color.isClosest ? ' ★' : ''}
                </div>
                <div class="color-info">
                    <span class="color-hex" onclick="copyColor('${color.hex}')">${color.hex.toUpperCase()}</span>
                    <span>${color.contrast.toFixed(2)}:1 ${badge}</span>
                </div>
            `;
            
            return row;
        }

        // 스텝 분류 표시 업데이트 (Scale Generator용)
        function updateStepIndicator(hex) {
            var stepIndicator = document.getElementById('stepIndicator');
            var classificationBadge = document.getElementById('classificationBadge');
            var classificationInfo = document.getElementById('stepClassificationInfo');
            var classificationText = document.getElementById('stepClassificationText');
            
            if (!stepIndicator || !classificationBadge) return;
            
            // ColorGenerator에서 생성된 색상들과 일치시키기
            var colors = colorGenerator.generateColors(hex, 'light', 0);
            var closestColor = colors.find(color => color.isClosest);
            var closestStep = closestColor ? closestColor.step : 500;
            var colorRange = getColorRangeFromStep(closestStep, hex);
            
            stepIndicator.textContent = `Step: ${closestStep}`;
            
            if (colorRange === 'light') {
                stepIndicator.className = 'step-indicator step-light';
                classificationBadge.textContent = '밝음';
                classificationBadge.className = 'classification-badge classification-light';
                
                if (classificationInfo) classificationInfo.style.display = 'block';
                if (classificationText) classificationText.textContent = `입력 색상이 Step ${closestStep}에 해당합니다. 밝은 범위로 분류되어 Mode별로 다른 매핑이 적용됩니다.`;
            } else if (colorRange === 'medium') {
                stepIndicator.className = 'step-indicator step-medium';
                classificationBadge.textContent = '중간';
                classificationBadge.className = 'classification-badge classification-medium';
                
                if (classificationInfo) classificationInfo.style.display = 'block';
                if (classificationText) classificationText.textContent = `입력 색상이 Step ${closestStep}에 해당합니다. 중간 범위로 분류되어 Mode별로 다른 매핑이 적용됩니다.`;
            } else {
                stepIndicator.className = 'step-indicator step-dark';
                classificationBadge.textContent = '어두움';
                classificationBadge.className = 'classification-badge classification-dark';
                
                if (classificationInfo) classificationInfo.style.display = 'block';
                if (classificationText) classificationText.textContent = `입력 색상이 Step ${closestStep}에 해당합니다. 어두운 범위로 분류되어 Mode별로 다른 매핑이 적용됩니다.`;
            }
        }

        // 스텝 분류 표시 업데이트 (Custom Theme Wizard용)
        function updateWizardStepIndicator(hex) {
            var stepIndicator = document.getElementById('wizardStepIndicator');
            var classificationBadge = document.getElementById('wizardClassificationBadge');
            var classificationInfo = document.getElementById('wizardStepClassificationInfo');
            var classificationText = document.getElementById('wizardStepClassificationText');
            
            if (!stepIndicator || !classificationBadge) return;
            
            // ColorGenerator에서 생성된 색상들과 일치시키기
            var colors = colorGenerator.generateColors(hex, 'light', 0);
            var closestColor = colors.find(color => color.isClosest);
            var closestStep = closestColor ? closestColor.step : 500;
            var colorRange = getColorRangeFromStep(closestStep, hex);
            
            stepIndicator.textContent = `Step: ${closestStep}`;
            
            if (colorRange === 'light') {
                stepIndicator.className = 'step-indicator step-light';
                classificationBadge.textContent = '밝음';
                classificationBadge.className = 'classification-badge classification-light';
                
                if (classificationInfo) classificationInfo.style.display = 'block';
                if (classificationText) classificationText.textContent = `입력 색상이 Step ${closestStep}에 해당합니다. 밝은 범위로 분류되어 Mode별로 다른 매핑이 적용됩니다.`;
            } else if (colorRange === 'medium') {
                stepIndicator.className = 'step-indicator step-medium';
                classificationBadge.textContent = '중간';
                classificationBadge.className = 'classification-badge classification-medium';
                
                if (classificationInfo) classificationInfo.style.display = 'block';
                if (classificationText) classificationText.textContent = `입력 색상이 Step ${closestStep}에 해당합니다. 중간 범위로 분류되어 Mode별로 다른 매핑이 적용됩니다.`;
            } else {
                stepIndicator.className = 'step-indicator step-dark';
                classificationBadge.textContent = '어두움';
                classificationBadge.className = 'classification-badge classification-dark';
                
                if (classificationInfo) classificationInfo.style.display = 'block';
                if (classificationText) classificationText.textContent = `입력 색상이 Step ${closestStep}에 해당합니다. 어두운 범위로 분류되어 Mode별로 다른 매핑이 적용됩니다.`;
            }
        }

        function generateCustomTheme() {
            var baseColor = document.getElementById('themeBaseColor').value;
            var themeName = document.getElementById('themeNameInput').value || 'brand-theme';
            var applicationMode = document.querySelector('input[name="applicationMode"]:checked').value;
            
            // Fine Tuning 값 가져오기
            var tuningValue = document.getElementById('autoTuning').checked ? 
                colorGenerator.getAutoTuningValue(baseColor) :
                parseInt(document.getElementById('tuningSlider').value) || 0;
            
            
            // themeGenerator에 tuning 값 전달
            currentTheme = themeGenerator.generateTheme(baseColor, themeName, applicationMode, tuningValue);
            
            // 모드 카드 미리보기 업데이트
            updateModeCardPreviews();
            
            displayThemePreview(currentTheme);
            
            showMessage(`${themeName} 테마가 생성되었습니다!`);
        }

        function displayThemePreview(theme) {
            const container = document.getElementById('themePreviewContainer');
            const hint = document.getElementById('uiPreviewHint');
            if (!container) return;

            const baseColorInput = document.getElementById('wizardThemeBaseHex');
            const baseColor = (theme && theme.baseColor) || (baseColorInput ? baseColorInput.value : null) || '#3B82F6';

            const previewSelection = getPreviewSelection(theme);
            const tokens = buildUIPreviewTokens(baseColor, previewSelection, theme);

            const titleEl = container.querySelector('.ui-preview-card-header span:first-child');
            const badgeEl = container.querySelector('.ui-preview-badge');
            const primaryTextEl = container.querySelector('.ui-preview-primary-text');
            const secondaryTextEl = container.querySelector('.ui-preview-secondary-text');
            const actionBtn = container.querySelector('.ui-preview-btn.primary');
            const cancelBtn = container.querySelector('.ui-preview-btn.secondary');

            container.style.background = tokens.background;
            container.style.color = tokens.textPrimary;
            container.style.borderColor = convertToBorderColor(tokens.background);

            if (titleEl) {
                titleEl.textContent = 'UI Preview';
            }

            if (badgeEl) {
                badgeEl.style.backgroundColor = applyAlpha(tokens.fillPrimary, 0.18);
                badgeEl.style.color = tokens.fillPrimary;
            }

            const secondaryColor = applyAlpha(tokens.textPrimary, 0.65);

            if (primaryTextEl) {
                primaryTextEl.textContent = 'Primary text content';
                primaryTextEl.style.color = tokens.textPrimary;
            }

            if (secondaryTextEl) {
                secondaryTextEl.textContent = 'Secondary description text';
                secondaryTextEl.style.color = secondaryColor;
            }

            if (actionBtn) {
                actionBtn.style.backgroundColor = tokens.fillPrimary;
                actionBtn.style.color = getContrastTextColor(tokens.fillPrimary);
                actionBtn.style.boxShadow = '0 4px 10px rgba(15,23,42,0.18)';
            }

            if (cancelBtn) {
                cancelBtn.style.borderColor = applyAlpha(tokens.fillPrimary, 0.65);
                cancelBtn.style.color = tokens.fillPrimary;
                cancelBtn.style.backgroundColor = tokens.fillSurfaceContents;
            }

            if (hint) {
                hint.textContent = getModeDescription(previewSelection);
            }
        }

        function getPreviewSelection(theme) {
            const customBgPanel = document.getElementById('customBgPanel');
            const customBgHex = document.getElementById('customBgHex');
            if (customBgPanel && customBgPanel.classList.contains('expanded')) {
                const customColorRaw = customBgHex ? customBgHex.value.trim() : '';
                const customColor = /^#[0-9A-F]{6}$/i.test(customColorRaw) ? customColorRaw.toUpperCase() : null;
                return { mode: 'custom-background', customColor: customColor };
            }

            const selectedSwatch = document.querySelector('.bg-swatch.selected');
            if (selectedSwatch) {
                const modeAttr = selectedSwatch.dataset.mode || 'accent-on-bg-off';
                const stepAttr = selectedSwatch.dataset.step;
                const step = stepAttr ? parseInt(stepAttr, 10) : null;
                const backgroundColor = (step && theme) ? getColorHexForStep(step) : null;
                return { mode: modeAttr, step: step, backgroundColor: backgroundColor };
            }

            const fallbackMode = (theme && theme.applicationMode) ? theme.applicationMode : 'accent-on-bg-off';
            return { mode: fallbackMode };
        }

        function buildUIPreviewTokens(baseColor, selection, theme) {
            const mode = selection.mode || 'accent-on-bg-off';
            const baseMode = mode === 'custom-background' ? 'accent-on-bg-off' : mode;

            let tokens = calculatePreviewTokensForMode(baseColor, baseMode) || calculateBasicPreviewTokens(baseColor, baseMode);
            if (!tokens) {
                tokens = {
                    background: '#f5f6f8',
                    textPrimary: '#1f2937',
                    fillPrimary: baseColor,
                    fillSurfaceContents: '#ffffff'
                };
            }

            if (mode === 'custom-background') {
                const customColor = selection.customColor || (theme && theme.customBackgroundColor) || tokens.background;
                if (customColor) {
                    tokens.background = customColor;
                    tokens.textPrimary = getContrastTextColor(customColor);
                    const hsl = ColorUtils.hexToHsl ? ColorUtils.hexToHsl(customColor) : hexToHsl(customColor);
                    const offset = tokens.textPrimary === '#000000' ? -12 : 18;
                    const adjusted = Math.max(4, Math.min(hsl[2] + offset, 96));
                    tokens.fillSurfaceContents = adjustColorLightness(customColor, adjusted);
                }
            } else if (selection.backgroundColor) {
                const bg = selection.backgroundColor;
                tokens.background = bg;
                tokens.textPrimary = getContrastTextColor(bg);
                const hsl = ColorUtils.hexToHsl ? ColorUtils.hexToHsl(bg) : hexToHsl(bg);
                const offset = tokens.textPrimary === '#000000' ? -12 : 18;
                const adjusted = Math.max(4, Math.min(hsl[2] + offset, 96));
                tokens.fillSurfaceContents = adjustColorLightness(bg, adjusted);
            }

            tokens.fillPrimary = tokens.fillPrimary || baseColor;
            if (!tokens.fillSurfaceContents) {
                tokens.fillSurfaceContents = applyAlpha(tokens.textPrimary, 0.08);
            }
            tokens.textPrimary = tokens.textPrimary || '#1f2937';

            return tokens;
        }

        function getModeDescription(selection) {
            switch (selection.mode) {
                case 'accent-on-bg-fixed':
                    return '화이트 배경에 맞춘 미리보기를 표시하고 있어요.';
                case 'accent-on-bg-black':
                    return '다크 배경 모드 미리보기예요.';
                case 'custom-background':
                    return selection.customColor ? `커스텀 배경 (${selection.customColor}) 기준 미리보기예요.` : '커스텀 배경 미리보기예요.';
                default:
                    return '컬러 배경 모드 미리보기를 표시하고 있어요.';
            }
        }

        function convertToBorderColor(backgroundHex) {
            try {
                const hsl = ColorUtils.hexToHsl ? ColorUtils.hexToHsl(backgroundHex) : hexToHsl(backgroundHex);
                const lightness = hsl[2];
                const borderLightness = lightness > 50 ? lightness - 12 : lightness + 12;
                const adjusted = Math.max(6, Math.min(borderLightness, 88));
                return ColorUtils.hslToHex ? ColorUtils.hslToHex(hsl[0], Math.min(hsl[1], 25), adjusted) : backgroundHex;
            } catch (e) {
                return 'rgba(15,23,42,0.08)';
            }
        }

        function applyAlpha(color, alpha) {
            if (!color) return `rgba(15,23,42, ${Math.min(Math.max(alpha || 0.1, 0), 1)})`;
            if (color.startsWith('rgba') || color.startsWith('rgb')) {
                return color;
            }
            if (!/^#[0-9A-F]{6}$/i.test(color) || !ColorUtils.hexToRgb) {
                return color;
            }
            const rgb = ColorUtils.hexToRgb(color);
            const safeAlpha = Math.min(Math.max(alpha || 0.1, 0), 1);
            return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${safeAlpha})`;
        }

        function createCustomThemeVariables() {
            if (!currentTheme) {
                showMessage('먼저 테마를 생성해주세요!');
                return;
            }
            
            
            parent.postMessage({
                pluginMessage: {
                    type: 'create-custom-theme',
                    theme: currentTheme
                }
            }, '*');
            
            showMessage('Custom Theme Variables 생성 중...');
        }

        // Custom Mode 적용 함수
        function applyCustomMode(modeName) {
            
            if (!currentTheme) {
                showMessage('먼저 테마를 생성해주세요!');
                return;
            }
            
            parent.postMessage({
                pluginMessage: {
                    type: 'apply-theme-colors-to-frame',
                    theme: currentTheme
                }
            }, '*');
            
            showMessage('테마 토큰을 Frame에 적용 중...');
        }
        // 아코디언 토글 함수 추가
        function toggleThemePreview() {
        var header = document.getElementById('themePreviewAccordion');
        var content = document.getElementById('themePreviewContent');
        
        header.classList.toggle('active');
        content.classList.toggle('expanded');
        }
        // 색상 복사
        function copyColor(hex) {
            // 클릭된 요소 찾기
            var elements = document.querySelectorAll('.color-hex');
            elements.forEach(function(el) {
                if (el.textContent === hex.toUpperCase()) {
                    el.classList.add('copied');
                    setTimeout(function() {
                        el.classList.remove('copied');
                    }, 500);
                }
            });
            
            navigator.clipboard.writeText(hex).then(function() {
                showMessage(`📋 ${hex} 복사됨!`);
            }).catch(function() {
                showMessage('복사 실패');
            });
        }

        // 변수 생성 함수들
function createVariables() {
    var variableName = document.getElementById('variableName').value.trim();
    
    if (!variableName) {
        showMessage('변수 이름을 입력해주세요!');
        return;
    }
    
    if (generatedColors.length === 0) {
        showMessage('먼저 색상을 생성해주세요!');
        return;
    }

    // Fine Tuning 값 포함
    var tuningValue = document.getElementById('autoTuning').checked ? 
        colorGenerator.getAutoTuningValue(document.getElementById('baseColor').value) :
        parseInt(document.getElementById('tuningSlider').value) || 0;

    parent.postMessage({
        pluginMessage: {
            type: 'create-variables',
            colors: generatedColors,
            variableName: variableName,
            mode: currentMode,
            dualMode: false,
            tuningValue: tuningValue  // 추가
        }
    }, '*');
    
    showMessage('Variables 생성 중...');
}

function createDualModeVariables() {
    var variableName = document.getElementById('variableName').value.trim();
    
    if (!variableName) {
        showMessage('변수 이름을 입력해주세요!');
        return;
    }

    var baseColor = document.getElementById('baseColor').value;
    
    // Fine Tuning 값 포함
    var tuningValue = document.getElementById('autoTuning').checked ? 
        colorGenerator.getAutoTuningValue(baseColor) :
        parseInt(document.getElementById('tuningSlider').value) || 0;
    
    // Light 모드 색상 생성 (tuning 값 포함)
    var lightColors = colorGenerator.generateColors(baseColor, 'light', tuningValue);
    // Dark 모드 색상 생성 (tuning 값 포함)
    var darkColors = colorGenerator.generateColors(baseColor, 'dark', tuningValue);
    
    parent.postMessage({
        pluginMessage: {
            type: 'create-variables',
            lightColors: lightColors,
            darkColors: darkColors,
            variableName: variableName,
            dualMode: true,
            tuningValue: tuningValue  // 추가
        }
    }, '*');
    
    showMessage('Light + Dark Variables 생성 중...');
}

function createStyles() {
    var variableName = document.getElementById('variableName').value.trim() || 'color';
    
    if (generatedColors.length === 0) {
        showMessage('먼저 색상을 생성해주세요!');
        return;
    }

    parent.postMessage({
        pluginMessage: {
            type: 'create-styles',
            colors: generatedColors,
            styleName: variableName,
            mode: currentMode
        }
    }, '*');
    
    showMessage('Color Styles 생성 중...');
}

// 메시지 수신 처리 수정
window.addEventListener('message', (event) => {
    var msg = event.data.pluginMessage;
    if (!msg) return;

    
    switch(msg.type) {
        case 'plugin-ready':
            break;
        case 'variable-created':
            if (msg.success) {
                var modeText = msg.dualMode ? 'Light + Dark' : currentMode;
                showMessage(`✅ ${msg.count}개의 ${modeText} Variables 생성 완료!`);
            } else {
                showMessage('에러: ' + msg.error);
            }
            break;
        case 'style-created':
            if (msg.success) {
                showMessage(`✅ ${msg.count}개의 Color Styles 생성 완료!`);
            } else {
                showMessage('에러: ' + msg.error);
            }
            break;
        case 'custom-theme-created':
            if (msg.success) {
                showMessage(`${msg.themeName} 테마 생성 완료! (${msg.count || 0}개 변수)`);
            } else {
                showMessage('테마 생성 에러: ' + msg.error);
            }
            break;
        case 'custom-mode-applied':
            if (msg.success) {
                var message = msg.modeName + ' 모드 적용 완료!';
                if (msg.cleared && msg.cleared > 0) {
                    message += ' (' + msg.count + '개 적용, ' + msg.cleared + '개 자식 상속)';
                } else {
                    message += ' (' + msg.count + '개 적용)';
                }
                showMessage(message);
            } else {
                showMessage('모드 적용 에러: ' + msg.error);
            }
            break;
        case 'error':
            showMessage('에러: ' + msg.message);
            break;
    }
});

        // 톤 매칭 관련 함수들
        function setReferenceColor() {
            var picker = document.getElementById('referenceColorPicker');
            var hex = document.getElementById('referenceColorHex');
            setReferenceColorFromHex(picker.value);
            if (hex) {
                hex.value = picker.value.toUpperCase();
            }
        }

        function setReferenceColorFromHex(hexValue) {
            if (!hexValue || !/^#[0-9A-F]{6}$/i.test(hexValue)) return;
            var picker = document.getElementById('referenceColorPicker');
            var hexInput = document.getElementById('referenceColorHex');
            if (picker) picker.value = hexValue.toUpperCase();
            if (hexInput) hexInput.value = hexValue.toUpperCase();

            referenceColor = {
                hex: hexValue.toUpperCase(),
                hsl: ColorUtils.hexToHsl(hexValue)
            };

            addToneRecentColor(hexValue);
            updateReferenceDisplay();
            showMessage('기준 색상이 설정되었습니다!');
        }

        function clearReference() {
            referenceColor = null;
            updateReferenceDisplay();
            clearToneMatchingResults();
            showMessage('기준 색상이 초기화되었습니다.');
        }

        function updateReferenceDisplay() {
            var statusElement = document.getElementById('referenceStatus');
            var displayElement = document.getElementById('referenceDisplay');
            
            if (!referenceColor) {
                statusElement.textContent = '현재 설정된 기준 컬러가 없습니다.';
                statusElement.style.color = '#666';
                displayElement.innerHTML = '';
                return;
            }
            
            statusElement.textContent = '기준 색상이 설정되었어요';
            statusElement.style.color = '#18A0FB';
            
            displayElement.innerHTML = '';
        }

        function generateToneMatching() {
            if (!referenceColor) {
                showMessage('먼저 기준 색상을 설정해주세요!');
                return;
            }
            
            var newColorHex = document.getElementById('newColorPicker').value;
            
            // 백엔드에 톤 매칭 요청
            parent.postMessage({
                pluginMessage: {
                    type: 'generate-tone-matching',
                    referenceColor: referenceColor.hex,
                    inputColor: newColorHex
                }
            }, '*');
            
            showMessage('톤 매칭 제안을 생성하는 중...');
        }

        function displayToneMatchingSuggestions(originalHex, suggestions) {
            var container = document.getElementById('toneMatchingResults');
            
            container.innerHTML = `
                <div style="background: #18A0FB12; border-radius: 6px; padding: 12px; margin: 8px 0;">
                    <h4 style="color: #18A0FB; font-size: 11px;">톤 매칭 결과</h4>
                    <p style="margin-bottom: 8px; font-size: 9px;">
                        Original: <strong>${originalHex.toUpperCase()}</strong><br>
                        색상을 선택하면 팔레트가 생성돼요.
                    </p>
                    
                    <div class="tone-suggestions">
                        ${suggestions.map((suggestion, index) => `
                            <div class="tone-suggestion" onclick="applyToneToGenerator('${suggestion.hex}')">
                                <div class="tone-color-display" style="background: ${suggestion.hex};"></div>
                                <div class="tone-suggestion-title">${suggestion.type}</div>
                                <div class="tone-suggestion-hex">${suggestion.hex.toUpperCase()}</div>
                                <div class="tone-suggestion-desc">${suggestion.explanation}</div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        function applyToneToGenerator(hex) {
            switchTab('generator');
            document.getElementById('baseColor').value = hex;
            document.getElementById('hexInput').value = hex.toUpperCase();
            updateDisplay();
            showMessage(`${hex} 색상이 Generator에 적용되었습니다!`);
        }

        function clearToneMatchingResults() {
            var container = document.getElementById('toneMatchingResults');
            if (container) container.innerHTML = '';
        }

        // 메시지 표시
        function showMessage(message) {
            var el = document.getElementById('successMessage');
            if (el) {
                el.textContent = message;
                el.classList.add('show');
                setTimeout(() => el.classList.remove('show'), 3000);
            }
        }

        function finishEyedropperSession() {
            eyedropperState.active = false;
            eyedropperState.targetId = null;
        }

        function startEyedropperForPicker(picker) {
            if (!eyedropperSupported) return;
            if (!picker || !picker.id) return;
            if (eyedropperState.active) return;

            eyedropperState = { active: true, targetId: picker.id };

            if (typeof picker.blur === 'function') {
                picker.blur();
            }

            const currentValue = picker.value && /^#[0-9A-F]{6}$/i.test(picker.value)
                ? picker.value.toUpperCase()
                : null;

            parent.postMessage({
                pluginMessage: {
                    type: 'activate-eyedropper',
                    targetId: picker.id,
                    currentColor: currentValue
                }
            }, '*');

            showMessage(EYEDROPPER_PROMPT_MESSAGE);
        }

        function attachEyedropperToPicker(picker) {
            if (!picker || picker.dataset.eyedropperBound === 'true') return;

            const handlePointerDown = (event) => {
                if (event.button !== undefined && event.button !== 0) return;
                event.preventDefault();
                event.stopPropagation();
                if (!eyedropperState.active) {
                    startEyedropperForPicker(picker);
                }
            };

            const suppressClick = (event) => {
                event.preventDefault();
                event.stopPropagation();
            };

            const handleKeyDown = (event) => {
                if (event.key !== 'Enter' && event.key !== ' ') return;
                event.preventDefault();
                event.stopPropagation();
                if (!eyedropperState.active) {
                    startEyedropperForPicker(picker);
                }
            };

            picker.addEventListener('pointerdown', handlePointerDown);
            picker.addEventListener('click', suppressClick);
            picker.addEventListener('keydown', handleKeyDown);

            picker.dataset.eyedropperBound = 'true';
        }

        function setupEyedropperTriggers() {
            if (!eyedropperSupported) return;
            document.querySelectorAll('input.color-picker').forEach(attachEyedropperToPicker);
        }

        function applyEyedropperResult(targetId, hex, rgba) {
            finishEyedropperSession();

            if (!targetId || !hex) return;

            const picker = document.getElementById(targetId);
            if (!picker) {
                console.warn('Eyedropper target not found:', targetId);
                return;
            }

            const normalizedHex = hex.toUpperCase();
            picker.value = normalizedHex;

            picker.dispatchEvent(new Event('input', { bubbles: true }));
            picker.dispatchEvent(new Event('change', { bubbles: true }));

            showMessage(`스포이드 색상이 적용되었습니다: ${normalizedHex}`);
        }

        function handleEyedropperCancelled() {
            finishEyedropperSession();
            showMessage(EYEDROPPER_CANCEL_MESSAGE);
        }

        function handleEyedropperError(message) {
            finishEyedropperSession();
            console.error('Eyedropper error:', message);
            if (message && message.toLowerCase().includes('not supported')) {
                eyedropperSupported = false;
            }
            showMessage(message || '스포이드 사용 중 오류가 발생했습니다.');
        }

        // 이벤트 리스너 설정
        function setupEventListeners() {

            // 탭 버튼들
            const generatorTab = document.getElementById('generatorTab');
            const toneMatchingTab = document.getElementById('toneMatchingTab');
            const customThemeTab = document.getElementById('customThemeTab');
            
            if (generatorTab) {
                generatorTab.addEventListener('click', () => {
                    console.log('Generator tab clicked');
                    switchTab('generator');
                });
            } else {
                console.warn('generatorTab not found');
            }
            
            if (toneMatchingTab) {
                toneMatchingTab.addEventListener('click', () => {
                    console.log('Tone matching tab clicked');
                    switchTab('tone-matching');
                });
            } else {
                console.warn('toneMatchingTab not found');
            }
            
            if (customThemeTab) {
                customThemeTab.addEventListener('click', () => {
                    console.log('Custom theme tab clicked');
                    switchTab('custom-theme');
                });
            } else {
                console.warn('customThemeTab not found');
            }

            // 색상 입력
            var baseColor = document.getElementById('baseColor');
            var hexInput = document.getElementById('hexInput');

            if (baseColor && hexInput) {
                baseColor.addEventListener('input', () => {
                    hexInput.value = baseColor.value.toUpperCase();
                    updateDisplay();
                    updateStepIndicator(baseColor.value);
                    // 모드 미리보기도 업데이트
                    if (document.getElementById('wizardStep3').classList.contains('active')) {
                        updateAllModePreviewsWithColor(baseColor.value);
                    }
                });

                hexInput.addEventListener('input', () => {
                    if (/^#[0-9A-F]{6}$/i.test(hexInput.value)) {
                        baseColor.value = hexInput.value;
                        updateDisplay();
                        updateStepIndicator(hexInput.value);
                        // 모드 미리보기도 업데이트
                        if (document.getElementById('wizardStep3').classList.contains('active')) {
                            updateAllModePreviewsWithColor(hexInput.value);
                        }
                    }
                });
            }

            // Fine Tuning 이벤트 리스너
            var autoTuning = document.getElementById('autoTuning');
            var tuningSlider = document.getElementById('tuningSlider');
            var tuningValue = document.getElementById('tuningValue');
            var tuningStatus = document.getElementById('tuningStatus');

            if (autoTuning && tuningSlider && tuningValue && tuningStatus) {
                autoTuning.addEventListener('change', function() {
                if (this.checked) {
                    // Auto 모드
                    var baseColor = document.getElementById('baseColor').value;
                    var autoValue = colorGenerator.getAutoTuningValue(baseColor);
                    tuningSlider.value = autoValue;
                    tuningSlider.disabled = true;
                    tuningValue.textContent = autoValue;
                    tuningStatus.textContent = 'Auto: ' + autoValue;
                    tuningStatus.className = 'auto';
                } else {
                    // Manual 모드
                    tuningSlider.disabled = false;
                    tuningStatus.textContent = 'Manual: ' + tuningSlider.value;
                    tuningStatus.className = '';
                }
                updateDisplay();
            });

                tuningSlider.addEventListener('input', function() {
                    if (!autoTuning.checked) {
                        tuningValue.textContent = this.value;
                        tuningStatus.textContent = 'Manual: ' + this.value;
                        updateDisplay();
                    }
                });
            } else {
                console.warn('Fine Tuning elements not found');
            }

            // 톤 매칭 관련
            const setRefBtn = document.getElementById('setRefBtn');
            const clearRefBtn = document.getElementById('clearRefBtn');
            const getSuggestionsBtn = document.getElementById('getSuggestionsBtn');
            
            if (setRefBtn) {
                setRefBtn.addEventListener('click', setReferenceColor);
            } else {
                console.warn('setRefBtn not found');
            }
            
            if (clearRefBtn) {
                clearRefBtn.addEventListener('click', clearReference);
            } else {
                console.warn('clearRefBtn not found');
            }
            
            if (getSuggestionsBtn) {
                getSuggestionsBtn.addEventListener('click', generateToneMatching);
            } else {
                console.warn('getSuggestionsBtn not found');
            }

            // Reference 색상 입력 동기화
            var refPicker = document.getElementById('referenceColorPicker');
            var refHex = document.getElementById('referenceColorHex');
            
            if (refPicker && refHex) {
                refPicker.addEventListener('input', () => {
                    refHex.value = refPicker.value.toUpperCase();
                });
                
                refHex.addEventListener('input', () => {
                    if (/^#[0-9A-F]{6}$/i.test(refHex.value)) {
                        refPicker.value = refHex.value;
                    }
                });
            } else {
                console.warn('Reference color elements not found');
            }

            // New 색상 입력 동기화
            var newPicker = document.getElementById('newColorPicker');
            var newHex = document.getElementById('newColorHex');
            
            if (newPicker && newHex) {
                newPicker.addEventListener('input', () => {
                    newHex.value = newPicker.value.toUpperCase();
                });
                
                newHex.addEventListener('input', () => {
                    if (/^#[0-9A-F]{6}$/i.test(newHex.value)) {
                        newPicker.value = newHex.value;
                    }
                });
            } else {
                console.warn('New color elements not found');
            }

            // Custom Theme 관련 (구버전)
            var themeBaseColor = document.getElementById('themeBaseColor');
            var themeBaseHex = document.getElementById('themeBaseHex');
            
            if (themeBaseColor && themeBaseHex) {
                themeBaseColor.addEventListener('input', () => {
                    themeBaseHex.value = themeBaseColor.value.toUpperCase();
                    updateStepIndicator(themeBaseColor.value);
                });
                
                themeBaseHex.addEventListener('input', () => {
                    if (/^#[0-9A-F]{6}$/i.test(themeBaseHex.value)) {
                        themeBaseColor.value = themeBaseHex.value;
                        updateStepIndicator(themeBaseHex.value);
                    }
                });
            } else {
                console.warn('Custom Theme (old version) elements not found');
            }

            // Radio button 스타일 업데이트
            document.querySelectorAll('input[name="applicationMode"]').forEach(radio => {
                radio.addEventListener('change', (e) => {
                    document.querySelectorAll('.radio-option').forEach(option => {
                        option.classList.remove('selected');
                    });
                    e.target.parentElement.classList.add('selected');
                });
            });

            // Wizard 이벤트 리스너
            
            // Step 1 색상 입력 동기화
            setupWizardColorSync();

            // Step 2 배경 아코디언/스와치 제어
            const bgSwatches = document.querySelectorAll('.bg-swatch');
            const recommendedToggle = document.getElementById('recommendedBgToggle');
            const recommendedPanel = document.getElementById('recommendedBgPanel');
            const customBgToggle = document.getElementById('customBgToggle');
            const customBgPanel = document.getElementById('customBgPanel');
            const customBgColorContainer = document.getElementById('customBgColorContainer');
            const customBgColor = document.getElementById('customBgColor');
            const customBgHex = document.getElementById('customBgHex');
            const customBgCreateBtn = document.getElementById('customBgCreateBtn');

            const setAccordionState = (toggle, panel, expanded) => {
                if (!toggle || !panel) return;
                panel.classList.toggle('expanded', expanded);
                panel.style.display = expanded ? 'block' : 'none';
                toggle.classList.toggle('expanded', expanded);
                toggle.setAttribute('aria-expanded', expanded ? 'true' : 'false');
            };

            const openRecommendedAccordion = () => {
                setAccordionState(recommendedToggle, recommendedPanel, true);
                setAccordionState(customBgToggle, customBgPanel, false);
                if (customBgColorContainer) customBgColorContainer.style.display = 'none';
                customBackgroundTheme = null;
                if (!document.querySelector('.bg-swatch.selected')) {
                    const recDefault = document.getElementById('recommendedBgCard');
                    if (recDefault) recDefault.classList.add('selected');
                }
                updateCustomBgHint();
                displayThemePreview(currentTheme);
            };

            const openCustomAccordion = () => {
                setAccordionState(customBgToggle, customBgPanel, true);
                setAccordionState(recommendedToggle, recommendedPanel, false);
                bgSwatches.forEach(s => s.classList.remove('selected'));
                if (customBgColorContainer) customBgColorContainer.style.display = 'block';
                if (currentTheme) currentTheme.applicationMode = 'custom-background';
                if (wizardThemeData) wizardThemeData.applicationMode = 'custom-background';
                customBackgroundTheme = null;
                updateCustomBgHint();
                displayThemePreview(currentTheme);
            };

            setAccordionState(recommendedToggle, recommendedPanel, true);
            setAccordionState(customBgToggle, customBgPanel, false);
            if (customBgColorContainer) customBgColorContainer.style.display = 'none';
            openRecommendedAccordion();

            bgSwatches.forEach(swatch => {
                swatch.addEventListener('click', () => {
                    openRecommendedAccordion();
                    selectBackgroundOption(swatch);
                });
            });

            if (recommendedToggle) {
                recommendedToggle.addEventListener('click', () => {
                    const expanded = recommendedPanel.classList.contains('expanded');
                    if (expanded) {
                        setAccordionState(recommendedToggle, recommendedPanel, false);
                    } else {
                        openRecommendedAccordion();
                    }
                });
            }

            if (customBgToggle) {
                customBgToggle.addEventListener('click', () => {
                    const expanded = customBgPanel.classList.contains('expanded');
                    if (expanded) {
                        setAccordionState(customBgToggle, customBgPanel, false);
                        openRecommendedAccordion();
                    } else {
                        openCustomAccordion();
                    }
                });
            }

            // 커스텀 배경색 변경 이벤트
            if (customBgColor && customBgHex) {
                customBgColor.addEventListener('input', (e) => {
                    const color = e.target.value.toUpperCase();
                    customBgHex.value = color;
                    displayThemePreview(currentTheme);
                });

                customBgHex.addEventListener('input', (e) => {
                    const color = e.target.value.toUpperCase();
                    if (/^#[0-9A-F]{6}$/i.test(color)) {
                        customBgColor.value = color;
                        displayThemePreview(currentTheme);
                    }
                });
            }

            if (customBgCreateBtn) {
                customBgCreateBtn.addEventListener('click', createCustomBackgroundVariables);
            }

            // Mode 카드 클릭 이벤트
            document.querySelectorAll('.mode-card').forEach(card => {
                card.addEventListener('click', () => {
                    const mode = card.dataset.mode;
                    selectModeCard(card, mode);
                });
            });

            setupEyedropperTriggers();
            displayThemePreview(currentTheme);

            // 초기화 완료
        }

        // 플러그인 메시지 수신
        window.addEventListener('message', (event) => {
            var msg = event.data.pluginMessage;
            if (!msg) return;

                    
            switch(msg.type) {
                case 'plugin-ready':
                    eyedropperSupported = !!msg.eyedropperSupported;
                    if (eyedropperSupported) {
                        setupEyedropperTriggers();
                    }
                    break;
                case 'variable-created':
                    if (msg.success) {
                        showMessage(`Variables 생성 완료! (${msg.count || 0}개)`);
                        // 테마 데이터가 함께 온 경우 semanticColors 동기화
                        syncSemanticColorsFromMessage(msg);
                        if (currentTheme && currentTheme.baseColor) {
                            safeUpdateRecommendedBackground(currentTheme.baseColor);
                        }
                    } else {
                        showMessage('에러: ' + msg.error);
                    }
                    break;
                case 'custom-theme-created':
                    if (msg.success) {
                        showMessage(`${msg.themeName} 테마 생성 완료! (${msg.count || 0}개 변수)`);
                        // 백엔드가 theme/semanticColors를 반환하면 반영
                        syncSemanticColorsFromMessage(msg);
                        if (currentTheme && currentTheme.baseColor) {
                            safeUpdateRecommendedBackground(currentTheme.baseColor);
                        }
                    } else {
                        showMessage('테마 생성 에러: ' + msg.error);
                    }
                    break;
                case 'custom-mode-applied':
                    if (msg.success) {
                        var message = msg.modeName + ' 모드 적용 완료!';
                        if (msg.cleared && msg.cleared > 0) {
                            message += ' (' + msg.count + '개 적용, ' + msg.cleared + '개 자식 상속)';
                        } else {
                            message += ' (' + msg.count + '개 적용)';
                        }
                        showMessage(message);
                        // 적용 응답에도 theme 정보가 있을 수 있으므로 동기화
                        syncSemanticColorsFromMessage(msg);
                        if (currentTheme && currentTheme.baseColor) {
                            safeUpdateRecommendedBackground(currentTheme.baseColor);
                        }
                    } else {
                        showMessage('모드 적용 에러: ' + msg.error);
                    }
                    break;
                case 'eyedropper-picked':
                    applyEyedropperResult(msg.targetId, msg.hex, msg.rgba);
                    break;
                case 'eyedropper-cancelled':
                    handleEyedropperCancelled();
                    break;
                case 'eyedropper-error':
                    handleEyedropperError(msg.message);
                    break;
                case 'tone-matching-complete':
                    displayToneMatchingSuggestions(msg.originalColor, msg.suggestions);
                    showMessage('톤 매칭 제안이 완료되었습니다!');
                    break;
                case 'tone-matching-error':
                    showMessage('톤 매칭 에러: ' + msg.error);
                    break;
                case 'error':
                    showMessage('에러: ' + msg.message);
                    break;
            }
        });

        // 메시지에서 semanticColors 추출 후 currentTheme에 병합
        function syncSemanticColorsFromMessage(msg) {
            try {
                const themeFromMsg = msg?.theme || msg?.themeData || msg?.payload || null;
                const semantics = msg?.semanticColors || themeFromMsg?.semanticColors || null;
                if (!semantics) return;

                const targetName = themeFromMsg?.themeName || msg?.themeName || null;

                if (targetName && customBackgroundTheme && customBackgroundTheme.themeName === targetName) {
                    customBackgroundTheme.semanticColors = semantics;
                } else {
                    if (!currentTheme) currentTheme = {};
                    currentTheme.semanticColors = semantics;
                }
            } catch (e) {
                console.warn('semanticColors 동기화 실패:', e);
            }
        }

        // 안전 래퍼: 추천 배경 업데이트 실행 중 오류 방지
        function safeUpdateRecommendedBackground(color) {
            try { updateRecommendedBackground(color); } catch (e) { console.warn(e); }
        }

        // 초기화
        function init() {
            setupEventListeners();
            updateDisplay();
            
            // 초기 컬러 분류 표시
            const baseColor = document.getElementById('baseColor');
            if (baseColor) {
                updateStepIndicator(baseColor.value);
            }
            
            // Custom Theme 탭이 기본이므로 초기화 시에도 wizard 색상 동기화 설정
            setTimeout(() => {
                setupWizardColorSync();
                // 최근 컬러는 저장된 내역이 있으면 즉시 표시
                try {
                    renderRecentColors();
                    renderToneRecentColors();
                } catch {}
            }, 200);
            
        }
        
        // =====================================
        // Annotation 제어 함수들
        // =====================================
        
        function showMappingInfo() {
            // 현재 테마 정보와 함께 메시지 전송
            parent.postMessage({
                pluginMessage: {
                    type: 'annotation-control',
                    action: 'show-mapping',
                    theme: currentTheme // 현재 테마 정보 포함
                }
            }, '*');
        }
        
        // Mapping 정보 표시 상태 업데이트
        function updateMappingStatus(message, color = '#666') {
            const statusSpan = document.getElementById('mappingStatus');
            if (statusSpan) {
                statusSpan.textContent = message;
                statusSpan.style.color = color;
            }
        }

        // DOM 로드 완료 후 초기화
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }

        // 페이지 로드 완료 후에도 확인
        window.addEventListener('load', () => {
            if (generatedColors.length === 0) {
                updateDisplay();
            }
        });
    </script>
