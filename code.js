// Figma Plugin Backend Code - Version 14 (Improved)

// UI 표시
figma.showUI(__html__, { 
  width: 360, 
  height: 700,
  themeColors: true 
});

// =====================================
// Variable Library Integration Helpers
// =====================================

const LIBRARY_VARIABLE_KEYS = {
  "scale/green-950": "7ab71760888c4073de75f58421584343bccfd5ce",
  "scale/green-800": "d556fd27db19425e01362f56803fdff034bc7a71",
  "scale/green-700": "d434bfb54eb7e35475c9391caab030ffec76de3c",
  "scale/green-600": "1cbced49c6112ba110c76365d96324d1caa51fc7",
  "scale/green-400": "568c34bf4160a0f6b820616ebccf4b6ae3826f0d",
  "scale/green-300": "7142574a72a6faa0e4be1b0ea07b894bc9fb9e62",
  "scale/green-200": "bad92205686550471a1f124992bbcbcc2d4cd2ad",
  "scale/green-150": "68f2ead41ec4220ed8d9c4545af8cdbe4ab76a92",
  "scale/green-100": "9a8640f5fdbae880a28cfc0fa05fedb472fe3a61",
  "scale/green-75": "fda33d9b231719d06dc0c61c3508ac525fd203db",
  "scale/green-50": "7a1363377c5e96af1006a2b9158cc1bffd7531b2",
  "scale/deep-red-900": "37ad42c3f1a5716f8f6766e2cb6f90f7b7253e31",
  "scale/deep-red-950": "f9ebc90b576cd21af0fc41813064197c51bb2847",
  "scale/deep-red-400": "124cc19672a8e3cae56123dcb3a4a694631a2c40",
  "scale/deep-red-300": "1c89be5ba17a847202a06cffb00dff44629f81f9",
  "scale/deep-red-100": "16a5f5c40d0eb7f11b98ca68aed4375eb37d1b83",
  "scale/deep-red-75": "b42fcaf39c38c332d79facd06a44539b64c3d814",
  "scale/blue-950": "d58846ac8d1ea8f6d035ec7b88a1b64db72d41a9",
  "scale/blue-900": "4674d328923ccad899999c1cbf390429c0f10506",
  "scale/blue-800": "f854f31decc033d83db4322c9a88a6ce0f7aca5e",
  "scale/blue-700": "7c51963514e643d7f1c58c6821bd3df2b3d12bc0",
  "scale/blue-500": "afb4fc7b06c7d6c2e4dd926d29f9163fe0d21a5e",
  "scale/blue-150": "d119b232e0bd5aba8b00fd62acc84a08bcc5e650",
  "scale/blue-100": "6a8fb8023162d0e20ef967819992c04fd897dab5",
  "scale/orange-red-950": "95948bff741cdd82186815a0c00b79a858b390b9",
  "scale/orange-red-900": "c74f59eadec372b751cc1a33b1aa26070bf431b6",
  "scale/deep-red-600": "c59b70e3e470218cac8ee37417889bcb48dd674d",
  "scale/orange-red-800": "b500a25e268455dd2c084ac7438e997e0ef86112",
  "scale/orange-red-700": "685e821a8469cc751bccdacdf2a23742620b9b40",
  "scale/orange-red-500": "eabaa5e7efe7d7deac874eaa46efdb9b1dfd6028",
  "scale/orange-red-400": "1ae746e891aa09035abb9c28d26639a7e18cdd0a",
  "scale/orange-red-300": "ff25888d7c48177f5c6f38a8a018ca30527c9f1c",
  "scale/green-500": "4f0c2da9d1d817fe879bb80eb50eee17c17dddca",
  "static/static-black-alpha-400": "db848a1d645cdb86c0597038eac05921d886aa30",
  "semantic/fill/silent-pressed": "28152aa10d94bb0dca4bf91f5110ee4787a1781d",
  "scale/orange-red-200": "ab77c84aa88690a7b0f488e6be87c3da928ba392",
  "scale/orange-red-150": "f1a435853ea849454652bdbcb0ef938c99781671",
  "scale/gray-800": "c131a09e66624aaccc04b7d9d2029385c6a5390f",
  "semantic/fill/primary-hover": "2475039539b8e1a65a85990899e9b48249760b8c",
  "scale/gray-alpha-900": "152c5501f3ed5ab3463bd551ddfa1c527b013acf",
  "semantic/border/line-selected": "0de74c1cc6b023891bced75bece50ea1c02b3659",
  "semantic/common/infomative-pressed": "8615d794911d94e571257d02e679df59cf400b7f",
  "semantic/common/infomative": "731a855a1a33d09be6fdb03f615401b0cc8a725d",
  "semantic/common/on-white-hover": "7b801c418d6fc5eadbc459a3b1cc5a1639513a88",
  "semantic/common/accent-hover": "afa820e7c42c034a09b6c38df70787b1c5865e14",
  "semantic/common/muted": "e67dd08ded2a322349010610c4f66dabddda5978",
  "scale/deep-red-800": "3675392d5da3fdc3edaecb5e2bee78993cca9e1a",
  "semantic/common/on-black-hover": "e36a6a32dce45492422687b1726f8034f5017ed8",
  "semantic/common/on-white-pressed": "7a554cc313f367756e6e14aa54f059fdcf8f82cb",
  "semantic/common/on-white": "9636e4985a7d04a0b1c445e51646e36344f51b5d",
  "scale/gray-700": "175af266912b1cb1dba502e1ca36fa1134e236c1",
  "semantic/common/custom-accent-low": "76018f4402226a09d9de6fff4ad9aec61493f35c",
  "semantic/text/secondary": "9ccb81268d0fd7d8b403486ca74f919b029e7bdc",
  "semantic/overlay/dimmed": "ccabff77e202ede42c4eb03e84387644659b2451",
  "semantic/fill/surface-black": "07248de87d3007b0492c3d13ee8e1c442dbeae16",
  "scale/gray-50": "5ce327eb97b32e183817140e034fd3c20289495c",
  "semantic/fill/surface-sheet": "173f18fadec001ba9284943f2a9a287962dcbda5",
  "semantic/text/on-color": "956ba5b0bb0c68fed4bcb7a2f57e961f5e42cfb3",
  "scale/gray-alpha-100": "ae728cdd03670e62c028243b8bcc8071b72b2a6f",
  "scale/orange-red-75": "a3f0191ada942c9970119ccb67f0428966d7460b",
  "semantic/common/accent-low": "30ae9a002b3deff7a4ba4dc01a1df1ef84a3ad9d",
  "static/static-white-alpha-100": "dec0f162c74ef8af59700572a3ff9678a27a5b60",
  "semantic/text/disabled": "78570344f1391a6e9c4798d54724811cca9a7f33",
  "semantic/fill/silent": "5263899d14009d36b16ef0b5ca861db1ef98ecbc",
  "semantic/text/tertiary": "ca60101acc0e78abcb5169c5994c8866f6622019",
  "scale/blue-400": "dfc2fe412e4b12d7e7afb298c4947f9ffb6a2567",
  "semantic/common/accent": "49bcbf4490dc05213d9d2da23143eec131d22869",
  "scale/deep-red-150": "b334e72b75acfba5319c620f27fdfceccc67b9c6",
  "semantic/fill/tertiary-pressed": "28d18087920536e2567724c594368c3ed7a62e42",
  "semantic/common/custom-accent": "8eed7de9b75b7559721dfaba9889c827350b7c87",
  "semantic/fill/tertiary-hover": "9b6f415ff944043f6b924a44e6950f75853ce890",
  "semantic/fill/surface-floating": "e5534cb073118d98c86817f2001c5d3d321bbfd5",
  "semantic/fill/tertiary": "337c50a176a7f07e0bed7fab135a6c23219330cf",
  "semantic/fill/primary-pressed": "3500b317c3014e7b220efc677e6610f18fd3872a",
  "semantic/fill/surface-contents": "772021e2c4d4fa18618ee8c4e1daa39adb25a73a",
  "scale/green-900": "b53ea738f416c090fd530eca1be4b94f8324dd38",
  "semantic/background/default": "58a162cf884242ba8d318f8e9b2dd794fd465e97",
  "semantic/fill/disabled": "c07836d193b1a3b90ef9deeecd20561be33eaf53",
  "scale/gray-alpha-800": "deb4dc5560e3fed1df0da53f926126aea830675d",
  "semantic/background/gradient-default": "c456ab919977db45e6ed2f177fa21a2a8d5a4e57",
  "semantic/border/line-disabled": "79e494d51d9f459ee3356aba560429c716ccac76",
  "semantic/border/line": "7dfb9824068070b60942a396a2df510c6f36947e",
  "semantic/border/divider-strong": "efce4e3ddf28aae9b8c99b6d187f5d1e178f454d",
  "static/static-black-alpha-300": "16bc3b42b67fd2d06c98a656bfb7f63a3de87a6f",
  "static/static-black-alpha-800": "93c7947df2eaa1918e95dcb94d5fea4df5416d45",
  "scale/orange-red-50": "2f08411a948f4095f4a8e8482655e7f5fa8e3e35",
  "semantic/shadow/default": "33abb30ce969dbcdecf2bc53d5b6ef45bacb6a74",
  "static/static-black-alpha-900": "ef81290eff974dfe714361dbd01b3d3a1fb485a5",
  "scale/blue-600": "c32e56be80e0ced00021de6c6d9ed2ab0167ff1a",
  "semantic/common/on-black-pressed": "a94667a288abf10c5efe10832e3344c59393fd14",
  "semantic/common/accent-pressed": "c70e2860b72320d6dc139ce57151c7fb27727ba3",
  "scale/gray-alpha-300": "103358e698697d154551b17ad27b43f70421a57a",
  "scale/blue-300": "743d677d4d62e04acf6661c59ac08435621bc2cb",
  "static/static-white-alpha-00": "43fa1f7ed59ecaf4e1f07bbf18504a757ef5136a",
  "static/static-black-alpha-700": "9b6e3d7f11934026e05449124d0ced0b6e2789c5",
  "semantic/background/low": "b5c219820f0057b3d2a8d8e694c549e6bd651143",
  "scale/gray-alpha-400": "fea35d0b2f9f6ae67559823802d6e90d274e98d6",
  "static/static-black-alpha-600": "f3f84c6b6b68e386ed4675c12b3d25bac2179dcf",
  "scale/deep-red-200": "b16fdc9394362777a0565279c7410d343041a7ee",
  "static/static-black-alpha-200": "88db4a9525d13b59cebff8e114d21f51543eab0b",
  "semantic/common/on-black": "be607aebcf62263e1dea8a47f0f5822713e3a4ed",
  "static/static-white-alpha-200": "89e21d420fc7c59edeedbb90c07d4743301c19b4",
  "scale/gray-alpha-700": "ff20a3e3998d3eee4195a293c0ac99a16aa040ad",
  "semantic/text/primary": "11c33d1aef66d76b60a1758aa687f863205e4f56",
  "static/static-black-alpha-500": "41a25db0ce7393e2444989c3a9555a3b8e668fc7",
  "static/static-black-alpha-00": "69be0c583fabb6d19bc20ade09fc34676f001a25",
  "static/static-white-alpha-900": "a9cff4f2023f552e6bdcaed3ae05632c44c92c12",
  "scale/deep-red-700": "232300719c8701c2caca3f028891aa0a68e3df20",
  "semantic/fill/silent-hover": "c5d0e2f565bc73fd34181983d7696a84c9c651b9",
  "static/static-white-alpha-700": "61687f65fe9c27e4421dbcb4c4d7804c2fa2636d",
  "semantic/fill/primary": "219013673b2774d6d1158e1132da0c15e55ac2a6",
  "static/static-white-alpha-500": "7b7ae69402b2c18c4bc3b71c5939c963d224171c",
  "scale/orange-red-100": "5ffe513ff1493e1482844359eb8ac10c45008f48",
  "static/static-white-alpha-400": "310fdc006d94fba2c2b6803010bba35f4ca0df45",
  "scale/deep-red-500": "803bd071391e781f1c732675aec437b6731d1379",
  "static/static-black-alpha-100": "0803f3c808f7ec0d08c2a8bed693bab1b3765384",
  "static/static-white-alpha-300": "826395a4bd607a495566784b441f24d0ab94637d",
  "scale/gray-400": "f017645f6bb539fdd2aed7ba8b77d7a63ac8c8d8",
  "scale/gray-alpha-150": "ffc0873abc1caf1231381837f02f2a72db9763cb",
  "semantic/common/infomative-hover": "09890846ab77a045532b7734244617fca7e5f2a4",
  "static/static-white-alpha-600": "e7650c183627da387a92b3e854042ca68760b1cc",
  "semantic/fill/surface-dialog": "1d482dec34d50794f20b8443f607b76f65e25861",
  "scale/blue-75": "731e50147ff726e6be82e578b3474eb6c7550eaa",
  "scale/gray-alpha-200": "4aaf4be7a78a66e0ec8352d3c8f1b8ed3159f705",
  "scale/gray-200": "86e59b6b1f185f8c0b4fc921c2122ef4daeaecf8",
  "scale/gray-alpha-000": "8f9f0cdf425dcb182e8b39d07b3a4d09a505a752",
  "semantic/common/infomative-low": "46716693fcc162c655e08b0a196d3b6408510220",
  "semantic/border/divider": "c8ad773379102728ad1c479335c145f3708a16b8",
  "scale/gray-alpha-600": "9ae4dbfd580826800039c73d50bb4546a9a12fff",
  "scale/gray-950": "8d610a691f99418da7c0efc4c79363bb5e57157f",
  "scale/blue-50": "b168d4b170ab4e6e496deda8f6aacc0124d8417d",
  "scale/gray-150": "72605eca79df91dccdd95fb9bc8c42822ee5693a",
  "scale/gray-900": "0890ac1441baa4c7c8c9b3433318c42ec63346f9",
  "scale/gray-75": "0c2bd4d96a7526cc5f85457e250c576d2d3fb708",
  "semantic/background/black": "846cf4f9e8eb33b2f7988a93e43c15ed8e5e3d5c",
  "scale/deep-red-50": "4ee48e594121dc4095f5ed5c63d2bf6da077f641",
  "scale/blue-200": "883a63d53813a75cc0016637bb3bad4c575cd6d5",
  "scale/gray-100": "23b4a49c1545fdde0c8246a1ba1c798fcfbe874a",
  "static/static-white-alpha-800": "064054746aa22947453aa8aedb72968156ecd5aa",
  "scale/gray-600": "86f8b758a120f8d6e003f4e9adf56bbdc05a73b1",
  "scale/gray-alpha-500": "32b780e3a61bcee1bd7114f5eeb8140cf33d6201",
  "scale/gray-500": "9537894dbc984bfdbd60ac36f0d9e4509c17e759",
  "scale/orange-red-600": "78b81f0dbb341d74eaee09768c9db73b78e280ab",
  "scale/gray-300": "24452e904857037618aa3cf8fd979abc68a8fb21",
  "semantic/background/gradient-black": "3980b4283655f7f1f609c498152f8390205026d2",
  "scale/custom-theme-50": "d5adddb0c74342b0ba1fc75b6266d9cab521e235",
  "scale/custom-theme-75": "d6789d41251d5b89cd5a312884e193ff9ae7c024",
  "scale/custom-theme-100": "671d9c59e91a420c2c91b9b4618fc07c12e27e32",
  "scale/custom-theme-150": "c83b716031fb4d6c29303c8c5aaf74d5ea052c5e",
  "scale/custom-theme-200": "67e243c8187f92d43db3d3c6435280ef98c7c377",
  "scale/custom-theme-300": "b79bbacbe306f6cd630162d6acf50368d4476074",
  "scale/custom-theme-400": "37f3cf71bfd96b33fade0d011b6c623f5305b36f",
  "scale/custom-theme-500": "94f6a72e28c348236a15a495710d6bd8ac2a6a41",
  "scale/custom-theme-600": "64584960dff21d161adca852399337147120e842",
  "scale/custom-theme-700": "9215f30975987dd071c4a385d8466d27fe98eb5f",
  "scale/custom-theme-800": "f51ca78f0c13c2f97451845d9f558ea05ee6c17b",
  "scale/custom-theme-900": "4842cfe94c4fdf5f8c38df7ce978e8fab00c7ac1",
  "scale/custom-theme-950": "851b2e0998c27543354a06613d0a67faad9c3cfd",
  "scale/custom-theme-alpha-00": "1e0961d255fd37d8fc5264235e26bb3573d1a7a7",
  "scale/custom-theme-alpha-75": "5c030d17b1c543a12c92f36c33bf4afca865979d",
  "scale/custom-theme-alpha-100": "b5ec7622281d168a39223649e4c29025518efa7c",
  "scale/custom-theme-alpha-150": "3e1958ecf31af92ee5c0fbd9c6d4eaba186a4ed2",
  "scale/custom-theme-alpha-200": "0c35456e106dac3469f208ab1bcdf377d5bcdbd5",
  "scale/custom-theme-alpha-300": "e448d5b23e36dbac2551592baae322780013a89c",
  "scale/custom-theme-alpha-400": "b47cbecc930329b556c7e1d660298d147b9eb821",
  "scale/custom-theme-alpha-500": "e441287397c649a915d72214c6b0e94ba770a76c",
  "scale/custom-theme-alpha-600": "5c1eadc972d4ac44063987d6ecde2e7ece7c9d84",
  "scale/custom-theme-alpha-700": "3e8a69dcc3511b25a98a6ceccbce9d483ab64a25",
  "scale/custom-theme-alpha-800": "b59a3ad8c31f10bfbf497ac3575619d6bcee1626",
  "scale/custom-theme-alpha-900": "0352b9b5845551ea351b96fb3029f67244201e68",
  "scale/custom-theme-alpha-950": "ec9c2345db8387034a6ad03cd0cd562ca2506591"
};

const libraryCollectionModeCache = new Map();

const RULER_V2_LOCAL_DATA_BASE64 = 'W3sibmFtZSI6InNjYWxlL2dyYXktNTAiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsidmFsdWUiOiIjZmZmZmZmIn0sIkRhcmsiOnsidmFsdWUiOiIjMGMwYzBjIn19fSx7Im5hbWUiOiJzY2FsZS9ncmF5LTc1IiwidHlwZSI6ImNvbG9yIiwidmFsdWVzIjp7IkxpZ2h0Ijp7InZhbHVlIjoiI2Y3ZjdmNyJ9LCJEYXJrIjp7InZhbHVlIjoiIzE0MTQxNCJ9fX0seyJuYW1lIjoic2NhbGUvZ3JheS0xMDAiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsidmFsdWUiOiIjZjBmMGYwIn0sIkRhcmsiOnsidmFsdWUiOiIjMWMxYzFjIn19fSx7Im5hbWUiOiJzY2FsZS9ncmF5LTE1MCIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJ2YWx1ZSI6IiNlOGU4ZTgifSwiRGFyayI6eyJ2YWx1ZSI6IiMyNDI0MjQifX19LHsibmFtZSI6InNjYWxlL2dyYXktMjAwIiwidHlwZSI6ImNvbG9yIiwidmFsdWVzIjp7IkxpZ2h0Ijp7InZhbHVlIjoiI2RkZGRkZCJ9LCJEYXJrIjp7InZhbHVlIjoiIzMxMzEzMSJ9fX0seyJuYW1lIjoic2NhbGUvZ3JheS0zMDAiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsidmFsdWUiOiIjY2NjY2NjIn0sIkRhcmsiOnsidmFsdWUiOiIjNDE0MTQxIn19fSx7Im5hbWUiOiJzY2FsZS9ncmF5LTQwMCIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJ2YWx1ZSI6IiNiNGI0YjQifSwiRGFyayI6eyJ2YWx1ZSI6IiM1MjUyNTIifX19LHsibmFtZSI6InNjYWxlL2dyYXktNTAwIiwidHlwZSI6ImNvbG9yIiwidmFsdWVzIjp7IkxpZ2h0Ijp7InZhbHVlIjoiIzllOWU5ZSJ9LCJEYXJrIjp7InZhbHVlIjoiIzYyNjI2MiJ9fX0seyJuYW1lIjoic2NhbGUvZ3JheS02MDAiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsidmFsdWUiOiIjOGE4YThhIn0sIkRhcmsiOnsidmFsdWUiOiIjODA4MDgwIn19fSx7Im5hbWUiOiJzY2FsZS9ncmF5LTcwMCIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJ2YWx1ZSI6IiM2YTZhNmEifSwiRGFyayI6eyJ2YWx1ZSI6IiNhZGFkYWQifX19LHsibmFtZSI6InNjYWxlL2dyYXktODAwIiwidHlwZSI6ImNvbG9yIiwidmFsdWVzIjp7IkxpZ2h0Ijp7InZhbHVlIjoiIzQ2NDY0NiJ9LCJEYXJrIjp7InZhbHVlIjoiI2UzZTNlMyJ9fX0seyJuYW1lIjoic2NhbGUvZ3JheS05MDAiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsidmFsdWUiOiIjMWYxZjFmIn0sIkRhcmsiOnsidmFsdWUiOiIjZjRmNGY0In19fSx7Im5hbWUiOiJzY2FsZS9ncmF5LTk1MCIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJ2YWx1ZSI6IiMwMDAwMDAifSwiRGFyayI6eyJ2YWx1ZSI6IiNmY2ZjZmMifX19LHsibmFtZSI6InNjYWxlL2dyYXktYWxwaGEtMDAwIiwidHlwZSI6ImNvbG9yIiwidmFsdWVzIjp7IkxpZ2h0Ijp7InZhbHVlIjoicmdiYSgwLCAwLCAwLCAwKSJ9LCJEYXJrIjp7InZhbHVlIjoicmdiYSgyNTUsIDI1NSwgMjU1LCAwKSJ9fX0seyJuYW1lIjoic2NhbGUvZ3JheS1hbHBoYS0xMDAiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsidmFsdWUiOiJyZ2JhKDAsIDAsIDAsIDAuMDYpIn0sIkRhcmsiOnsidmFsdWUiOiJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMTEpIn19fSx7Im5hbWUiOiJzY2FsZS9ncmF5LWFscGhhLTE1MCIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJ2YWx1ZSI6InJnYmEoMCwgMCwgMCwgMC4wOSkifSwiRGFyayI6eyJ2YWx1ZSI6InJnYmEoMjU1LCAyNTUsIDI1NSwgMC4xNCkifX19LHsibmFtZSI6InNjYWxlL2dyYXktYWxwaGEtMjAwIiwidHlwZSI6ImNvbG9yIiwidmFsdWVzIjp7IkxpZ2h0Ijp7InZhbHVlIjoicmdiYSgwLCAwLCAwLCAwLjEzKSJ9LCJEYXJrIjp7InZhbHVlIjoicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjE5KSJ9fX0seyJuYW1lIjoic2NhbGUvZ3JheS1hbHBoYS0zMDAiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsidmFsdWUiOiJyZ2JhKDAsIDAsIDAsIDAuMikifSwiRGFyayI6eyJ2YWx1ZSI6InJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yNSkifX19LHsibmFtZSI6InNjYWxlL2dyYXktYWxwaGEtNDAwIiwidHlwZSI6ImNvbG9yIiwidmFsdWVzIjp7IkxpZ2h0Ijp7InZhbHVlIjoicmdiYSgwLCAwLCAwLCAwLjI5KSJ9LCJEYXJrIjp7InZhbHVlIjoicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjMyKSJ9fX0seyJuYW1lIjoic2NhbGUvZ3JheS1hbHBoYS01MDAiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsidmFsdWUiOiJyZ2JhKDAsIDAsIDAsIDAuMzgpIn0sIkRhcmsiOnsidmFsdWUiOiJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMzgpIn19fSx7Im5hbWUiOiJzY2FsZS9ncmF5LWFscGhhLTYwMCIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJ2YWx1ZSI6InJnYmEoMCwgMCwgMCwgMC40NikifSwiRGFyayI6eyJ2YWx1ZSI6InJnYmEoMjU1LCAyNTUsIDI1NSwgMC41KSJ9fX0seyJuYW1lIjoic2NhbGUvZ3JheS1hbHBoYS03MDAiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsidmFsdWUiOiJyZ2JhKDAsIDAsIDAsIDAuNTgpIn0sIkRhcmsiOnsidmFsdWUiOiJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNjgpIn19fSx7Im5hbWUiOiJzY2FsZS9ncmF5LWFscGhhLTgwMCIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJ2YWx1ZSI6InJnYmEoMCwgMCwgMCwgMC43MykifSwiRGFyayI6eyJ2YWx1ZSI6InJnYmEoMjU1LCAyNTUsIDI1NSwgMC44OSkifX19LHsibmFtZSI6InNjYWxlL2dyYXktYWxwaGEtOTAwIiwidHlwZSI6ImNvbG9yIiwidmFsdWVzIjp7IkxpZ2h0Ijp7InZhbHVlIjoicmdiYSgwLCAwLCAwLCAwLjg4KSJ9LCJEYXJrIjp7InZhbHVlIjoicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjk2KSJ9fX0seyJuYW1lIjoic2NhbGUvb3JhbmdlLXJlZC01MCIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJ2YWx1ZSI6IiNmY2VlZTgifSwiRGFyayI6eyJ2YWx1ZSI6IiMyNDBkMDQifX19LHsibmFtZSI6InNjYWxlL29yYW5nZS1yZWQtNzUiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsidmFsdWUiOiIjZmZkYWNjIn0sIkRhcmsiOnsidmFsdWUiOiIjM2QxMTAwIn19fSx7Im5hbWUiOiJzY2FsZS9vcmFuZ2UtcmVkLTEwMCIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJ2YWx1ZSI6IiNmZmM4YjMifSwiRGFyayI6eyJ2YWx1ZSI6IiM1YzFhMDAifX19LHsibmFtZSI6InNjYWxlL29yYW5nZS1yZWQtMTUwIiwidHlwZSI6ImNvbG9yIiwidmFsdWVzIjp7IkxpZ2h0Ijp7InZhbHVlIjoiI2ZmYWU4ZiJ9LCJEYXJrIjp7InZhbHVlIjoiIzgwMjQwMCJ9fX0seyJuYW1lIjoic2NhbGUvb3JhbmdlLXJlZC0yMDAiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsidmFsdWUiOiIjZmY5MTY2In0sIkRhcmsiOnsidmFsdWUiOiIjYTMyZTAwIn19fSx7Im5hbWUiOiJzY2FsZS9vcmFuZ2UtcmVkLTMwMCIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJ2YWx1ZSI6IiNmZjZkMzMifSwiRGFyayI6eyJ2YWx1ZSI6IiNjYzNhMDAifX19LHsibmFtZSI6InNjYWxlL29yYW5nZS1yZWQtNDAwIiwidHlwZSI6ImNvbG9yIiwidmFsdWVzIjp7IkxpZ2h0Ijp7InZhbHVlIjoiI2ZiNGEwNCJ9LCJEYXJrIjp7InZhbHVlIjoiI2ZiNGEwNCJ9fX0seyJuYW1lIjoic2NhbGUvb3JhbmdlLXJlZC01MDAiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsidmFsdWUiOiIjY2MzYTAwIn0sIkRhcmsiOnsidmFsdWUiOiIjZmY2ZDMzIn19fSx7Im5hbWUiOiJzY2FsZS9vcmFuZ2UtcmVkLTYwMCIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJ2YWx1ZSI6IiNhMzJlMDAifSwiRGFyayI6eyJ2YWx1ZSI6IiNmZjhhNWMifX19LHsibmFtZSI6InNjYWxlL29yYW5nZS1yZWQtNzAwIiwidHlwZSI6ImNvbG9yIiwidmFsdWVzIjp7IkxpZ2h0Ijp7InZhbHVlIjoiIzgwMjQwMCJ9LCJEYXJrIjp7InZhbHVlIjoiI2ZmYTM4MCJ9fX0seyJuYW1lIjoic2NhbGUvb3JhbmdlLXJlZC04MDAiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsidmFsdWUiOiIjNWMxYTAwIn0sIkRhcmsiOnsidmFsdWUiOiIjZmZiZGEzIn19fSx7Im5hbWUiOiJzY2FsZS9vcmFuZ2UtcmVkLTkwMCIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJ2YWx1ZSI6IiMzZDExMDAifSwiRGFyayI6eyJ2YWx1ZSI6IiNmZmQzYzIifX19LHsibmFtZSI6InNjYWxlL29yYW5nZS1yZWQtOTUwIiwidHlwZSI6ImNvbG9yIiwidmFsdWVzIjp7IkxpZ2h0Ijp7InZhbHVlIjoiIzI5MGMwMCJ9LCJEYXJrIjp7InZhbHVlIjoiI2ZmZWRlNSJ9fX0seyJuYW1lIjoic2NhbGUvYmx1ZS01MCIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJ2YWx1ZSI6IiNlN2VmZmQifSwiRGFyayI6eyJ2YWx1ZSI6IiMwMjBhMTgifX19LHsibmFtZSI6InNjYWxlL2JsdWUtNzUiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsidmFsdWUiOiIjZGJlOGZkIn0sIkRhcmsiOnsidmFsdWUiOiIjMDIwZjI0In19fSx7Im5hbWUiOiJzY2FsZS9ibHVlLTEwMCIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJ2YWx1ZSI6IiNjZmUwZmMifSwiRGFyayI6eyJ2YWx1ZSI6IiMwMzE0MzAifX19LHsibmFtZSI6InNjYWxlL2JsdWUtMTUwIiwidHlwZSI6ImNvbG9yIiwidmFsdWVzIjp7IkxpZ2h0Ijp7InZhbHVlIjoiI2I3ZDBmYSJ9LCJEYXJrIjp7InZhbHVlIjoiIzA1MWU0OCJ9fX0seyJuYW1lIjoic2NhbGUvYmx1ZS0yMDAiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsidmFsdWUiOiIjOWZjMWY5In0sIkRhcmsiOnsidmFsdWUiOiIjMDYyODYwIn19fSx7Im5hbWUiOiJzY2FsZS9ibHVlLTMwMCIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJ2YWx1ZSI6IiM2ZmExZjYifSwiRGFyayI6eyJ2YWx1ZSI6IiMwOTNiOTAifX19LHsibmFtZSI6InNjYWxlL2JsdWUtNDAwIiwidHlwZSI6ImNvbG9yIiwidmFsdWVzIjp7IkxpZ2h0Ijp7InZhbHVlIjoiIzNmODJmMyJ9LCJEYXJrIjp7InZhbHVlIjoiIzBjNGZjMCJ9fX0seyJuYW1lIjoic2NhbGUvYmx1ZS01MDAiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsidmFsdWUiOiIjMGY2M2YwIn0sIkRhcmsiOnsidmFsdWUiOiIjMGY2M2YwIn19fSx7Im5hbWUiOiJzY2FsZS9ibHVlLTYwMCIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJ2YWx1ZSI6IiMwYzRmYzAifSwiRGFyayI6eyJ2YWx1ZSI6IiMzZjgyZjMifX19LHsibmFtZSI6InNjYWxlL2JsdWUtNzAwIiwidHlwZSI6ImNvbG9yIiwidmFsdWVzIjp7IkxpZ2h0Ijp7InZhbHVlIjoiIzA5M2I5MCJ9LCJEYXJrIjp7InZhbHVlIjoiIzZmYTFmNiJ9fX0seyJuYW1lIjoic2NhbGUvYmx1ZS04MDAiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsidmFsdWUiOiIjMDYyODYwIn0sIkRhcmsiOnsidmFsdWUiOiIjOWZjMWY5In19fSx7Im5hbWUiOiJzY2FsZS9ibHVlLTkwMCIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJ2YWx1ZSI6IiMwMzE0MzAifSwiRGFyayI6eyJ2YWx1ZSI6IiNjZmUwZmMifX19LHsibmFtZSI6InNjYWxlL2JsdWUtOTUwIiwidHlwZSI6ImNvbG9yIiwidmFsdWVzIjp7IkxpZ2h0Ijp7InZhbHVlIjoiIzAyMGExOCJ9LCJEYXJrIjp7InZhbHVlIjoiI2U3ZWZmZCJ9fX0seyJuYW1lIjoic2NhbGUvZGVlcC1yZWQtNTAiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsidmFsdWUiOiIjZmVmYmZiIn0sIkRhcmsiOnsidmFsdWUiOiIjMzAwNjA2In19fSx7Im5hbWUiOiJzY2FsZS9kZWVwLXJlZC03NSIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJ2YWx1ZSI6IiNmZGYyZjIifSwiRGFyayI6eyJ2YWx1ZSI6IiMzYTA3MDcifX19LHsibmFtZSI6InNjYWxlL2RlZXAtcmVkLTEwMCIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJ2YWx1ZSI6IiNmY2VhZWEifSwiRGFyayI6eyJ2YWx1ZSI6IiM0NjA5MDkifX19LHsibmFtZSI6InNjYWxlL2RlZXAtcmVkLTE1MCIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJ2YWx1ZSI6IiNmYmUwZTAifSwiRGFyayI6eyJ2YWx1ZSI6IiM1MjBiMGIifX19LHsibmFtZSI6InNjYWxlL2RlZXAtcmVkLTIwMCIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJ2YWx1ZSI6IiNmOWQzZDMifSwiRGFyayI6eyJ2YWx1ZSI6IiM2ODBlMGUifX19LHsibmFtZSI6InNjYWxlL2RlZXAtcmVkLTMwMCIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJ2YWx1ZSI6IiNmN2JlYmUifSwiRGFyayI6eyJ2YWx1ZSI6IiM4NTExMTEifX19LHsibmFtZSI6InNjYWxlL2RlZXAtcmVkLTQwMCIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJ2YWx1ZSI6IiNmMzlmOWYifSwiRGFyayI6eyJ2YWx1ZSI6IiNhMzE1MTUifX19LHsibmFtZSI6InNjYWxlL2RlZXAtcmVkLTUwMCIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJ2YWx1ZSI6IiNlZTgwODAifSwiRGFyayI6eyJ2YWx1ZSI6IiNjMDE5MTkifX19LHsibmFtZSI6InNjYWxlL2RlZXAtcmVkLTYwMCIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJ2YWx1ZSI6IiNlYTVlNWUifSwiRGFyayI6eyJ2YWx1ZSI6IiNlNjNmM2YifX19LHsibmFtZSI6InNjYWxlL2RlZXAtcmVkLTcwMCIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJ2YWx1ZSI6IiNjZjJiMmIifSwiRGFyayI6eyJ2YWx1ZSI6IiNmMDhlOGUifX19LHsibmFtZSI6InNjYWxlL2RlZXAtcmVkLTgwMCIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJ2YWx1ZSI6IiM5MjEzMTMifSwiRGFyayI6eyJ2YWx1ZSI6IiNmOGQ2ZDYifX19LHsibmFtZSI6InNjYWxlL2RlZXAtcmVkLTkwMCIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJ2YWx1ZSI6IiM0OTBiMGIifSwiRGFyayI6eyJ2YWx1ZSI6IiNmYmViZWIifX19LHsibmFtZSI6InNjYWxlL2RlZXAtcmVkLTk1MCIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJ2YWx1ZSI6IiMxNzAzMDMifSwiRGFyayI6eyJ2YWx1ZSI6IiNmZWZiZmIifX19LHsibmFtZSI6InNjYWxlL2dyZWVuLTUwIiwidHlwZSI6ImNvbG9yIiwidmFsdWVzIjp7IkxpZ2h0Ijp7InZhbHVlIjoiI2Y1ZmVmNiJ9LCJEYXJrIjp7InZhbHVlIjoiIzAzMWEwNSJ9fX0seyJuYW1lIjoic2NhbGUvZ3JlZW4tNzUiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsidmFsdWUiOiIjZTFmYmU0In0sIkRhcmsiOnsidmFsdWUiOiIjMDQyMDA3In19fSx7Im5hbWUiOiJzY2FsZS9ncmVlbi0xMDAiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsidmFsdWUiOiIjY2RmOWQxIn0sIkRhcmsiOnsidmFsdWUiOiIjMDUyNzA5In19fSx7Im5hbWUiOiJzY2FsZS9ncmVlbi0xNTAiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsidmFsdWUiOiIjYjZmNmJjIn0sIkRhcmsiOnsidmFsdWUiOiIjMDYyZjBhIn19fSx7Im5hbWUiOiJzY2FsZS9ncmVlbi0yMDAiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsidmFsdWUiOiIjOTRmMTlkIn0sIkRhcmsiOnsidmFsdWUiOiIjMDgzYzBkIn19fSx7Im5hbWUiOiJzY2FsZS9ncmVlbi0zMDAiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsidmFsdWUiOiIjNGVlOTVlIn0sIkRhcmsiOnsidmFsdWUiOiIjMGE0ZDExIn19fSx7Im5hbWUiOiJzY2FsZS9ncmVlbi00MDAiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsidmFsdWUiOiIjMWJkMTJkIn0sIkRhcmsiOnsidmFsdWUiOiIjMGM1ZjE1In19fSx7Im5hbWUiOiJzY2FsZS9ncmVlbi01MDAiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsidmFsdWUiOiIjMTdiOTI4In0sIkRhcmsiOnsidmFsdWUiOiIjMGU3MTE4In19fSx7Im5hbWUiOiJzY2FsZS9ncmVlbi02MDAiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsidmFsdWUiOiIjMWRhMjJiIn0sIkRhcmsiOnsidmFsdWUiOiIjMTI5MjFmIn19fSx7Im5hbWUiOiJzY2FsZS9ncmVlbi03MDAiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsidmFsdWUiOiIjMTA3ZTFiIn0sIkRhcmsiOnsidmFsdWUiOiIjMTljNDJhIn19fSx7Im5hbWUiOiJzY2FsZS9ncmVlbi04MDAiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsidmFsdWUiOiIjMGI1NTEyIn0sIkRhcmsiOnsidmFsdWUiOiIjOTlmMmEyIn19fSx7Im5hbWUiOiJzY2FsZS9ncmVlbi05MDAiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsidmFsdWUiOiIjMDkyOTBjIn0sIkRhcmsiOnsidmFsdWUiOiIjY2ZmOWQ0In19fSx7Im5hbWUiOiJzY2FsZS9ncmVlbi05NTAiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsidmFsdWUiOiIjMDEwYjAyIn0sIkRhcmsiOnsidmFsdWUiOiIjZjVmZWY2In19fSx7Im5hbWUiOiJzdGF0aWMvc3RhdGljLXdoaXRlLWFscGhhLTAwIiwidHlwZSI6ImNvbG9yIiwidmFsdWVzIjp7IkxpZ2h0Ijp7InZhbHVlIjoicmdiYSgyNTUsIDI1NSwgMjU1LCAwKSJ9LCJEYXJrIjp7InZhbHVlIjoicmdiYSgyNTUsIDI1NSwgMjU1LCAwKSJ9fX0seyJuYW1lIjoic3RhdGljL3N0YXRpYy13aGl0ZS1hbHBoYS0xMDAiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsidmFsdWUiOiJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMTEpIn0sIkRhcmsiOnsidmFsdWUiOiJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMTEpIn19fSx7Im5hbWUiOiJzdGF0aWMvc3RhdGljLXdoaXRlLWFscGhhLTIwMCIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJ2YWx1ZSI6InJnYmEoMjU1LCAyNTUsIDI1NSwgMC4xOSkifSwiRGFyayI6eyJ2YWx1ZSI6InJnYmEoMjU1LCAyNTUsIDI1NSwgMC4xOSkifX19LHsibmFtZSI6InN0YXRpYy9zdGF0aWMtd2hpdGUtYWxwaGEtMzAwIiwidHlwZSI6ImNvbG9yIiwidmFsdWVzIjp7IkxpZ2h0Ijp7InZhbHVlIjoicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjI1KSJ9LCJEYXJrIjp7InZhbHVlIjoicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjI1KSJ9fX0seyJuYW1lIjoic3RhdGljL3N0YXRpYy13aGl0ZS1hbHBoYS00MDAiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsidmFsdWUiOiJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMzIpIn0sIkRhcmsiOnsidmFsdWUiOiJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMzIpIn19fSx7Im5hbWUiOiJzdGF0aWMvc3RhdGljLXdoaXRlLWFscGhhLTUwMCIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJ2YWx1ZSI6InJnYmEoMjU1LCAyNTUsIDI1NSwgMC4zOCkifSwiRGFyayI6eyJ2YWx1ZSI6InJnYmEoMjU1LCAyNTUsIDI1NSwgMC4zOCkifX19LHsibmFtZSI6InN0YXRpYy9zdGF0aWMtd2hpdGUtYWxwaGEtNjAwIiwidHlwZSI6ImNvbG9yIiwidmFsdWVzIjp7IkxpZ2h0Ijp7InZhbHVlIjoicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpIn0sIkRhcmsiOnsidmFsdWUiOiJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSkifX19LHsibmFtZSI6InN0YXRpYy9zdGF0aWMtd2hpdGUtYWxwaGEtNzAwIiwidHlwZSI6ImNvbG9yIiwidmFsdWVzIjp7IkxpZ2h0Ijp7InZhbHVlIjoicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjY4KSJ9LCJEYXJrIjp7InZhbHVlIjoicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjY4KSJ9fX0seyJuYW1lIjoic3RhdGljL3N0YXRpYy13aGl0ZS1hbHBoYS04MDAiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsidmFsdWUiOiJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuODkpIn0sIkRhcmsiOnsidmFsdWUiOiJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuODkpIn19fSx7Im5hbWUiOiJzdGF0aWMvc3RhdGljLXdoaXRlLWFscGhhLTkwMCIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJ2YWx1ZSI6InJnYmEoMjU1LCAyNTUsIDI1NSwgMC45NikifSwiRGFyayI6eyJ2YWx1ZSI6InJnYmEoMjU1LCAyNTUsIDI1NSwgMC45NikifX19LHsibmFtZSI6InN0YXRpYy9zdGF0aWMtYmxhY2stYWxwaGEtMDAiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsidmFsdWUiOiJyZ2JhKDAsIDAsIDAsIDApIn0sIkRhcmsiOnsidmFsdWUiOiJyZ2JhKDAsIDAsIDAsIDApIn19fSx7Im5hbWUiOiJzdGF0aWMvc3RhdGljLWJsYWNrLWFscGhhLTEwMCIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJ2YWx1ZSI6InJnYmEoMCwgMCwgMCwgMC4wNikifSwiRGFyayI6eyJ2YWx1ZSI6InJnYmEoMCwgMCwgMCwgMC4wNikifX19LHsibmFtZSI6InN0YXRpYy9zdGF0aWMtYmxhY2stYWxwaGEtMjAwIiwidHlwZSI6ImNvbG9yIiwidmFsdWVzIjp7IkxpZ2h0Ijp7InZhbHVlIjoicmdiYSgwLCAwLCAwLCAwLjEzKSJ9LCJEYXJrIjp7InZhbHVlIjoicmdiYSgwLCAwLCAwLCAwLjEzKSJ9fX0seyJuYW1lIjoic3RhdGljL3N0YXRpYy1ibGFjay1hbHBoYS0zMDAiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsidmFsdWUiOiJyZ2JhKDAsIDAsIDAsIDAuMikifSwiRGFyayI6eyJ2YWx1ZSI6InJnYmEoMCwgMCwgMCwgMC4yKSJ9fX0seyJuYW1lIjoic3RhdGljL3N0YXRpYy1ibGFjay1hbHBoYS00MDAiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsidmFsdWUiOiJyZ2JhKDAsIDAsIDAsIDAuMjkpIn0sIkRhcmsiOnsidmFsdWUiOiJyZ2JhKDAsIDAsIDAsIDAuMjkpIn19fSx7Im5hbWUiOiJzdGF0aWMvc3RhdGljLWJsYWNrLWFscGhhLTUwMCIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJ2YWx1ZSI6InJnYmEoMCwgMCwgMCwgMC4zOCkifSwiRGFyayI6eyJ2YWx1ZSI6InJnYmEoMCwgMCwgMCwgMC4zOCkifX19LHsibmFtZSI6InN0YXRpYy9zdGF0aWMtYmxhY2stYWxwaGEtNjAwIiwidHlwZSI6ImNvbG9yIiwidmFsdWVzIjp7IkxpZ2h0Ijp7InZhbHVlIjoicmdiYSgwLCAwLCAwLCAwLjQ2KSJ9LCJEYXJrIjp7InZhbHVlIjoicmdiYSgwLCAwLCAwLCAwLjQ2KSJ9fX0seyJuYW1lIjoic3RhdGljL3N0YXRpYy1ibGFjay1hbHBoYS03MDAiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsidmFsdWUiOiJyZ2JhKDAsIDAsIDAsIDAuNTgpIn0sIkRhcmsiOnsidmFsdWUiOiJyZ2JhKDAsIDAsIDAsIDAuNTgpIn19fSx7Im5hbWUiOiJzdGF0aWMvc3RhdGljLWJsYWNrLWFscGhhLTgwMCIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJ2YWx1ZSI6InJnYmEoMCwgMCwgMCwgMC43MykifSwiRGFyayI6eyJ2YWx1ZSI6InJnYmEoMCwgMCwgMCwgMC43MykifX19LHsibmFtZSI6InN0YXRpYy9zdGF0aWMtYmxhY2stYWxwaGEtOTAwIiwidHlwZSI6ImNvbG9yIiwidmFsdWVzIjp7IkxpZ2h0Ijp7InZhbHVlIjoicmdiYSgwLCAwLCAwLCAwLjg4KSJ9LCJEYXJrIjp7InZhbHVlIjoicmdiYSgwLCAwLCAwLCAwLjg4KSJ9fX0seyJuYW1lIjoic2VtYW50aWMvdGV4dC9wcmltYXJ5IiwidHlwZSI6ImNvbG9yIiwidmFsdWVzIjp7IkxpZ2h0Ijp7ImFsaWFzIjoic2NhbGUvZ3JheS05MDAifSwiRGFyayI6eyJhbGlhcyI6InNjYWxlL2dyYXktOTAwIn19fSx7Im5hbWUiOiJzZW1hbnRpYy90ZXh0L3NlY29uZGFyeSIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJhbGlhcyI6InNjYWxlL2dyYXktNzAwIn0sIkRhcmsiOnsiYWxpYXMiOiJzY2FsZS9ncmF5LTcwMCJ9fX0seyJuYW1lIjoic2VtYW50aWMvdGV4dC90ZXJ0aWFyeSIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJhbGlhcyI6InNjYWxlL2dyYXktNjAwIn0sIkRhcmsiOnsiYWxpYXMiOiJzY2FsZS9ncmF5LTYwMCJ9fX0seyJuYW1lIjoic2VtYW50aWMvdGV4dC9kaXNhYmxlZCIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJhbGlhcyI6InNjYWxlL2dyYXktNDAwIn0sIkRhcmsiOnsiYWxpYXMiOiJzY2FsZS9ncmF5LTQwMCJ9fX0seyJuYW1lIjoic2VtYW50aWMvdGV4dC9vbi1jb2xvciIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJhbGlhcyI6InNjYWxlL2dyYXktNTAifSwiRGFyayI6eyJhbGlhcyI6InNjYWxlL2dyYXktNTAifX19LHsibmFtZSI6InNlbWFudGljL2ZpbGwvcHJpbWFyeSIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJhbGlhcyI6InNjYWxlL2dyYXktOTAwIn0sIkRhcmsiOnsiYWxpYXMiOiJzY2FsZS9ncmF5LTk1MCJ9fX0seyJuYW1lIjoic2VtYW50aWMvZmlsbC9wcmltYXJ5LWhvdmVyIiwidHlwZSI6ImNvbG9yIiwidmFsdWVzIjp7IkxpZ2h0Ijp7ImFsaWFzIjoic2NhbGUvZ3JheS05NTAifSwiRGFyayI6eyJhbGlhcyI6InNjYWxlL2dyYXktOTAwIn19fSx7Im5hbWUiOiJzZW1hbnRpYy9maWxsL3ByaW1hcnktcHJlc3NlZCIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJhbGlhcyI6InNjYWxlL2dyYXktOTUwIn0sIkRhcmsiOnsiYWxpYXMiOiJzY2FsZS9ncmF5LTkwMCJ9fX0seyJuYW1lIjoic2VtYW50aWMvZmlsbC90ZXJ0aWFyeSIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJhbGlhcyI6InNjYWxlL2dyYXktNzUifSwiRGFyayI6eyJhbGlhcyI6InNjYWxlL2dyYXktMTAwIn19fSx7Im5hbWUiOiJzZW1hbnRpYy9maWxsL3RlcnRpYXJ5LWhvdmVyIiwidHlwZSI6ImNvbG9yIiwidmFsdWVzIjp7IkxpZ2h0Ijp7ImFsaWFzIjoic2NhbGUvZ3JheS0xMDAifSwiRGFyayI6eyJhbGlhcyI6InNjYWxlL2dyYXktMTUwIn19fSx7Im5hbWUiOiJzZW1hbnRpYy9maWxsL3RlcnRpYXJ5LXByZXNzZWQiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsiYWxpYXMiOiJzY2FsZS9ncmF5LTEwMCJ9LCJEYXJrIjp7ImFsaWFzIjoic2NhbGUvZ3JheS0xNTAifX19LHsibmFtZSI6InNlbWFudGljL2ZpbGwvc2lsZW50IiwidHlwZSI6ImNvbG9yIiwidmFsdWVzIjp7IkxpZ2h0Ijp7ImFsaWFzIjoic2NhbGUvZ3JheS01MCJ9LCJEYXJrIjp7ImFsaWFzIjoic2NhbGUvZ3JheS03NSJ9fX0seyJuYW1lIjoic2VtYW50aWMvZmlsbC9zaWxlbnQtaG92ZXIiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsiYWxpYXMiOiJzY2FsZS9ncmF5LTEwMCJ9LCJEYXJrIjp7ImFsaWFzIjoic2NhbGUvZ3JheS0xMDAifX19LHsibmFtZSI6InNlbWFudGljL2ZpbGwvc2lsZW50LXByZXNzZWQiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsiYWxpYXMiOiJzY2FsZS9ncmF5LTEwMCJ9LCJEYXJrIjp7ImFsaWFzIjoic2NhbGUvZ3JheS0xMDAifX19LHsibmFtZSI6InNlbWFudGljL2ZpbGwvZGlzYWJsZWQiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsiYWxpYXMiOiJzY2FsZS9ncmF5LTE1MCJ9LCJEYXJrIjp7ImFsaWFzIjoic2NhbGUvZ3JheS0xNTAifX19LHsibmFtZSI6InNlbWFudGljL2ZpbGwvc3VyZmFjZS1jb250ZW50cyIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJhbGlhcyI6InNjYWxlL2dyYXktNzUifSwiRGFyayI6eyJhbGlhcyI6InNjYWxlL2dyYXktMTAwIn19fSx7Im5hbWUiOiJzZW1hbnRpYy9maWxsL3N1cmZhY2UtZmxvYXRpbmciLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsiYWxpYXMiOiJzY2FsZS9ncmF5LTkwMCJ9LCJEYXJrIjp7ImFsaWFzIjoic2NhbGUvZ3JheS05MDAifX19LHsibmFtZSI6InNlbWFudGljL2ZpbGwvc3VyZmFjZS1kaWFsb2ciLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsiYWxpYXMiOiJzY2FsZS9ncmF5LTUwIn0sIkRhcmsiOnsiYWxpYXMiOiJzY2FsZS9ncmF5LTc1In19fSx7Im5hbWUiOiJzZW1hbnRpYy9maWxsL3N1cmZhY2Utc2hlZXQiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsiYWxpYXMiOiJzY2FsZS9ncmF5LTUwIn0sIkRhcmsiOnsiYWxpYXMiOiJzY2FsZS9ncmF5LTc1In19fSx7Im5hbWUiOiJzZW1hbnRpYy9maWxsL3N1cmZhY2UtYmxhY2siLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsiYWxpYXMiOiJzY2FsZS9ncmF5LTk1MCJ9LCJEYXJrIjp7ImFsaWFzIjoic2NhbGUvZ3JheS01MCJ9fX0seyJuYW1lIjoic2VtYW50aWMvYm9yZGVyL2RpdmlkZXIiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsiYWxpYXMiOiJzY2FsZS9ncmF5LWFscGhhLTEwMCJ9LCJEYXJrIjp7ImFsaWFzIjoic2NhbGUvZ3JheS1hbHBoYS0xNTAifX19LHsibmFtZSI6InNlbWFudGljL2JvcmRlci9kaXZpZGVyLXN0cm9uZyIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJhbGlhcyI6InNjYWxlL2dyYXktOTUwIn0sIkRhcmsiOnsiYWxpYXMiOiJzY2FsZS9ncmF5LTk1MCJ9fX0seyJuYW1lIjoic2VtYW50aWMvYm9yZGVyL2xpbmUiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsiYWxpYXMiOiJzY2FsZS9ncmF5LTIwMCJ9LCJEYXJrIjp7ImFsaWFzIjoic2NhbGUvZ3JheS0yMDAifX19LHsibmFtZSI6InNlbWFudGljL2JvcmRlci9saW5lLXNlbGVjdGVkIiwidHlwZSI6ImNvbG9yIiwidmFsdWVzIjp7IkxpZ2h0Ijp7ImFsaWFzIjoic2NhbGUvZ3JheS05NTAifSwiRGFyayI6eyJhbGlhcyI6InNjYWxlL2dyYXktOTUwIn19fSx7Im5hbWUiOiJzZW1hbnRpYy9ib3JkZXIvbGluZS1kaXNhYmxlZCIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJhbGlhcyI6InNjYWxlL2dyYXktYWxwaGEtMjAwIn0sIkRhcmsiOnsiYWxpYXMiOiJzY2FsZS9ncmF5LWFscGhhLTEwMCJ9fX0seyJuYW1lIjoic2VtYW50aWMvb3ZlcmxheS9kaW1tZWQiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsiYWxpYXMiOiJzdGF0aWMvc3RhdGljLWJsYWNrLWFscGhhLTcwMCJ9LCJEYXJrIjp7ImFsaWFzIjoic3RhdGljL3N0YXRpYy1ibGFjay1hbHBoYS03MDAifX19LHsibmFtZSI6InNlbWFudGljL2JhY2tncm91bmQvZGVmYXVsdCIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJhbGlhcyI6InNjYWxlL2dyYXktNTAifSwiRGFyayI6eyJhbGlhcyI6InNjYWxlL2dyYXktNTAifX19LHsibmFtZSI6InNlbWFudGljL2JhY2tncm91bmQvbG93IiwidHlwZSI6ImNvbG9yIiwidmFsdWVzIjp7IkxpZ2h0Ijp7ImFsaWFzIjoic2NhbGUvZ3JheS03NSJ9LCJEYXJrIjp7ImFsaWFzIjoic2NhbGUvZ3JheS0xMDAifX19LHsibmFtZSI6InNlbWFudGljL2JhY2tncm91bmQvYmxhY2siLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsiYWxpYXMiOiJzY2FsZS9ncmF5LTk1MCJ9LCJEYXJrIjp7ImFsaWFzIjoic2NhbGUvZ3JheS01MCJ9fX0seyJuYW1lIjoic2VtYW50aWMvYmFja2dyb3VuZC9ncmFkaWVudC1kZWZhdWx0IiwidHlwZSI6ImNvbG9yIiwidmFsdWVzIjp7IkxpZ2h0Ijp7ImFsaWFzIjoic2NhbGUvZ3JheS05NTAifSwiRGFyayI6eyJhbGlhcyI6InNjYWxlL2dyYXktNTAifX19LHsibmFtZSI6InNlbWFudGljL3NoYWRvdy9kZWZhdWx0IiwidHlwZSI6ImNvbG9yIiwidmFsdWVzIjp7IkxpZ2h0Ijp7ImFsaWFzIjoic3RhdGljL3N0YXRpYy1ibGFjay1hbHBoYS0xMDAifSwiRGFyayI6eyJhbGlhcyI6InN0YXRpYy9zdGF0aWMtYmxhY2stYWxwaGEtMTAwIn19fSx7Im5hbWUiOiJzZW1hbnRpYy9jb21tb24vb24td2hpdGUiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsiYWxpYXMiOiJzY2FsZS9ncmF5LTUwIn0sIkRhcmsiOnsiYWxpYXMiOiJzY2FsZS9ncmF5LTk1MCJ9fX0seyJuYW1lIjoic2VtYW50aWMvY29tbW9uL29uLXdoaXRlLWhvdmVyIiwidHlwZSI6ImNvbG9yIiwidmFsdWVzIjp7IkxpZ2h0Ijp7ImFsaWFzIjoic2NhbGUvZ3JheS03NSJ9LCJEYXJrIjp7ImFsaWFzIjoic2NhbGUvZ3JheS05MDAifX19LHsibmFtZSI6InNlbWFudGljL2NvbW1vbi9vbi13aGl0ZS1wcmVzc2VkIiwidHlwZSI6ImNvbG9yIiwidmFsdWVzIjp7IkxpZ2h0Ijp7ImFsaWFzIjoic2NhbGUvZ3JheS03NSJ9LCJEYXJrIjp7ImFsaWFzIjoic2NhbGUvZ3JheS05MDAifX19LHsibmFtZSI6InNlbWFudGljL2NvbW1vbi9vbi1ibGFjayIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJhbGlhcyI6InNjYWxlL2dyYXktOTAwIn0sIkRhcmsiOnsiYWxpYXMiOiJzY2FsZS9ncmF5LTc1In19fSx7Im5hbWUiOiJzZW1hbnRpYy9jb21tb24vb24tYmxhY2staG92ZXIiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsiYWxpYXMiOiJzY2FsZS9ncmF5LTk1MCJ9LCJEYXJrIjp7ImFsaWFzIjoic2NhbGUvZ3JheS01MCJ9fX0seyJuYW1lIjoic2VtYW50aWMvY29tbW9uL29uLWJsYWNrLXByZXNzZWQiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsiYWxpYXMiOiJzY2FsZS9ncmF5LTk1MCJ9LCJEYXJrIjp7ImFsaWFzIjoic2NhbGUvZ3JheS01MCJ9fX0seyJuYW1lIjoic2VtYW50aWMvY29tbW9uL211dGVkIiwidHlwZSI6ImNvbG9yIiwidmFsdWVzIjp7IkxpZ2h0Ijp7ImFsaWFzIjoic2NhbGUvZ3JheS0zMDAifSwiRGFyayI6eyJhbGlhcyI6InNjYWxlL2dyYXktMzAwIn19fSx7Im5hbWUiOiJzZW1hbnRpYy9jb21tb24vYWNjZW50IiwidHlwZSI6ImNvbG9yIiwidmFsdWVzIjp7IkxpZ2h0Ijp7ImFsaWFzIjoic2NhbGUvb3JhbmdlLXJlZC00MDAifSwiRGFyayI6eyJhbGlhcyI6InNjYWxlL29yYW5nZS1yZWQtNDAwIn19fSx7Im5hbWUiOiJzZW1hbnRpYy9jb21tb24vYWNjZW50LWhvdmVyIiwidHlwZSI6ImNvbG9yIiwidmFsdWVzIjp7IkxpZ2h0Ijp7ImFsaWFzIjoic2NhbGUvb3JhbmdlLXJlZC01MDAifSwiRGFyayI6eyJhbGlhcyI6InNjYWxlL29yYW5nZS1yZWQtMzAwIn19fSx7Im5hbWUiOiJzZW1hbnRpYy9jb21tb24vYWNjZW50LXByZXNzZWQiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsiYWxpYXMiOiJzY2FsZS9vcmFuZ2UtcmVkLTUwMCJ9LCJEYXJrIjp7ImFsaWFzIjoic2NhbGUvb3JhbmdlLXJlZC0zMDAifX19LHsibmFtZSI6InNlbWFudGljL2NvbW1vbi9hY2NlbnQtbG93IiwidHlwZSI6ImNvbG9yIiwidmFsdWVzIjp7IkxpZ2h0Ijp7ImFsaWFzIjoic2NhbGUvb3JhbmdlLXJlZC01MCJ9LCJEYXJrIjp7ImFsaWFzIjoic2NhbGUvb3JhbmdlLXJlZC01MCJ9fX0seyJuYW1lIjoic2VtYW50aWMvY29tbW9uL2luZm9tYXRpdmUiLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsiYWxpYXMiOiJzY2FsZS9ibHVlLTUwMCJ9LCJEYXJrIjp7ImFsaWFzIjoic2NhbGUvYmx1ZS02MDAifX19LHsibmFtZSI6InNlbWFudGljL2NvbW1vbi9pbmZvbWF0aXZlLWhvdmVyIiwidHlwZSI6ImNvbG9yIiwidmFsdWVzIjp7IkxpZ2h0Ijp7ImFsaWFzIjoic2NhbGUvYmx1ZS02MDAifSwiRGFyayI6eyJhbGlhcyI6InNjYWxlL2JsdWUtNTAwIn19fSx7Im5hbWUiOiJzZW1hbnRpYy9jb21tb24vaW5mb21hdGl2ZS1wcmVzc2VkIiwidHlwZSI6ImNvbG9yIiwidmFsdWVzIjp7IkxpZ2h0Ijp7ImFsaWFzIjoic2NhbGUvYmx1ZS02MDAifSwiRGFyayI6eyJhbGlhcyI6InNjYWxlL2JsdWUtNTAwIn19fSx7Im5hbWUiOiJzZW1hbnRpYy9jb21tb24vaW5mb21hdGl2ZS1sb3ciLCJ0eXBlIjoiY29sb3IiLCJ2YWx1ZXMiOnsiTGlnaHQiOnsiYWxpYXMiOiJzY2FsZS9ibHVlLTUwIn0sIkRhcmsiOnsiYWxpYXMiOiJzY2FsZS9ibHVlLTc1In19fSx7Im5hbWUiOiJzZW1hbnRpYy9jb21tb24vY3VzdG9tLWFjY2VudCIsInR5cGUiOiJjb2xvciIsInZhbHVlcyI6eyJMaWdodCI6eyJhbGlhcyI6InNjYWxlL2dyYXktOTAwIn0sIkRhcmsiOnsiYWxpYXMiOiJzY2FsZS9ncmF5LTkwMCJ9fX0seyJuYW1lIjoic2VtYW50aWMvY29tbW9uL2N1c3RvbS1hY2NlbnQtbG93IiwidHlwZSI6ImNvbG9yIiwidmFsdWVzIjp7IkxpZ2h0Ijp7ImFsaWFzIjoic2NhbGUvZ3JheS03NSJ9LCJEYXJrIjp7ImFsaWFzIjoic2NhbGUvZ3JheS0xMDAifX19XQ==';


let cachedRulerLocalData = null;
function decodeBase64ToString(base64) {
  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
  var output = '';
  var buffer = 0;
  var bitsCollected = 0;
  for (var i = 0; i < base64.length; i++) {
    var char = base64.charAt(i);
    if (char === '=' || char === '\n' || char === '\r' || char === '\t' || char === ' ') {
      if (char === '=') {
        break;
      }
      continue;
    }
    var value = chars.indexOf(char);
    if (value < 0) {
      continue;
    }
    buffer = (buffer << 6) | value;
    bitsCollected += 6;
    if (bitsCollected >= 8) {
      bitsCollected -= 8;
      var byte = (buffer >> bitsCollected) & 0xFF;
      buffer &= (1 << bitsCollected) - 1;
      output += String.fromCharCode(byte);
    }
  }
  return output;
}

function getRulerLocalData() {
  if (!cachedRulerLocalData) {
    try {
      var json = decodeBase64ToString(RULER_V2_LOCAL_DATA_BASE64);
      var entries = JSON.parse(json);
      var map = {};
      var order = [];
      for (var i = 0; i < entries.length; i++) {
        var entry = entries[i];
        map[entry.name] = entry;
        order.push(entry.name);
      }
      cachedRulerLocalData = { map: map, order: order };
    } catch (error) {
      console.warn('[Backend] Failed to decode local ruler data:', error);
      cachedRulerLocalData = { map: {}, order: [] };
    }
  }
  return cachedRulerLocalData;
}


let cachedLibrarySyncNames = null;
function getLibrarySyncNames() {
  if (!cachedLibrarySyncNames) {
    var fallback = getRulerLocalData();
    var order = (fallback && Array.isArray(fallback.order)) ? fallback.order.slice() : [];
    var validNames = [];
    var seen = {};
    for (var i = 0; i < order.length; i++) {
      var name = order[i];
      if (LIBRARY_VARIABLE_KEYS.hasOwnProperty(name) && !seen[name]) {
        validNames.push(name);
        seen[name] = true;
      }
    }
    cachedLibrarySyncNames = validNames;
  }
  return cachedLibrarySyncNames.slice();
}


async function findRulerCollection() {
  var collections = await figma.variables.getLocalVariableCollectionsAsync();
  return collections.find(function(c) { return c.name === 'ruler_v2'; }) || null;
}

async function ensureRulerCollectionWithModes() {
  var collection = await findRulerCollection();

  if (!collection) {
    collection = figma.variables.createVariableCollection('ruler_v2');
  }

  var lightMode = collection.modes.find(function(m) { return m.name === 'Light'; });
  if (!lightMode) {
    if (collection.modes.length === 1 && collection.modes[0].name === 'Mode 1') {
      collection.renameMode(collection.modes[0].modeId, 'Light');
      lightMode = collection.modes[0];
    } else {
      var lightId = collection.addMode('Light');
      lightMode = collection.modes.find(function(m) { return m.modeId === lightId; });
    }
  }

  var darkMode = collection.modes.find(function(m) { return m.name === 'Dark'; });
  if (!darkMode) {
    var darkId = collection.addMode('Dark');
    darkMode = collection.modes.find(function(m) { return m.modeId === darkId; });
  }

  return {
    collection: collection,
    lightModeId: lightMode ? lightMode.modeId : null,
    darkModeId: darkMode ? darkMode.modeId : null
  };
}

async function getLibraryCollectionModes(collectionId) {
  if (!collectionId) return [];
  if (libraryCollectionModeCache.has(collectionId)) {
    return libraryCollectionModeCache.get(collectionId);
  }

  try {
    var collection = await figma.variables.getVariableCollectionByIdAsync(collectionId);
    if (collection && Array.isArray(collection.modes)) {
      var modes = collection.modes.map(function(mode) {
        return { modeId: mode.modeId, name: mode.name };
      });
      libraryCollectionModeCache.set(collectionId, modes);
      return modes;
    }
  } catch (error) {
    console.warn('[Backend] 라이브러리 컬렉션 모드 조회 실패:', error);
  }

  libraryCollectionModeCache.set(collectionId, []);
  return [];
}


async function ensureLibraryVariablesForMappings(mappings, theme) {
  return [];
}

function normalizeVariableLookup(allVariables, collectionId, name) {
  if (!name) return null;
  var match = allVariables.find(function(v) {
    return v.name === name && v.variableCollectionId === collectionId;
  });
  if (match) return match;
  match = allVariables.find(function(v) { return v.name === name; });
  if (match) return match;
  return null;
}

function cloneVariableValue(value) {
  if (value === undefined || value === null) {
    return value;
  }
  if (typeof value === 'object') {
    try {
      return JSON.parse(JSON.stringify(value));
    } catch (error) {
      console.warn('[Backend] 변수 값 클론 실패, 원본 사용:', error);
      return value;
    }
  }
  return value;
}

async function resolveLibraryVariableValue(value, modeId, depth) {
  if (depth === undefined) depth = 0;
  if (depth > 5) {
    return null;
  }
  if (value && typeof value === 'object' && value.type === 'VARIABLE_ALIAS' && value.id) {
    try {
      var targetVar = await figma.variables.getVariableByIdAsync(value.id);
      if (!targetVar) return null;
      var nextValue = undefined;
      if (targetVar.valuesByMode) {
        if (modeId && targetVar.valuesByMode[modeId] !== undefined) {
          nextValue = targetVar.valuesByMode[modeId];
        } else {
          var keys = Object.keys(targetVar.valuesByMode);
          if (keys.length > 0) {
            nextValue = targetVar.valuesByMode[keys[0]];
          }
        }
      }
      if (nextValue === undefined) {
        return null;
      }
      return resolveLibraryVariableValue(nextValue, modeId, depth + 1);
    } catch (error) {
      console.warn('[Backend] 변수 값 해석 실패:', error);
      return null;
    }
  }
  return value;
}

async function handleCheckLibrarySync() {
  var collection = await findRulerCollection();
  var syncNames = getLibrarySyncNames();
  var totalRequired = syncNames.length;
  var missingCount = totalRequired;

  if (collection) {
    var localVariables = await figma.variables.getLocalVariablesAsync('COLOR');
    var localMap = new Map();
    for (var i = 0; i < localVariables.length; i++) {
      var variable = localVariables[i];
      if (variable.variableCollectionId === collection.id) {
        localMap.set(variable.name, variable);
      }
    }

    missingCount = 0;
    for (var j = 0; j < syncNames.length; j++) {
      var name = syncNames[j];
      var localVar = localMap.get(name);
      var libraryKey = LIBRARY_VARIABLE_KEYS[name];
      if (!localVar) {
        missingCount++;
      } else if (libraryKey && localVar.key === libraryKey) {
        missingCount++;
      }
    }
  }

  figma.ui.postMessage({
    type: 'library-sync-status',
    needsSetup: missingCount > 0,
    missingCount: missingCount,
    totalRequired: totalRequired
  });
}

async function handleSyncLibraryVariables() {
  try {
    var setupInfo = await ensureRulerCollectionWithModes();
    var syncNames = getLibrarySyncNames();
    var fallbackData = getRulerLocalData();
    var fallbackMap = (fallbackData && fallbackData.map) ? fallbackData.map : {};
    var collection = setupInfo.collection;
    var total = syncNames.length;
    var completed = 0;
    var createdCount = 0;
    var updatedCount = 0;
    var failedImports = [];
    var fallbackCount = 0;

    var localVariables = await figma.variables.getLocalVariablesAsync('COLOR');
    var localMap = new Map();
    for (var i = 0; i < localVariables.length; i++) {
      var variable = localVariables[i];
      if (variable.variableCollectionId === collection.id) {
        localMap.set(variable.name, variable);
      }
    }

    for (var i = 0; i < syncNames.length; i++) {
      var name = syncNames[i];
      var key = LIBRARY_VARIABLE_KEYS[name];
      if (!key) {
        completed++;
        continue;
      }

      var libraryVar = null;
      var importError = null;
      try {
        libraryVar = await figma.variables.importVariableByKeyAsync(key);
      } catch (error) {
        console.warn('[Backend] 변수 임포트 실패:', name, error);
        importError = error;
      }

      var libraryModes = [];
      if (libraryVar) {
        libraryModes = await getLibraryCollectionModes(libraryVar.variableCollectionId);
      }
      var valueByModeName = new Map();
      var defaultValue = null;

      if (libraryVar && Array.isArray(libraryModes) && libraryModes.length > 0) {
        for (var m = 0; m < libraryModes.length; m++) {
          var modeInfo = libraryModes[m];
          var libraryValue = libraryVar.valuesByMode ? libraryVar.valuesByMode[modeInfo.modeId] : undefined;
          var resolvedValue = await resolveLibraryVariableValue(libraryValue, modeInfo.modeId);
          if (resolvedValue !== undefined && resolvedValue !== null) {
            valueByModeName.set(modeInfo.name, resolvedValue);
            if (defaultValue === null) {
              defaultValue = resolvedValue;
            }
          }
        }
      }

      if (libraryVar && defaultValue === null && libraryVar.valuesByMode) {
        var firstKeys = Object.keys(libraryVar.valuesByMode);
        if (firstKeys.length > 0) {
          defaultValue = await resolveLibraryVariableValue(libraryVar.valuesByMode[firstKeys[0]], firstKeys[0]);
        }
      }

      if (defaultValue === null) {
        var fallback = fallbackMap[name];
        if (fallback && fallback.values) {
          var usedFallback = false;
          for (var modeName in fallback.values) {
            if (!Object.prototype.hasOwnProperty.call(fallback.values, modeName)) continue;
            if (valueByModeName.has(modeName)) continue;
            var fallbackValue = fallback.values[modeName];
            if (!fallbackValue) continue;
            if (fallbackValue.alias) {
              var aliasName = fallbackValue.alias;
              var aliasVar = localMap.get(aliasName);
              if (!aliasVar) {
                aliasVar = normalizeVariableLookup(localVariables, collection.id, aliasName);
              }
              if (aliasVar) {
                valueByModeName.set(modeName, {
                  type: 'VARIABLE_ALIAS',
                  id: aliasVar.id
                });
                if (defaultValue === null) {
                  defaultValue = { type: 'VARIABLE_ALIAS', id: aliasVar.id };
                }
                usedFallback = true;
              }
            } else if (fallbackValue.value) {
              var parsed = parseColorValue(fallbackValue.value);
              if (parsed) {
                valueByModeName.set(modeName, parsed);
                if (defaultValue === null) {
                  defaultValue = parsed;
                }
                usedFallback = true;
              }
            }
          }
          if (usedFallback) {
            fallbackCount++;
          }
        }
      }

      if (defaultValue === null) {
        completed++;
        var reason = importError ? (importError.message || String(importError)) : 'No resolved value and no fallback data';
        failedImports.push({ name: name, error: reason });
        continue;
      }

      var localVar = localMap.get(name);
      var shouldClone = !localVar || (localVar.key && localVar.key === key);

      if (shouldClone && localVar && typeof localVar.remove === 'function') {
        try {
          localVar.remove();
        } catch (error) {
          console.warn('[Backend] 기존 변수 제거 실패:', name, error);
        }
        localMap.delete(name);
        localVar = null;
      }

      if (!localVar) {
        localVar = figma.variables.createVariable(name, collection, 'COLOR');
        localMap.set(name, localVar);
        localVariables.push(localVar);
        allVariables.push(localVar);
        localVarByName.set(name, localVar);
        localVarById.set(localVar.id, localVar);
        createdCount++;
      } else {
        updatedCount++;
      }

      if (Array.isArray(collection.modes)) {
        for (var c = 0; c < collection.modes.length; c++) {
          var mode = collection.modes[c];
          var targetValue = valueByModeName.has(mode.name) ? valueByModeName.get(mode.name) : defaultValue;
          if (targetValue !== undefined && targetValue !== null) {
            localVar.setValueForMode(mode.modeId, cloneVariableValue(targetValue));
          }
        }
      }

      completed++;
      if (completed % 10 === 0 || completed === total) {
        figma.ui.postMessage({
          type: 'library-sync-progress',
          completed: completed,
          total: total
        });
      }
    }

    await handleCheckLibrarySync();
    var finalLocal = await figma.variables.getLocalVariablesAsync('COLOR');
    console.log('[Backend] 복제 완료 - 로컬 변수 수:', finalLocal.length);
    console.log('[Backend] 샘플 변수 목록:', finalLocal.slice(0, 10).map(function(v) { return { name: v.name, collection: v.variableCollectionId }; }));

    var resultMessage = '라이브러리 토큰 복제 완료 (' + createdCount + '개 생성, ' + updatedCount + '개 갱신';
    if (fallbackCount > 0) {
      resultMessage += ', 로컬 데이터 사용 ' + fallbackCount + '개';
    }
    if (failedImports.length > 0) {
      resultMessage += ', 실패 ' + failedImports.length + '개';
    }
    resultMessage += ')';

    figma.ui.postMessage({
      type: 'library-sync-complete',
      imported: completed,
      total: total,
      created: createdCount,
      updated: updatedCount,
      failed: failedImports,
      fallback: fallbackCount
    });
    figma.notify(resultMessage);

    if (failedImports.length > 0) {
      console.warn('[Color Generator] 라이브러리 토큰 임포트 실패 목록:', failedImports);
    }

    if (failedImports.length === total) {
      figma.ui.postMessage({
        type: 'library-sync-error',
        message: '라이브러리 변수 임포트가 모두 실패했습니다. Figma 변수 패널에서 라이브러리를 활성화했는지 확인해주세요.',
        failed: failedImports
      });
    }
  } catch (error) {
    console.error('[Backend] 라이브러리 동기화 실패:', error);
    figma.ui.postMessage({
      type: 'library-sync-error',
      message: error && error.message ? error.message : String(error)
    });
  }
}

// =====================================
// 색상 안전 레일 함수들 (네온/고채도 처리)
// =====================================

// HSL 채도 조정
function setSaturation(hex, targetSaturation, hue) {
  var hsl = hexToHsl(hex);
  
  // 색상별 채도 부스트
  var boostFactor = 1.0;
  
  if (hue >= 0 && hue <= 30) {         // 빨강
    boostFactor = 1.3;
  } else if (hue >= 30 && hue <= 60) { // 주황
    boostFactor = 1.2;
  } else if (hue >= 60 && hue <= 120) { // 초록
    boostFactor = 1.4;
  } else if (hue >= 180 && hue <= 240) { // 파랑
    boostFactor = 1.4;
  } else if (hue >= 240 && hue <= 300) { // 보라
    boostFactor = 1.35;
  }
  
  var adjustedSaturation = Math.min(targetSaturation * boostFactor, 100);
  hsl[1] = Math.min(hsl[1], adjustedSaturation);
  
  return hslToHex(hsl[0], hsl[1], hsl[2]);
}

// 네온 색상 감지
function isNeon(hex) {
  var hsl = hexToHsl(hex);
  var L = hsl[2];
  var S = hsl[1];
  
  // 매우 밝고(L≥85) 채도가 높은(S≥60) 경우 네온으로 간주
  if (L >= 85 && S >= 60) {
    return true;
  }
  
  // 추가 조건: 매우 밝은 노랑/녹색 계열
  var H = hsl[0];
  if (L >= 80 && S >= 40 && (H >= 50 && H <= 150)) {
    return true;
  }
  
  return false;
}

// Y값 계산 (sRGB relative luminance, 0~1)
function getYValue(hex) {
  var rgb = hexToRgb(hex);
  return relativeLuminance(rgb);
}

// =====================================
// WCAG 대비비율 계산 함수들
// =====================================

// sRGB를 선형 RGB로 변환
function srgbToLinear(n) {
  // n은 0-1 범위
  if (n <= 0.03928) {
    return n / 12.92;
  } else {
    return Math.pow((n + 0.055) / 1.055, 2.4);
  }
}

// 상대 휘도 계산
function relativeLuminance(rgb) {
  // rgb는 0-255 범위
  var r = srgbToLinear(rgb.r / 255);
  var g = srgbToLinear(rgb.g / 255);
  var b = srgbToLinear(rgb.b / 255);
  
  return 0.2126 * r + 0.7152 * g + 0.0722 * b;
}

// 대비비율 계산
function contrastRatio(hex1, hex2) {
  var rgb1 = hexToRgb(hex1);
  var rgb2 = hexToRgb(hex2);
  
  var l1 = relativeLuminance(rgb1);
  var l2 = relativeLuminance(rgb2);
  
  var lighter = Math.max(l1, l2);
  var darker = Math.min(l1, l2);
  
  return (lighter + 0.05) / (darker + 0.05);
}

// =====================================
// 유틸리티 함수들
// =====================================

// HEX를 RGB로 변환
function hexToRgb(hex) {
  var cleanHex = hex.replace('#', '');
  
  // 3자리 HEX 처리
  if (cleanHex.length === 3) {
    cleanHex = cleanHex.split('').map(function(char) { 
      return char + char; 
    }).join('');
  }
  
  // 8자리 HEX인 경우 앞 6자리만 사용
  if (cleanHex.length === 8) {
    cleanHex = cleanHex.substring(0, 6);
  }
  
  var result = /^([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(cleanHex);
  if (!result) {
    return { r: 0, g: 0, b: 0 };
  }
  
  return {
    r: parseInt(result[1], 16),
    g: parseInt(result[2], 16),
    b: parseInt(result[3], 16)
  };
}

// Figma RGB 변환
function hexToFigmaRGB(hex) {
  var cleanHex = hex.replace('#', '');
  
  if (cleanHex.length === 3) {
    cleanHex = cleanHex.split('').map(function(char) { 
      return char + char; 
    }).join('');
  }
  
  var result = /^([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(cleanHex);
  if (!result) {
    return { r: 0, g: 0, b: 0 };
  }
  
  return {
    r: parseInt(result[1], 16) / 255,
    g: parseInt(result[2], 16) / 255,
    b: parseInt(result[3], 16) / 255
  };
}

function parseColorValue(value) {
  if (typeof value !== 'string') {
    return null;
  }
  value = value.trim();
  if (value.startsWith('#')) {
    var cleanHex = value.replace('#', '');
    var alpha = 1;
    if (cleanHex.length === 8) {
      alpha = parseInt(cleanHex.slice(6, 8), 16) / 255;
      cleanHex = cleanHex.slice(0, 6);
    }
    var rgb = hexToFigmaRGB('#' + cleanHex);
    return { r: rgb.r, g: rgb.g, b: rgb.b, a: alpha };
  }
  var rgbaMatch = value.match(/rgba?\(([^)]+)\)/i);
  if (rgbaMatch) {
    var parts = rgbaMatch[1].split(',').map(function(part) { return part.trim(); });
    var r = parseFloat(parts[0]);
    var g = parseFloat(parts[1]);
    var b = parseFloat(parts[2]);
    var a = parts.length > 3 ? parseFloat(parts[3]) : 1;
    if (isNaN(r) || isNaN(g) || isNaN(b) || isNaN(a)) {
      return null;
    }
    return {
      r: Math.max(0, Math.min(1, r / 255)),
      g: Math.max(0, Math.min(1, g / 255)),
      b: Math.max(0, Math.min(1, b / 255)),
      a: Math.max(0, Math.min(1, a))
    };
  }
  return null;
}

function figmaRGBComponentTo255(value) {
  if (typeof value !== 'number' || isNaN(value)) return 0;
  if (value > 1) {
    return Math.max(0, Math.min(255, Math.round(value)));
  }
  return Math.max(0, Math.min(255, Math.round(value * 255)));
}

function figmaRGBToHex(color) {
  if (!color) return '#000000';
  var r = figmaRGBComponentTo255(color.r);
  var g = figmaRGBComponentTo255(color.g);
  var b = figmaRGBComponentTo255(color.b);
  return '#' + [r, g, b].map(function(component) {
    var hex = component.toString(16).toUpperCase();
    return hex.length === 1 ? '0' + hex : hex;
  }).join('');
}

// HSL 변환 함수들
function hexToHsl(hex) {
  var r = parseInt(hex.slice(1, 3), 16) / 255;
  var g = parseInt(hex.slice(3, 5), 16) / 255;
  var b = parseInt(hex.slice(5, 7), 16) / 255;

  var max = Math.max(r, g, b);
  var min = Math.min(r, g, b);
  var h, s, l = (max + min) / 2;

  if (max === min) {
    h = s = 0;
  } else {
    var d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r: h = (g - b) / d + (g < b ? 6 : 0); break;
      case g: h = (b - r) / d + 2; break;
      case b: h = (r - g) / d + 4; break;
    }
    h /= 6;
  }

  return [h * 360, s * 100, l * 100];
}

function hslToHex(h, s, l) {
  h = h % 360;
  if (h < 0) h += 360;
  s = Math.max(0, Math.min(100, s));
  l = Math.max(0, Math.min(100, l));
  
  h /= 360;
  s /= 100;
  l /= 100;
  
  var a = s * Math.min(l, 1 - l);
  var f = function(n) {
    var k = (n + h * 12) % 12;
    return l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
  };
  
  var r = Math.round(f(0) * 255);
  var g = Math.round(f(8) * 255);
  var b = Math.round(f(4) * 255);
  
  return "#" + [r, g, b].map(function(x) {
    var hex = x.toString(16);
    return hex.length === 1 ? "0" + hex : hex;
  }).join("");
}

// =====================================
// Figma 변수 관련 함수들
// =====================================

// 변수 찾기/생성
async function findOrCreateVariable(name, collection, type) {
  var existingVars = await figma.variables.getLocalVariablesAsync(type);
  var existing = existingVars.find(function(v) {
    return v.name === name && v.variableCollectionId === collection.id;
  });
  
  if (existing) {
    return existing;
  } else {
    return figma.variables.createVariable(name, collection, type);
  }
}

// 모드 찾기/생성
function findOrCreateMode(collection, modeName) {
  var existingMode = collection.modes.find(function(mode) { 
    return mode.name === modeName; 
  });
  if (existingMode) {
    return existingMode.modeId;
  } else {
    return collection.addMode(modeName);
  }
}

// 가장 가까운 step 찾기 (모드별 독립 계산)
function findClosestStep(scaleColors, inputHex) {
  var inputHsl = hexToHsl(inputHex);
  var inputLightness = inputHsl[2];
  var closestStep = 500;
  var minDifference = Infinity;
  
  // 실제 생성된 색상들의 명도와 비교
  for (var i = 0; i < scaleColors.length; i++) {
    var step = scaleColors[i].step;
    var stepHex = scaleColors[i].hex;  // 실제 생성된 색상
    var stepHsl = hexToHsl(stepHex);
    var stepLightness = stepHsl[2];    // 실제 색상의 명도
    
    // 입력 색상과 실제 스케일 색상의 명도 차이 비교
    var diff = Math.abs(inputLightness - stepLightness);
    
    if (diff < minDifference) {
      minDifference = diff;
      closestStep = step;
    }
  }
  
  return closestStep;
}

// 단계 조정 헬퍼 함수 (±단계 이동 with 클램핑)
function adjustStep(currentStep, adjustment) {
  var steps = [50, 75, 100, 150, 200, 300, 400, 500, 600, 700, 800, 900, 950];
  var currentIndex = steps.indexOf(currentStep);

  if (currentIndex === -1) {
    // 현재 단계를 찾을 수 없으면 가장 가까운 단계 찾기
    var minDiff = Infinity;
    for (var i = 0; i < steps.length; i++) {
      var diff = Math.abs(steps[i] - currentStep);
      if (diff < minDiff) {
        minDiff = diff;
        currentIndex = i;
      }
    }
  }
  
  var newIndex = currentIndex + adjustment;
  
  // 클램핑: 50-950 범위 내로 제한
  if (newIndex < 0) {
    return steps[0]; // 50
  }
  if (newIndex >= steps.length) {
    return steps[steps.length - 1]; // 950
  }

  return steps[newIndex];
}

function getCustomBackgroundScaleInfo(theme) {
  if (!theme) {
    return { scaleColors: [], themeName: '' };
  }

  if (
    theme.backgroundTheme &&
    theme.backgroundTheme.scaleColors &&
    Array.isArray(theme.backgroundTheme.scaleColors.light) &&
    theme.backgroundTheme.scaleColors.light.length > 0
  ) {
    return {
      scaleColors: theme.backgroundTheme.scaleColors.light,
      themeName: theme.backgroundTheme.themeName || theme.themeName
    };
  }

  if (theme.scaleColors && Array.isArray(theme.scaleColors.light)) {
    return {
      scaleColors: theme.scaleColors.light,
      themeName: theme.themeName
    };
  }

  return { scaleColors: [], themeName: theme.themeName };
}

function resolveCustomSilentColor(theme, mappingValue) {
  if (!theme || !theme.customBackgroundColor) return null;

  var scaleInfo = getCustomBackgroundScaleInfo(theme);
  var scale = scaleInfo.scaleColors;
  var baseHex = theme.customBackgroundColor;
  var result = {
    hex: baseHex,
    step: null,
    themeName: scaleInfo.themeName
  };

  if (Array.isArray(scale) && scale.length > 0) {
    var baseStep = findClosestStep(scale, baseHex);
    if (typeof baseStep === 'number' && !isNaN(baseStep)) {
      result.step = baseStep;
    }

    if (mappingValue !== 'CUSTOM_SILENT' && result.step !== null) {
      var luminance = getPerceptualLuminance(baseHex);
      var direction = luminance >= 0.5 ? -1 : 1;
      var magnitude = (mappingValue === 'CUSTOM_SILENT_PRESSED') ? 2 : 1;
      var targetStep = adjustStep(result.step, direction * magnitude);
      var entry = scale.find(function(color) { return color.step === targetStep; });

      if (entry && entry.hex) {
        result.hex = entry.hex;
        result.step = targetStep;
      } else {
        var hsl = hexToHsl(baseHex);
        var adjL = Math.max(0, Math.min(100, hsl[2] + direction * magnitude * 5));
        result.hex = hslToHex(hsl[0], hsl[1], adjL);
        result.step = targetStep;
      }
    }
  } else if (mappingValue !== 'CUSTOM_SILENT') {
    var hslBase = hexToHsl(baseHex);
    var luminanceBase = getPerceptualLuminance(baseHex);
    var dir = luminanceBase >= 0.5 ? -1 : 1;
    var mag = (mappingValue === 'CUSTOM_SILENT_PRESSED') ? 2 : 1;
    var adjustedL = Math.max(0, Math.min(100, hslBase[2] + dir * mag * 5));
    result.hex = hslToHex(hslBase[0], hslBase[1], adjustedL);
  }

  return result;
}

function resolveCustomBackgroundLowColor(theme, mappingValue) {
  if (!theme || !theme.customBackgroundColor) return null;

  var scaleInfo = getCustomBackgroundScaleInfo(theme);
  var scale = scaleInfo.scaleColors;
  var result = {
    hex: theme.customBackgroundColor,
    step: null,
    themeName: scaleInfo.themeName
  };

  if (!mappingValue) {
    return result;
  }

  var parts = mappingValue.split(':');
  var targetStep = null;
  if (parts.length > 1) {
    var parsed = parseInt(parts[1], 10);
    if (!isNaN(parsed)) {
      targetStep = parsed;
    }
  }

  if (Array.isArray(scale) && scale.length > 0 && targetStep) {
    var entry = scale.find(function(color) { return color.step === targetStep; });
    if (!entry) {
      entry = scale.reduce(function(prev, curr) {
        if (!prev) return curr;
        return Math.abs(curr.step - targetStep) < Math.abs(prev.step - targetStep) ? curr : prev;
      }, null);
    }
    if (entry && entry.hex) {
      result.hex = entry.hex;
      result.step = entry.step;
    }
  }

  return result;
}

function resolveCustomBackgroundAlpha(theme, mappingValue) {
  if (!theme || !theme.customBackgroundColor) return null;

  var parts = mappingValue.split(':');
  var target = parts.length > 1 ? parseInt(parts[1], 10) : 100;
  if (isNaN(target)) target = 100;

  // 기본 알파 스케일(0~1000)을 0~1 범위로 변환
  var opacity = Math.max(0, Math.min(1, target / 1000));
  var rgb = hexToFigmaRGB(theme.customBackgroundColor);

  return {
    color: rgb,
    opacity: opacity
  };
}

function getPerceptualLuminance(hex) {
  var rgb = hexToRgb(hex);
  if (!rgb) return 0;

  function toLinear(value) {
    var normalized = value / 255;
    return normalized <= 0.03928
      ? normalized / 12.92
      : Math.pow((normalized + 0.055) / 1.055, 2.4);
  }

  var r = toLinear(rgb.r);
  var g = toLinear(rgb.g);
  var b = toLinear(rgb.b);

  return 0.2126 * r + 0.7152 * g + 0.0722 * b;
}

function getHueBrightness(hue, saturation, lightness) {
  if (saturation < 20) {
    if (lightness >= 70) return 'very-bright';
    if (lightness >= 50) return 'bright';
    if (lightness >= 30) return 'medium';
    return 'dark';
  }

  if (lightness >= 80) return 'very-bright';
  if (lightness <= 20) return 'dark';

  var base;

  if ((hue >= 50 && hue <= 70) || (hue >= 170 && hue <= 190)) {
    base = 'very-bright';
  } else if ((hue >= 30 && hue <= 50) || (hue >= 70 && hue <= 170)) {
    base = 'bright';
  } else if ((hue >= 210 && hue <= 270) || (hue >= 0 && hue <= 20) || hue >= 300) {
    base = 'dark';
  } else {
    base = 'medium';
  }

  if (saturation > 80) {
    if (base === 'dark') base = 'medium';
    else if (base === 'medium') base = 'bright';
  } else if (saturation < 40) {
    if (base === 'very-bright') base = 'bright';
    else if (base === 'bright') base = 'medium';
  }

  if (lightness > 65 && base === 'medium') return 'bright';
  if (lightness < 35 && base === 'medium') return 'dark';

  return base;
}

function assessColorRange(closestStep, baseColor) {
  var info = {
    isInherentlyBright: false,
    colorRange: 'medium',
    luminance: 0,
    hueBrightness: 'medium'
  };

  if (!baseColor) {
    return info;
  }

  var hsl = hexToHsl(baseColor);
  var hue = hsl[0];
  var saturation = hsl[1];
  var lightness = hsl[2];
  var luminance = getPerceptualLuminance(baseColor);
  var hueBrightness = getHueBrightness(hue, saturation, lightness);

  info.luminance = luminance;
  info.hueBrightness = hueBrightness;

  var isInherentlyBright = false;

  if (luminance > 0.5) {
    isInherentlyBright = true;
  } else if (luminance > 0.3) {
    isInherentlyBright = (hueBrightness === 'very-bright' || hueBrightness === 'bright');
  } else {
    isInherentlyBright = false;
  }

  info.isInherentlyBright = isInherentlyBright;

  if (isInherentlyBright) {
    if (closestStep <= 400) {
      info.colorRange = 'light';
    } else if (closestStep >= 500 && closestStep <= 700) {
      info.colorRange = 'medium';
    } else {
      info.colorRange = 'dark';
    }
  } else {
    if (closestStep <= 400) {
      info.colorRange = 'light';
    } else if (closestStep >= 500 && closestStep <= 700) {
      info.colorRange = 'medium';
    } else {
      info.colorRange = 'dark';
    }
  }

  return info;
}

// =====================================
// 동적 매핑 함수들
// =====================================

// 통합 동적 매핑 함수
function getDynamicMappings(closestStep, themeName, applicationMode, baseColor) {
  var mappings = {};
  
  console.log('[Backend] getDynamicMappings 호출됨 - closestStep:', closestStep, 'applicationMode:', applicationMode, 'baseColor:', baseColor);
  
  var colorInfo = assessColorRange(closestStep, baseColor);
  var isInherentlyBright = colorInfo.isInherentlyBright;
  var colorRange = colorInfo.colorRange;
  
  console.log('[Backend] 본질적 밝기 판단 - isInherentlyBright:', isInherentlyBright);
  console.log('[Backend] 결정된 색상 범위 - colorRange:', colorRange, 'closestStep:', closestStep);
  
  
  // 기존 호환성을 위한 변수
  var isLightRange = colorRange === 'light';
  

  // =====================================
  // Mode: accent-on-bg-off (foreground emphasis)
  // =====================================
  if (applicationMode === 'accent-on-bg-off') {
    console.log('[Backend] accent-on-bg-off 적용 - colorRange:', colorRange);
    if (colorRange === 'light') {
      // 밝은 범위 (Step≤400 OR L≥80% OR BornBright(40°≤H≤190°))
      mappings['semantic/text/primary'] = 'STATIC-WHITE-ALPHA:900';
      mappings['semantic/text/secondary'] = 'STATIC-WHITE-ALPHA:700';
      mappings['semantic/text/tertiary'] = 'STATIC-WHITE-ALPHA:600';
      mappings['semantic/text/disabled'] = 'STATIC-WHITE-ALPHA:500';
      mappings['semantic/text/on-color'] = 'GRAY:900';
      
      mappings['semantic/background/default'] = 'REF:' + themeName + '600';
      mappings['semantic/background/gradient-default'] = 'REF:' + themeName + closestStep;
      mappings['semantic/fill/surface-contents'] = 'STATIC-WHITE-ALPHA:200';

      mappings['semantic/fill/primary'] = 'REF:' + themeName + closestStep;
      mappings['semantic/fill/primary-hover'] = 'REF:' + themeName + adjustStep(closestStep, 1);
      mappings['semantic/fill/primary-pressed'] = 'REF:' + themeName + adjustStep(closestStep, 1);
      
      mappings['semantic/border/divider-strong'] = 'STATIC-WHITE-ALPHA:900';
      mappings['semantic/border/line-selected'] = 'STATIC-WHITE-ALPHA:900';
      mappings['semantic/border/divider'] = 'STATIC-WHITE-ALPHA:200';
      mappings['semantic/border/line'] = 'STATIC-WHITE-ALPHA:300';
      mappings['semantic/border/line-disabled'] = 'STATIC-WHITE-ALPHA:200';
      
      mappings['semantic/fill/silent'] = 'REF:' + themeName + '600';
      mappings['semantic/fill/silent-hover'] = 'REF:' + themeName + '500';
      mappings['semantic/fill/silent-pressed'] = 'REF:' + themeName + '500';
      
      mappings['semantic/common/accent'] = 'ORANGE-RED-300';
      mappings['semantic/common/accent-pressed'] = 'ORANGE-RED-400';
      mappings['semantic/common/accent-hover'] = 'ORANGE-RED-400';
      mappings['semantic/common/muted'] = 'STATIC-WHITE-ALPHA:400';
      
      mappings['semantic/common/custom-accent'] = 'REF:' + themeName + closestStep;
      mappings['semantic/common/custom-accent-low'] = 'REF:' + themeName + '500';
      
      mappings['semantic/fill/tertiary'] = 'STATIC-WHITE-ALPHA:400';
      mappings['semantic/fill/tertiary-hover'] = 'STATIC-WHITE-ALPHA:300';
      mappings['semantic/fill/tertiary-pressed'] = 'STATIC-WHITE-ALPHA:300';
      mappings['semantic/fill/disabled'] = 'STATIC-WHITE-ALPHA:200';
      
    } else if (colorRange === 'medium') {
      // 중간 범위 (Step 500-700)
      mappings['semantic/text/primary'] = 'GRAY:900';
      mappings['semantic/text/secondary'] = 'GRAY-ALPHA:700';
      mappings['semantic/text/tertiary'] = 'GRAY-ALPHA:600';
      mappings['semantic/text/disabled'] = 'GRAY-ALPHA:400';
      mappings['semantic/text/on-color'] = 'GRAY:50';
      
      mappings['semantic/background/default'] = 'REF:' + themeName + '100';
      mappings['semantic/background/gradient-default'] = 'REF:' + themeName + closestStep;
      mappings['semantic/fill/surface-contents'] = 'GRAY-ALPHA:75';

      mappings['semantic/fill/primary'] = 'REF:' + themeName + closestStep;
      mappings['semantic/fill/primary-hover'] = 'REF:' + themeName + adjustStep(closestStep, -1);
      mappings['semantic/fill/primary-pressed'] = 'REF:' + themeName + adjustStep(closestStep, -1);

      mappings['semantic/border/divider-strong'] = 'GRAY:950';
      mappings['semantic/border/line-selected'] = 'GRAY:950';
      mappings['semantic/border/divider'] = 'GRAY-ALPHA:200';
      mappings['semantic/border/line'] = 'GRAY-ALPHA:300';
      mappings['semantic/border/line-disabled'] = 'GRAY-ALPHA:200';
      
      mappings['semantic/fill/silent'] = 'REF:' + themeName + '100';
      mappings['semantic/fill/silent-hover'] = 'REF:' + themeName + '150';
      mappings['semantic/fill/silent-pressed'] = 'REF:' + themeName + '150';
      
      mappings['semantic/common/accent'] = 'ORANGE-RED-400';
      mappings['semantic/common/accent-pressed'] = 'ORANGE-RED-500';
      mappings['semantic/common/accent-hover'] = 'ORANGE-RED-500';
      mappings['semantic/common/muted'] = 'GRAY-ALPHA:300';
      mappings['semantic/common/custom-accent'] = 'REF:' + themeName + closestStep;
      mappings['semantic/common/custom-accent-low'] = 'REF:' + themeName + 50;

      mappings['semantic/fill/tertiary'] = 'GRAY-ALPHA:300';
      mappings['semantic/fill/tertiary-hover'] = 'GRAY-ALPHA:400';
      mappings['semantic/fill/tertiary-pressed'] = 'GRAY-ALPHA:400';
      mappings['semantic/fill/disabled'] = 'GRAY-ALPHA:200';
      
    } else {
      // 어두운 범위 (Step 700-950)
      mappings['semantic/text/primary'] = 'GRAY:900';
      mappings['semantic/text/secondary'] = 'GRAY-ALPHA:700';
      mappings['semantic/text/tertiary'] = 'GRAY-ALPHA:600';
      mappings['semantic/text/disabled'] = 'GRAY-ALPHA:400';
      mappings['semantic/text/on-color'] = 'GRAY:50';
      
      mappings['semantic/background/default'] = 'REF:' + themeName + '100';
      mappings['semantic/background/gradient-default'] = 'REF:' + themeName + closestStep;
      mappings['semantic/fill/surface-contents'] = 'GRAY-ALPHA:75';

      mappings['semantic/fill/primary'] = 'REF:' + themeName + closestStep;
      mappings['semantic/fill/primary-hover'] = 'REF:' + themeName + adjustStep(closestStep, -1);
      mappings['semantic/fill/primary-pressed'] = 'REF:' + themeName + adjustStep(closestStep, -1);

      mappings['semantic/border/divider-strong'] = 'GRAY:950';
      mappings['semantic/border/line-selected'] = 'GRAY:950';
      mappings['semantic/border/divider'] = 'GRAY-ALPHA:200';
      mappings['semantic/border/line'] = 'GRAY-ALPHA:300';
      mappings['semantic/border/line-disabled'] = 'GRAY-ALPHA:200';
      
      mappings['semantic/fill/silent'] = 'REF:' + themeName + '100';
      mappings['semantic/fill/silent-hover'] = 'REF:' + themeName + '150';
      mappings['semantic/fill/silent-pressed'] = 'REF:' + themeName + '150';
      
      mappings['semantic/common/accent'] = 'ORANGE-RED-400';
      mappings['semantic/common/accent-pressed'] = 'ORANGE-RED-500';
      mappings['semantic/common/accent-hover'] = 'ORANGE-RED-500';
      mappings['semantic/common/muted'] = 'GRAY-ALPHA:300';
      mappings['semantic/common/custom-accent'] = 'REF:' + themeName + closestStep;
      mappings['semantic/common/custom-accent-low'] = 'REF:' + themeName + 50;

      mappings['semantic/fill/tertiary'] = 'GRAY-ALPHA:300';
      mappings['semantic/fill/tertiary-hover'] = 'GRAY-ALPHA:400';
      mappings['semantic/fill/tertiary-pressed'] = 'GRAY-ALPHA:400';
      mappings['semantic/fill/disabled'] = 'GRAY-ALPHA:200';
    }
    
  // =====================================
  // Mode: accent-on-bg-fixed (foreground on white background)
  // =====================================
  } else if (applicationMode === 'accent-on-bg-fixed') {
    console.log('[Backend] accent-on-bg-fixed 적용 - colorRange:', colorRange);
    mappings['semantic/background/default'] = 'GRAY:50';
    
    if (colorRange === 'light') {
      // 밝은 범위 (Step≤300 OR L≥80% OR BornBright(40°≤H≤190°))
      mappings['semantic/text/primary'] = 'GRAY:900';
      mappings['semantic/text/secondary'] = 'GRAY:700';
      mappings['semantic/text/tertiary'] = 'GRAY:600';
      mappings['semantic/text/disabled'] = 'GRAY:400';
      mappings['semantic/text/on-color'] = 'GRAY:900';

      mappings['semantic/background/gradient-default'] = 'REF:' + themeName + closestStep;
      mappings['semantic/fill/surface-contents'] = 'GRAY-ALPHA:75';
      mappings['semantic/shadow/default'] = 'ALPHA:' + themeName + '100'

      mappings['semantic/fill/primary'] = 'REF:' + themeName + closestStep;
      mappings['semantic/fill/primary-hover'] = 'REF:' + themeName + adjustStep(closestStep, 1);
      mappings['semantic/fill/primary-pressed'] = 'REF:' + themeName + adjustStep(closestStep, 1);
      
      mappings['semantic/border/divider-strong'] = 'GRAY:950';
      mappings['semantic/border/line-selected'] = 'GRAY:900';
      mappings['semantic/border/divider'] = 'GRAY-ALPHA:100';
      mappings['semantic/border/line'] = 'GRAY:200';
      mappings['semantic/border/line-disabled'] = 'GRAY-ALPHA:200';
      
      mappings['semantic/fill/silent'] = 'GRAY:50';
      mappings['semantic/fill/silent-hover'] = 'GRAY:75';
      mappings['semantic/fill/silent-pressed'] = 'GRAY:75';
      
      mappings['semantic/common/accent'] = 'ORANGE-RED-400';
      mappings['semantic/common/accent-pressed'] = 'ORANGE-RED-500';
      mappings['semantic/common/accent-hover'] = 'ORANGE-RED-500';
      mappings['semantic/common/muted'] = 'GRAY:300';

      mappings['semantic/common/custom-accent'] = 'REF:' + themeName + 500;
      mappings['semantic/common/custom-accent-low'] = 'REF:' + themeName + 50;
      
    } else if (colorRange === 'medium') {
      // 중간 범위 (Step 500-700)
      mappings['semantic/text/primary'] = 'GRAY:900';
      mappings['semantic/text/secondary'] = 'GRAY:700';
      mappings['semantic/text/tertiary'] = 'GRAY:600';
      mappings['semantic/text/disabled'] = 'GRAY:400';
      mappings['semantic/text/on-color'] = 'GRAY:50';
      
      mappings['semantic/background/gradient-default'] = 'REF:' + themeName + adjustStep(closestStep, 1);
      mappings['semantic/fill/surface-contents'] = 'GRAY-ALPHA:75';
      mappings['semantic/shadow/default'] = 'ALPHA:' + themeName + '100'

      mappings['semantic/fill/primary'] = 'REF:' + themeName + closestStep;
      mappings['semantic/fill/primary-hover'] = 'REF:' + themeName + adjustStep(closestStep, -1);
      mappings['semantic/fill/primary-pressed'] = 'REF:' + themeName + adjustStep(closestStep, -1);
      
      mappings['semantic/border/divider-strong'] = 'GRAY:950';
      mappings['semantic/border/line-selected'] = 'GRAY:900';
      mappings['semantic/border/divider'] = 'GRAY-ALPHA:100';
      mappings['semantic/border/line'] = 'GRAY:200';
      mappings['semantic/border/line-disabled'] = 'GRAY-ALPHA:200';
      
      mappings['semantic/fill/silent'] = 'GRAY:50';
      mappings['semantic/fill/silent-hover'] = 'GRAY:75';
      mappings['semantic/fill/silent-pressed'] = 'GRAY:75';
      
      mappings['semantic/common/accent'] = 'ORANGE-RED-400';
      mappings['semantic/common/accent-pressed'] = 'ORANGE-RED-500';
      mappings['semantic/common/accent-hover'] = 'ORANGE-RED-500';
      mappings['semantic/common/muted'] = 'GRAY:300';

      mappings['semantic/common/custom-accent'] = 'REF:' + themeName + closestStep;
      mappings['semantic/common/custom-accent-low'] = 'REF:' + themeName + 50;
      
    } else {
      // 어두운 범위 (Step 700-950)
      mappings['semantic/text/primary'] = 'GRAY:900';
      mappings['semantic/text/secondary'] = 'GRAY:700';
      mappings['semantic/text/tertiary'] = 'GRAY:600';
      mappings['semantic/text/disabled'] = 'GRAY:400';
      mappings['semantic/text/on-color'] = 'GRAY:50';
      
      mappings['semantic/background/gradient-default'] = 'REF:' + themeName + closestStep;
      mappings['semantic/fill/surface-contents'] = 'GRAY-ALPHA:75';
      mappings['semantic/shadow/default'] = 'ALPHA:' + themeName + '100'

      mappings['semantic/fill/primary'] = 'REF:' + themeName + closestStep;
      mappings['semantic/fill/primary-hover'] = 'REF:' + themeName + adjustStep(closestStep, -1);
      mappings['semantic/fill/primary-pressed'] = 'REF:' + themeName + adjustStep(closestStep, -1);
      
      mappings['semantic/border/divider-strong'] = 'GRAY:950';
      mappings['semantic/border/line-selected'] = 'REF:' + themeName + closestStep;
      mappings['semantic/border/divider'] = 'GRAY-ALPHA:100';
      mappings['semantic/border/line'] = 'GRAY:200';
      mappings['semantic/border/line-disabled'] = 'GRAY-ALPHA:200';
      
      mappings['semantic/fill/silent'] = 'GRAY:50';
      mappings['semantic/fill/silent-hover'] = 'GRAY:75';
      mappings['semantic/fill/silent-pressed'] = 'GRAY:75';
      
      mappings['semantic/common/accent'] = 'ORANGE-RED-400';
      mappings['semantic/common/accent-pressed'] = 'ORANGE-RED-500';
      mappings['semantic/common/accent-hover'] = 'ORANGE-RED-500';
      mappings['semantic/common/muted'] = 'GRAY:300';
      mappings['semantic/common/custom-accent'] = 'REF:' + themeName + closestStep;
      mappings['semantic/common/custom-accent-low'] = 'REF:' + themeName + 50;
    }
  
  // =====================================
  // Mode: accent-on-bg-black (foreground on black background)
  // =====================================
  } else if (applicationMode === 'accent-on-bg-black') {
    console.log('[Backend] accent-on-bg-black 적용 - colorRange:', colorRange);
    // 배경은 항상 black으로 고정
    mappings['semantic/background/default'] = 'GRAY:950';
    
    if (colorRange === 'light') {
      // 밝은 범위
      mappings['semantic/text/primary'] = 'STATIC-WHITE-ALPHA:900';
      mappings['semantic/text/secondary'] = 'STATIC-WHITE-ALPHA:700';
      mappings['semantic/text/tertiary'] = 'STATIC-WHITE-ALPHA:600';
      mappings['semantic/text/disabled'] = 'STATIC-WHITE-ALPHA:500';
      mappings['semantic/text/on-color'] = 'GRAY:900';
      
      mappings['semantic/background/gradient-default'] = 'REF:' + themeName + closestStep;
      mappings['semantic/fill/surface-contents'] = 'STATIC-WHITE-ALPHA:200';

      mappings['semantic/fill/primary'] = 'REF:' + themeName + closestStep;
      mappings['semantic/fill/primary-hover'] = 'REF:' + themeName + adjustStep(closestStep, 1);
      mappings['semantic/fill/primary-pressed'] = 'REF:' + themeName + adjustStep(closestStep, 1);
      
      mappings['semantic/border/divider-strong'] =  'STATIC-WHITE-ALPHA:900';
      mappings['semantic/border/line-selected'] =  'STATIC-WHITE-ALPHA:900';
      mappings['semantic/border/divider'] = 'STATIC-WHITE-ALPHA:200';
      mappings['semantic/border/line'] = 'STATIC-WHITE-ALPHA:300';
      mappings['semantic/border/line-disabled'] = 'STATIC-WHITE-ALPHA:200';
      
      mappings['semantic/fill/silent'] = 'GRAY:950';
      mappings['semantic/fill/silent-hover'] = 'GRAY:900';
      mappings['semantic/fill/silent-pressed'] = 'GRAY:900';
      
      mappings['semantic/common/accent'] = 'ORANGE-RED-400';
      mappings['semantic/common/accent-pressed'] = 'ORANGE-RED-300';
      mappings['semantic/common/accent-hover'] = 'ORANGE-RED-300';
      mappings['semantic/common/muted'] = 'STATIC-WHITE-ALPHA:400';

      mappings['semantic/common/custom-accent'] = 'REF:' + themeName + 500;
      mappings['semantic/common/custom-accent-low'] = 'REF:' + themeName + 900;

      mappings['semantic/fill/tertiary'] = 'STATIC-WHITE-ALPHA:400';
      mappings['semantic/fill/tertiary-hover'] = 'STATIC-WHITE-ALPHA:300';
      mappings['semantic/fill/tertiary-pressed'] = 'STATIC-WHITE-ALPHA:300';
      mappings['semantic/fill/disabled'] = 'STATIC-WHITE-ALPHA:200';
      
    } else if (colorRange === 'medium') {
      mappings['semantic/text/primary'] = 'STATIC-WHITE-ALPHA:900';
      mappings['semantic/text/secondary'] = 'STATIC-WHITE-ALPHA:700';
      mappings['semantic/text/tertiary'] = 'STATIC-WHITE-ALPHA:600';
      mappings['semantic/text/disabled'] = 'STATIC-WHITE-ALPHA:500';
      mappings['semantic/text/on-color'] = 'GRAY:50';
       
      mappings['semantic/background/gradient-default'] = 'REF:' + themeName + closestStep;
      mappings['semantic/fill/surface-contents'] = 'STATIC-WHITE-ALPHA:200';

      mappings['semantic/fill/primary'] = 'REF:' + themeName + closestStep;
      mappings['semantic/fill/primary-hover'] = 'REF:' + themeName + adjustStep(closestStep, -1);
      mappings['semantic/fill/primary-pressed'] = 'REF:' + themeName + adjustStep(closestStep, -1);
      
      mappings['semantic/border/divider-strong'] =  'STATIC-WHITE-ALPHA:900';
      mappings['semantic/border/line-selected'] =  'STATIC-WHITE-ALPHA:900';
      mappings['semantic/border/divider'] = 'STATIC-WHITE-ALPHA:200';
      mappings['semantic/border/line'] = 'STATIC-WHITE-ALPHA:300';
      mappings['semantic/border/line-disabled'] = 'STATIC-WHITE-ALPHA:200';
      
      mappings['semantic/fill/silent'] = 'GRAY:950';
      mappings['semantic/fill/silent-hover'] = 'GRAY:900';
      mappings['semantic/fill/silent-pressed'] = 'GRAY:900';
      
      mappings['semantic/common/accent'] = 'ORANGE-RED-400';
      mappings['semantic/common/accent-pressed'] = 'ORANGE-RED-300';
      mappings['semantic/common/accent-hover'] = 'ORANGE-RED-300';
      mappings['semantic/common/muted'] = 'STATIC-WHITE-ALPHA:400';

      mappings['semantic/common/custom-accent'] = 'REF:' + themeName + 500;
      mappings['semantic/common/custom-accent-low'] = 'REF:' + themeName + 900;

      mappings['semantic/fill/tertiary'] = 'STATIC-WHITE-ALPHA:400';
      mappings['semantic/fill/tertiary-hover'] = 'STATIC-WHITE-ALPHA:300';
      mappings['semantic/fill/tertiary-pressed'] = 'STATIC-WHITE-ALPHA:300';
      mappings['semantic/fill/disabled'] = 'STATIC-WHITE-ALPHA:200';
      
    } else {
      // 어두운 범위 (Step 700-950)
      mappings['semantic/text/primary'] = 'STATIC-WHITE-ALPHA:900';
      mappings['semantic/text/secondary'] = 'STATIC-WHITE-ALPHA:700';
      mappings['semantic/text/tertiary'] = 'STATIC-WHITE-ALPHA:600';
      mappings['semantic/text/disabled'] = 'STATIC-WHITE-ALPHA:500';
      mappings['semantic/text/on-color'] = 'GRAY:50';
      
      mappings['semantic/background/gradient-default'] = 'REF:' + themeName + closestStep;
      mappings['semantic/fill/surface-contents'] = 'STATIC-WHITE-ALPHA:200';

      mappings['semantic/fill/primary'] = 'REF:' + themeName + closestStep;
      mappings['semantic/fill/primary-hover'] = 'REF:' + themeName + adjustStep(closestStep, -1);
      mappings['semantic/fill/primary-pressed'] = 'REF:' + themeName + adjustStep(closestStep, -1);
      
      mappings['semantic/border/divider-strong'] =  'STATIC-WHITE-ALPHA:900';
      mappings['semantic/border/line-selected'] =  'STATIC-WHITE-ALPHA:900';
      mappings['semantic/border/divider'] = 'STATIC-WHITE-ALPHA:200';
      mappings['semantic/border/line'] = 'STATIC-WHITE-ALPHA:300';
      mappings['semantic/border/line-disabled'] = 'STATIC-WHITE-ALPHA:200';
      
      mappings['semantic/fill/silent'] = 'GRAY:950';
      mappings['semantic/fill/silent-hover'] = 'GRAY:900';
      mappings['semantic/fill/silent-pressed'] = 'GRAY:900';
      
      mappings['semantic/common/accent'] = 'ORANGE-RED-400';
      mappings['semantic/common/accent-pressed'] = 'ORANGE-RED-300';
      mappings['semantic/common/accent-hover'] = 'ORANGE-RED-300';
      mappings['semantic/common/muted'] = 'STATIC-WHITE-ALPHA:400';
      
      mappings['semantic/common/custom-accent'] = 'REF:' + themeName + closestStep;
      mappings['semantic/common/custom-accent-low'] = 'REF:' + themeName + 900;

      mappings['semantic/fill/tertiary'] = 'STATIC-WHITE-ALPHA:400';
      mappings['semantic/fill/tertiary-hover'] = 'STATIC-WHITE-ALPHA:300';
      mappings['semantic/fill/tertiary-pressed'] = 'STATIC-WHITE-ALPHA:300';
      mappings['semantic/fill/disabled'] = 'STATIC-WHITE-ALPHA:200';
    }
  
  // =====================================
  // Custom Background: 배경만 사용자 지정, 나머지는 기본 매핑 사용
  // =====================================
  } else if (applicationMode === 'custom-background') {
    console.log('[Backend] Custom Background 모드 실행');

    // 기본적으로 accent-on-bg-off 매핑을 사용하되, 배경만 사용자 지정
    if (colorRange === 'light') {
      mappings['semantic/text/primary'] = 'GRAY:50';
      mappings['semantic/text/secondary'] = 'GRAY:300';
      mappings['semantic/text/tertiary'] = 'GRAY:400';
      mappings['semantic/text/disabled'] = 'GRAY:600';
      mappings['semantic/text/on-color'] = 'GRAY:900';
      
      // 배경은 CUSTOM으로 표시 (나중에 handleApplyThemeColorsToFrame에서 처리)
      mappings['semantic/background/default'] = 'CUSTOM_BACKGROUND';
      mappings['semantic/fill/surface-contents'] = 'STATIC-WHITE-ALPHA:200';

      mappings['semantic/fill/primary'] = 'REF:' + themeName + closestStep;
      mappings['semantic/fill/primary-hover'] = 'REF:' + themeName + adjustStep(closestStep, 1);
      mappings['semantic/fill/primary-pressed'] = 'REF:' + themeName + adjustStep(closestStep, 1);
      
      mappings['semantic/border/divider-strong'] = 'GRAY:50';
      mappings['semantic/border/line-selected'] = 'GRAY:50';
      mappings['semantic/border/divider'] = 'STATIC-WHITE-ALPHA:200';
      mappings['semantic/border/line'] = 'STATIC-WHITE-ALPHA:300';
      mappings['semantic/border/line-disabled'] = 'STATIC-WHITE-ALPHA:200';
      
      // silent는 커스텀 배경 기반으로 UI에서 직접 계산하도록 특수 토큰 사용
      mappings['semantic/fill/silent'] = 'CUSTOM_SILENT';
      mappings['semantic/fill/silent-hover'] = 'CUSTOM_SILENT_HOVER';
      mappings['semantic/fill/silent-pressed'] = 'CUSTOM_SILENT_PRESSED';
      
      mappings['semantic/common/accent'] = 'ORANGE-RED-400';
      mappings['semantic/common/accent-pressed'] = 'ORANGE-RED-300';
      mappings['semantic/common/accent-hover'] = 'ORANGE-RED-300';
      mappings['semantic/common/muted'] = 'GRAY:700';
      
      mappings['semantic/common/custom-accent'] = 'REF:' + themeName + closestStep;
      mappings['semantic/common/custom-accent-low'] = 'CUSTOM_BACKGROUND_LOW:900';
      
      mappings['semantic/fill/tertiary'] = 'STATIC-WHITE-ALPHA:200';
      mappings['semantic/fill/tertiary-hover'] = 'STATIC-WHITE-ALPHA:100';
      mappings['semantic/fill/tertiary-pressed'] = 'STATIC-WHITE-ALPHA:100'
      mappings['semantic/fill/disabled'] = 'STATIC-WHITE-ALPHA:100';
      
    } else {
      // 어두운 범위도 accent-on-bg-off 로직을 재사용
      mappings['semantic/text/primary'] = 'GRAY:900';
      mappings['semantic/text/secondary'] = 'GRAY:700';
      mappings['semantic/text/tertiary'] = 'GRAY:600';
      mappings['semantic/text/disabled'] = 'GRAY:400';
      mappings['semantic/text/on-color'] = 'GRAY:50';
      
      mappings['semantic/background/default'] = 'CUSTOM_BACKGROUND';
      mappings['semantic/fill/surface-contents'] = 'GRAY-ALPHA:100';

      mappings['semantic/fill/primary'] = 'REF:' + themeName + closestStep;
      mappings['semantic/fill/primary-hover'] = 'REF:' + themeName + adjustStep(closestStep, -1);
      mappings['semantic/fill/primary-pressed'] = 'REF:' + themeName + adjustStep(closestStep, -1);

      mappings['semantic/border/divider-strong'] = 'GRAY:900';
      mappings['semantic/border/line-selected'] = 'GRAY:900';
      mappings['semantic/border/divider'] = 'GRAY-ALPHA:200';
      mappings['semantic/border/line'] = 'GRAY-ALPHA:300';
      mappings['semantic/border/line-disabled'] = 'GRAY-ALPHA:200';
      
      mappings['semantic/fill/silent'] = 'CUSTOM_SILENT';
      mappings['semantic/fill/silent-hover'] = 'CUSTOM_SILENT_HOVER';
      mappings['semantic/fill/silent-pressed'] = 'CUSTOM_SILENT_PRESSED';
      
      mappings['semantic/common/accent'] = 'ORANGE-RED-400';
      mappings['semantic/common/accent-pressed'] = 'ORANGE-RED-500';
      mappings['semantic/common/accent-hover'] = 'ORANGE-RED-500';
      mappings['semantic/common/muted'] = 'GRAY:300';
      mappings['semantic/common/custom-accent'] = 'REF:' + themeName + closestStep;
      mappings['semantic/common/custom-accent-low'] = 'CUSTOM_BACKGROUND_LOW:50';
      
      mappings['semantic/fill/tertiary'] = 'GRAY-ALPHA:100';
      mappings['semantic/fill/tertiary-hover'] = 'GRAY-ALPHA:200';
      mappings['semantic/fill/tertiary-pressed'] = 'GRAY-ALPHA:200';
      mappings['semantic/fill/disabled'] = 'GRAY:150';
    }
  }
  
  return mappings;
}

function getBackgroundStageOverrides(theme) {
  if (!theme || !theme.scaleColors || !Array.isArray(theme.scaleColors.light) || theme.scaleColors.light.length === 0) return null;

  var baseColor = theme.baseColor;
  var themeName = theme.themeName;
  if (!themeName) return null;

  var baseHex = baseColor;
  if (!baseHex && theme.scaleColors.light.length > 0) {
    baseHex = theme.scaleColors.light[0].hex;
  }

  var closestStep = findClosestStep(theme.scaleColors.light, baseHex || '#FFFFFF');
  var colorInfo = assessColorRange(closestStep, baseColor);
  var colorRange = colorInfo.colorRange;
  var overrides = {};

  if (colorRange === 'light') {
    // 배경 관련
    overrides['semantic/background/default'] = 'REF:' + themeName + closestStep;
    overrides['semantic/fill/surface-contents'] = 'GRAY-ALPHA:100';
    overrides['semantic/background/gradient-default'] = 'REF:' + themeName + closestStep;
    overrides['semantic/common/custom-accent-low'] = 'ALPHA:' + themeName + '50';
    
    // 텍스트 관련
    overrides['semantic/text/primary'] = 'GRAY:900';
    overrides['semantic//common/custom-accent'] = 'REF:' + themeName + adjustStep(closestStep, 1);
    overrides['semantic/text/secondary'] = 'GRAY:700';
    overrides['semantic/text/tertiary'] = 'GRAY:600';
    overrides['semantic/text/disabled'] = 'GRAY:400';
    overrides['semantic/text/disabled'] = 'GRAY:50';
    
    // Silent 버튼 관련
    overrides['semantic/fill/silent'] = 'REF:' + themeName + closestStep;
    overrides['semantic/fill/silent-hover'] = 'REF:' + themeName + adjustStep(closestStep, -1);
    overrides['semantic/fill/silent-pressed'] = 'REF:' + themeName + adjustStep(closestStep, -1);
    
    // 보더 관련
    overrides['semantic/border/divider-strong'] = 'GRAY:950';
    overrides['semantic/border/line-selected'] = 'REF:' + themeName + adjustStep(closestStep, 2);
    overrides['semantic/border/divider'] = 'GRAY-ALPHA:100';
    overrides['semantic/border/line'] = 'GRAY:200';
    overrides['semantic/border/line-disabled'] = 'GRAY-ALPHA:200';

    // Accent 관련
    overrides['semantic/common/accent'] = 'ORANGE-RED-400';
    overrides['semantic/common/accent-pressed'] = 'ORANGE-RED-500';
    overrides['semantic/common/accent-hover'] = 'ORANGE-RED-500';
    overrides['semantic/common/muted'] = 'GRAY-ALPHA:300';
    
    // Tertiary 버튼 관련
    overrides['semantic/fill/tertiary'] = 'GRAY-ALPHA:200';
    overrides['semantic/fill/tertiary-hover'] = 'GRAY-ALPHA:300';
    overrides['semantic/fill/tertiary-pressed'] = 'GRAY-ALPHA:300';
    overrides['semantic/fill/disabled'] = 'GRAY-ALPHA:100';

  } else if (colorRange === 'medium') {
    // 배경 관련
    overrides['semantic/background/default'] = 'REF:' + themeName + closestStep;
    overrides['semantic/common/custom-accent-low'] = 'ALPHA:' + themeName + '50';
    overrides['semantic/fill/surface-contents'] = 'STATIC-WHITE-ALPHA:200';
    overrides['semantic/background/gradient-default'] = 'REF:' + themeName + closestStep;
    
    // 텍스트 관련
    overrides['semantic/text/primary'] = 'STATIC-WHITE-ALPHA:900';
    overrides['semantic/common/custom-accent'] = 'REF:' + themeName + adjustStep(closestStep, -2);
    overrides['semantic/text/secondary'] = 'STATIC-WHITE-ALPHA:800';
    overrides['semantic/text/tertiary'] = 'STATIC-WHITE-ALPHA:700';
    overrides['semantic/text/disabled'] = 'STATIC-WHITE-ALPHA:500';
    
    // Silent 버튼 관련
    overrides['semantic/fill/silent'] = 'REF:' + themeName + closestStep;
    overrides['semantic/fill/silent-hover'] = 'REF:' + themeName + adjustStep(closestStep, -1);
    overrides['semantic/fill/silent-pressed'] = 'REF:' + themeName + adjustStep(closestStep, -1);
    
    // 보더 관련
    overrides['semantic/border/divider-strong'] = 'STATIC-WHITE-ALPHA:900';
    overrides['semantic/border/line-selected'] = 'REF:' + themeName + adjustStep(closestStep, -1);
    overrides['semantic/border/divider'] = 'STATIC-WHITE-ALPHA:200';
    overrides['semantic/border/line'] = 'STATIC-WHITE-ALPHA:300';
    overrides['semantic/border/line-disabled'] = 'STATIC-WHITE-ALPHA:200';
     
    // Accent 관련
    overrides['semantic/common/accent'] = 'ORANGE-RED-300';
    overrides['semantic/common/accent-pressed'] = 'ORANGE-RED-400';
    overrides['semantic/common/accent-hover'] = 'ORANGE-RED-400';
    overrides['semantic/common/muted'] = 'GRAY-ALPHA:400';
    
    // Tertiary 버튼 관련
    overrides['semantic/fill/tertiary'] = 'STATIC-WHITE-ALPHA:400';
    overrides['semantic/fill/tertiary-hover'] = 'STATIC-WHITE-ALPHA:300';
    overrides['semantic/fill/tertiary-pressed'] = 'STATIC-WHITE-ALPHA:300';
    overrides['semantic/fill/disabled'] = 'STATIC-WHITE-ALPHA:200';
    
  } else {
    // 배경 관련 (어두운 범위)
    overrides['semantic/background/default'] = 'REF:' + themeName + closestStep;
    overrides['semantic/common/custom-accent-low'] = 'ALPHA:' + themeName + '900';
    overrides['semantic/fill/surface-contents'] = 'STATIC-WHITE-ALPHA:200';
    overrides['semantic/background/gradient-default'] = 'REF:' + themeName + closestStep;
    
    // 텍스트 관련
    overrides['semantic/text/primary'] = 'STATIC-WHITE-ALPHA:900';
    overrides['semantic/common/custom-accent-low'] = 'REF:' + themeName + adjustStep(closestStep, -2);
    overrides['semantic/text/secondary'] = 'STATIC-WHITE-ALPHA:700';
    overrides['semantic/text/tertiary'] = 'STATIC-WHITE-ALPHA:600';
    overrides['semantic/text/disabled'] = 'STATIC-WHITE-ALPHA:500';
    
    // Silent 버튼 관련
    overrides['semantic/fill/silent'] = 'REF:' + themeName + closestStep;
    overrides['semantic/fill/silent-hover'] = 'REF:' + themeName + adjustStep(closestStep, -1);
    overrides['semantic/fill/silent-pressed'] = 'REF:' + themeName + adjustStep(closestStep, -1);
    
    // 보더 관련
    overrides['semantic/border/divider-strong'] = 'STATIC-WHITE-ALPHA:900';
    overrides['semantic/border/line-selected'] = 'STATIC-WHITE-ALPHA:900';
    overrides['semantic/border/divider'] = 'STATIC-WHITE-ALPHA:200';
    overrides['semantic/border/line'] = 'STATIC-WHITE-ALPHA:300';
    overrides['semantic/border/line-disabled'] = 'STATIC-WHITE-ALPHA:200';
    
    // Accent 관련
    overrides['semantic/common/accent'] = 'ORANGE-RED-300';
    overrides['semantic/common/accent-pressed'] = 'ORANGE-RED-400';
    overrides['semantic/common/accent-hover'] = 'ORANGE-RED-400';
    overrides['semantic/common/muted'] = 'STATIC-WHITE-ALPHA:400';
    
    // Tertiary 버튼 관련
    overrides['semantic/fill/tertiary'] = 'STATIC-WHITE-ALPHA:400';
    overrides['semantic/fill/tertiary-hover'] = 'STATIC-WHITE-ALPHA:300';
    overrides['semantic/fill/tertiary-pressed'] = 'STATIC-WHITE-ALPHA:300';
    overrides['semantic/fill/disabled'] = 'STATIC-WHITE-ALPHA:200';
  }

  return overrides;
}


// =====================================
// 톤 매칭 함수
// =====================================

function generateToneMatchingSuggestions(referenceHex, inputHex) {
  var refHsl = hexToHsl(referenceHex);
  var inputHsl = hexToHsl(inputHex);
  var suggestions = [];
  
  suggestions.push({
    type: 'Saturation Match',
    hex: hslToHex(inputHsl[0], refHsl[1], inputHsl[2]),
    explanation: '채도를 ' + Math.round(refHsl[1]) + '%로 조정'
  });
  
  suggestions.push({
    type: 'Lightness Match', 
    hex: hslToHex(inputHsl[0], inputHsl[1], refHsl[2]),
    explanation: '명도를 ' + Math.round(refHsl[2]) + '%로 조정'
  });
  
  return suggestions;
}

// =====================================
// 상수 정의
// =====================================

// 기존 값 유지해야 할 토큰 목록
var preserveTokens = [
  'semantic/fill/surface-floating',
  'semantic/fill/surface-dialog', 
  'semantic/fill/surface-sheet',
  'semantic/fill/surface-black',
  'semantic/background/black',
  'semantic/common/on-white',
  'semantic/common/on-white-hover',
  'semantic/common/on-white-pressed',
  'semantic/common/on-black',
  'semantic/common/on-black-hover',
  'semantic/common/on-black-pressed',
  'semantic/overlay/dimmed'
];

// =====================================
// 메시지 핸들러들
// =====================================

// 기본 변수 생성 핸들러
async function handleCreateVariables(msg) {
  var collections = await figma.variables.getLocalVariableCollectionsAsync();
  var collection = collections.find(function(c) { 
    return c.name === 'ruler_v2'; 
  });
  
  if (!collection) {
    collection = figma.variables.createVariableCollection('ruler_v2');
  }
  
  var createdCount = 0;
  
  // Fine Tuning 값 확인
  var tuningValue = msg.tuningValue || 0;
  
  // 듀얼 모드 처리
  if (msg.dualMode) {
    // Light/Dark 모드 확인 및 생성
    var lightMode = collection.modes.find(function(m) { return m.name === 'Light'; });
    var darkMode = collection.modes.find(function(m) { return m.name === 'Dark'; });
    
    if (!lightMode) {
      if (collection.modes.length === 1 && collection.modes[0].name === 'Mode 1') {
        // 기본 모드 이름 변경
        collection.renameMode(collection.modes[0].modeId, 'Light');
        lightMode = collection.modes[0];
      } else {
        lightMode = collection.addMode('Light');
      }
    }
    
    if (!darkMode) {
      darkMode = collection.addMode('Dark');
    }
    
    // Light/Dark 색상 모두 생성
    for (var i = 0; i < msg.lightColors.length; i++) {
      var lightColor = msg.lightColors[i];
      var darkColor = msg.darkColors[i];
      
      if (!lightColor || !lightColor.hex || !darkColor || !darkColor.hex) continue;
      
      var variableName = 'scale/' + msg.variableName + '-' + lightColor.step;
      var variable = await findOrCreateVariable(variableName, collection, 'COLOR');
      
      // Light 모드 값 설정
      variable.setValueForMode(lightMode.modeId, hexToFigmaRGB(lightColor.hex));
      // Dark 모드 값 설정  
      variable.setValueForMode(darkMode.modeId, hexToFigmaRGB(darkColor.hex));
      
      createdCount++;
    }
    
    figma.notify('Created ' + createdCount + ' dual-mode variables');
  } else {
    // 단일 모드 처리
    var modeId = collection.modes[0].modeId;
    
    for (var i = 0; i < msg.colors.length; i++) {
      var color = msg.colors[i];
      if (!color || !color.hex) continue;
      
      var variableName = 'scale/' + msg.variableName + '-' + color.step;
      var variable = await findOrCreateVariable(variableName, collection, 'COLOR');
      variable.setValueForMode(modeId, hexToFigmaRGB(color.hex));
      createdCount++;
    }
    
    figma.notify('Created ' + createdCount + ' variables');
  }
  
  figma.ui.postMessage({ 
    type: 'variable-created',
    success: true,
    count: createdCount,
    dualMode: msg.dualMode,
    tuningValue: tuningValue
  });
}

// 스타일 생성 핸들러
async function handleCreateStyles(msg) {
  var createdCount = 0;
  var paintStyles = [];
  
  for (var i = 0; i < msg.colors.length; i++) {
    var color = msg.colors[i];
    if (!color || !color.hex) continue;
    
    var styleName = msg.styleName + '/' + color.step;
    
    // 기존 스타일 찾기
    var existingStyle = figma.getLocalPaintStyles().find(function(style) {
      return style.name === styleName;
    });
    
    var style;
    if (existingStyle) {
      style = existingStyle;
    } else {
      style = figma.createPaintStyle();
      style.name = styleName;
    }
    
    // 색상 설정
    var rgb = hexToFigmaRGB(color.hex);
    style.paints = [{
      type: 'SOLID',
      color: rgb
    }];
    
    paintStyles.push(style);
    createdCount++;
  }
  
  figma.ui.postMessage({
    type: 'style-created',
    success: true,
    count: createdCount
  });
  
  figma.notify('Created ' + createdCount + ' color styles');
}

// Custom Theme 생성 핸들러
async function handleCreateCustomTheme(msg) {
  var theme = msg.theme;
  var applicationMode = theme.applicationMode || 'accent-on-bg-off';
  
  var collections = await figma.variables.getLocalVariableCollectionsAsync();
  var collection = collections.find(function(c) { 
    return c.name === 'ruler_v2'; 
  });
  
  if (!collection) {
    collection = figma.variables.createVariableCollection('ruler_v2');
  }
  
  // Light/Dark 모드 확인 및 생성 (Scale Generator와 동일한 방식)
  var lightMode = collection.modes.find(function(m) { return m.name === 'Light'; });
  var darkMode = collection.modes.find(function(m) { return m.name === 'Dark'; });
  
  if (!lightMode) {
    if (collection.modes.length === 1 && collection.modes[0].name === 'Mode 1') {
      // 기본 모드 이름 변경
      collection.renameMode(collection.modes[0].modeId, 'Light');
      lightMode = collection.modes[0];
    } else {
      lightMode = { modeId: collection.addMode('Light') };
    }
  }
  
  if (!darkMode) {
    darkMode = { modeId: collection.addMode('Dark') };
  }
  
  var createdCount = 0;
  
  // Scale 색상 생성 (Light/Dark 모드 모두)
  for (var i = 0; i < theme.scaleColors.light.length; i++) {
    var lightColor = theme.scaleColors.light[i];
    var darkColor = theme.scaleColors.dark[i];
    var variableName = 'scale/' + theme.themeName + '-' + lightColor.step;
    
    var variable = await findOrCreateVariable(variableName, collection, 'COLOR');
    
    // Light 모드 값 설정
    variable.setValueForMode(lightMode.modeId, hexToFigmaRGB(lightColor.hex));
    // Dark 모드 값 설정
    variable.setValueForMode(darkMode.modeId, hexToFigmaRGB(darkColor.hex));
    
    createdCount++;
  }
  
  // Alpha 토큰 생성 (Light/Dark 모드 모두)
  var closestStepForAlphaLight = findClosestStep(theme.scaleColors.light, theme.baseColor);
  var closestStepForAlphaDark = findClosestStep(theme.scaleColors.dark, theme.baseColor);
  
  var baseColorLight = theme.scaleColors.light.find(function(c) { 
    return c.step === closestStepForAlphaLight; 
  });
  var baseColorDark = theme.scaleColors.dark.find(function(c) { 
    return c.step === closestStepForAlphaDark; 
  });
  
  if (!baseColorLight) {
    baseColorLight = { hex: theme.baseColor };
  }
  if (!baseColorDark) {
    baseColorDark = { hex: theme.baseColor };
  }
  
  var baseRgbLight = hexToFigmaRGB(baseColorLight.hex);
  var baseRgbDark = hexToFigmaRGB(baseColorDark.hex);
  
  // 고정된 알파 매핑 테이블
  var alphaMapping = {
    0: 0.00, 50: 0.05, 75: 0.08, 100: 0.10, 150: 0.15,
    200: 0.20, 300: 0.30, 400: 0.40, 500: 0.50,
    600: 0.60, 700: 0.70, 800: 0.80, 900: 0.90, 950: 0.95
  };
  
  // alpha-00 먼저 생성
  var transparentVariableName = 'scale/' + theme.themeName + '-alpha-00';
  var transparentVariable = await findOrCreateVariable(transparentVariableName, collection, 'COLOR');
  transparentVariable.setValueForMode(lightMode.modeId, { 
    r: baseRgbLight.r, g: baseRgbLight.g, b: baseRgbLight.b, a: 0 
  });
  transparentVariable.setValueForMode(darkMode.modeId, { 
    r: baseRgbDark.r, g: baseRgbDark.g, b: baseRgbDark.b, a: 0 
  });
  createdCount++;
  
  // 각 단계별 alpha 토큰 생성 (50 제외, 75는 surface-contents에서 사용하므로 생성)
  for (var i = 0; i < theme.scaleColors.light.length; i++) {
    var step = theme.scaleColors.light[i].step;
    
    // 50만 건너뛰기 (75는 surface-contents에서 사용하므로 생성)
    if (step === 50) continue;
    
    var alphaValue = alphaMapping[step];
    if (alphaValue === undefined) continue;
    
    var alphaVariableName = 'scale/' + theme.themeName + '-alpha-' + step;
    var alphaVariable = await findOrCreateVariable(alphaVariableName, collection, 'COLOR');
    
    // Light/Dark 모드 모두에 alpha 값 설정
    alphaVariable.setValueForMode(lightMode.modeId, { 
      r: baseRgbLight.r, g: baseRgbLight.g, b: baseRgbLight.b, a: alphaValue 
    });
    alphaVariable.setValueForMode(darkMode.modeId, { 
      r: baseRgbDark.r, g: baseRgbDark.g, b: baseRgbDark.b, a: alphaValue 
    });
    createdCount++;
  }
  
  // Semantic 토큰은 건드리지 않음 - scale 토큰만 생성
  
  figma.notify('Created ' + createdCount + ' variables for ' + theme.themeName);
}

// 매핑 값을 실제 색상으로 변환하는 함수
function calculateTokenColor(mappingValue, theme, mode) {
  if (!mappingValue) return null;
  
  var scaleColors = mode === 'light' ? theme.scaleColors.light : theme.scaleColors.dark;
  
  if (mappingValue.startsWith('REF:')) {
    var refString = mappingValue.replace('REF:', '');
    var refThemeName = theme.themeName;
    var step = NaN;

    if (/^\d+$/.test(refString)) {
      step = parseInt(refString, 10);
    } else {
      var matchDigits = refString.match(/(\d{1,3})$/);
      if (matchDigits) {
        step = parseInt(matchDigits[1], 10);
        var namePart = refString.slice(0, refString.length - matchDigits[1].length);
        if (namePart) {
          refThemeName = namePart.endsWith('-') ? namePart.slice(0, -1) : namePart;
        }
      }
    }

    if (isNaN(step)) return null;

    var targetScale = scaleColors;
    if (refThemeName !== theme.themeName && theme.backgroundTheme && theme.backgroundTheme.themeName === refThemeName) {
      targetScale = (mode === 'light') ? theme.backgroundTheme.scaleColors.light : theme.backgroundTheme.scaleColors.dark;
    }

    if (!targetScale) return null;

    var colorObj = targetScale.find(function(c) { return c.step == step; });
    return colorObj ? colorObj.hex : null;
  } 
  else if (mappingValue.startsWith('GRAY:')) {
    var grayStep = parseInt(mappingValue.replace('GRAY:', ''));
    // 간단한 그레이 계산 (실제로는 gray scale에서 가져와야 함)
    var grayValue = Math.round(255 - (grayStep / 1000) * 255);
    return '#' + grayValue.toString(16).padStart(2, '0').repeat(3);
  }
  else if (mappingValue.startsWith('ALPHA:')) {
    var alphaString = mappingValue.replace('ALPHA:', '').replace(theme.themeName, '');
    var alphaValue = parseInt(alphaString) / 1000;
    var baseColor = scaleColors.find(function(c) { return c.step == 500; }) || scaleColors[Math.floor(scaleColors.length/2)];
    // 알파값 적용은 Figma에서 별도 처리 - 일단 베이스 색상 반환
    return baseColor ? baseColor.hex : theme.baseColor;
  }
  
  return null;
}

// Frame 선택 상태 확인 핸들러
async function handleCheckFrameSelection(msg) {
  console.log('[Backend] Frame 선택 상태 확인 중...');
  
  var selection = figma.currentPage.selection;
  var frameNodes = selection.filter(function(node) {
    return node.type === 'FRAME';
  });
  
  var frameInfo = {
    hasFrames: frameNodes.length > 0,
    frameCount: frameNodes.length,
    frameNames: frameNodes.map(function(frame) {
      return frame.name;
    })
  };
  
  console.log('[Backend] Frame 선택 정보:', frameInfo);
  
  // UI에 결과 전송
  figma.ui.postMessage({
    type: 'frame-selection-result',
    frameInfo: frameInfo
  });
}

// 테마 토큰을 Layer에 직접 적용하는 핸들러 (semantic 토큰 변경 없이)
async function handleApplyThemeColorsToFrame(msg) {
  var theme = msg.theme;
  var applicationMode = theme.applicationMode || 'accent-on-bg-off';
  var selection = figma.currentPage.selection;
  
  console.log('[Backend] 테마 적용 시작 - applicationMode:', applicationMode);
  console.log('[Backend] 받은 테마 데이터:', theme);
  
  if (selection.length === 0) {
    figma.notify('Frame을 선택해주세요');
    try {
      figma.ui.postMessage({ type: 'error', message: 'Frame을 선택해주세요' });
    } catch (e) {}
    return;
  }

  function collectBoundVariableIds(nodes) {
    var ids = new Set();

    function addPaintVariables(paints) {
      if (!Array.isArray(paints)) return;
      for (var p = 0; p < paints.length; p++) {
        var paint = paints[p];
        if (
          paint &&
          paint.boundVariables &&
          paint.boundVariables.color &&
          paint.boundVariables.color.id
        ) {
          ids.add(paint.boundVariables.color.id);
        }
      }
    }

    function addEffectVariables(effects) {
      if (!Array.isArray(effects)) return;
      for (var e = 0; e < effects.length; e++) {
        var effect = effects[e];
        if (
          effect &&
          effect.boundVariables &&
          effect.boundVariables.color &&
          effect.boundVariables.color.id
        ) {
          ids.add(effect.boundVariables.color.id);
        }
      }
    }

    function traverse(node) {
      if (!node) return;
      if ('fills' in node && Array.isArray(node.fills)) {
        addPaintVariables(node.fills);
      }
      if ('strokes' in node && Array.isArray(node.strokes)) {
        addPaintVariables(node.strokes);
      }
      if ('backgrounds' in node && Array.isArray(node.backgrounds)) {
        addPaintVariables(node.backgrounds);
      }
      if ('effects' in node && Array.isArray(node.effects)) {
        addEffectVariables(node.effects);
      }
      if ('children' in node && node.children) {
        for (var c = 0; c < node.children.length; c++) {
          traverse(node.children[c]);
        }
      }
    }

    for (var n = 0; n < nodes.length; n++) {
      traverse(nodes[n]);
    }

    return ids;
  }

  var collections = await figma.variables.getLocalVariableCollectionsAsync();
  var collection = collections.find(function(c) { return c.name === 'ruler_v2'; });
  
  if (!collection) {
    figma.notify('ruler_v2 컬렉션을 찾을 수 없습니다');
    return;
  }
  
  // 동적 매핑 계산 (기존 로직과 동일)
  var closestStep = findClosestStep(theme.scaleColors.light, theme.baseColor);
  console.log('[Backend] Closest step:', closestStep);
  
  // custom-background 선택 시, 매핑은 foreground 중심 로직을 사용하고 배경만 사용자 정의로 대체
  var effectiveMode = (applicationMode === 'custom-background') ? 'accent-on-bg-off' : applicationMode;
  var mappings = getDynamicMappings(closestStep, theme.themeName, effectiveMode, theme.baseColor);
  // 추천 패널에서 인접 스텝을 선택한 경우 배경을 해당 스텝으로 강제 매핑
  if (applicationMode !== 'custom-background' && theme.overrideRecommendedStep) {
    mappings['semantic/background/default'] = 'REF:' + theme.themeName + theme.overrideRecommendedStep;
    mappings['semantic/background/gradient-default'] = 'REF:' + theme.themeName + theme.overrideRecommendedStep;
    mappings['semantic/fill/silent'] = 'REF:' + theme.themeName + theme.overrideRecommendedStep;
    mappings['semantic/fill/silent-hover'] = 'REF:' + theme.themeName + adjustStep(theme.overrideRecommendedStep, -1);
    mappings['semantic/fill/silent-pressed'] = 'REF:' + theme.themeName + adjustStep(theme.overrideRecommendedStep, -1);
  }

  if (applicationMode === 'custom-background') {
    if (theme.backgroundTheme) {
      var backgroundOverrides = getBackgroundStageOverrides(theme.backgroundTheme);
      if (backgroundOverrides) {
        Object.keys(backgroundOverrides).forEach(function(key) {
          mappings[key] = backgroundOverrides[key];
        });
      }
    } else if (theme.customBackgroundColor) {
      mappings['semantic/background/default'] = 'CUSTOM_BACKGROUND';
      mappings['semantic/background/gradient-default'] = 'CUSTOM_BACKGROUND';
    }
  }
  console.log('[Backend] 생성된 매핑:', mappings);
  
  // Ensure required library variables are available for upcoming lookups
  var importedLibraryVariables = await ensureLibraryVariablesForMappings(mappings, theme);
  
  // 모든 변수 가져오기
  var allVariables = await figma.variables.getLocalVariablesAsync('COLOR');
  if (importedLibraryVariables && importedLibraryVariables.length) {
    importedLibraryVariables.forEach(function(variable) {
      if (!variable) return;
      var exists = allVariables.some(function(v) { return v.id === variable.id; });
      if (!exists) {
        allVariables.push(variable);
      }
    });
  }
  var allVarById = new Map();
  var localVarByName = new Map();
  var localVarById = new Map();
  for (var lv = 0; lv < allVariables.length; lv++) {
    var variable = allVariables[lv];
    if (!variable) continue;
    allVarById.set(variable.id, variable);
    if (variable.variableCollectionId === collection.id) {
      localVarByName.set(variable.name, variable);
      localVarById.set(variable.id, variable);
    }
  }

  var referencedVariableIds = collectBoundVariableIds(selection);
  for (var id of referencedVariableIds) {
    if (!allVarById.has(id)) {
      try {
        var remoteVar = await figma.variables.getVariableByIdAsync(id);
        if (remoteVar) {
          allVariables.push(remoteVar);
          allVarById.set(remoteVar.id, remoteVar);
        }
      } catch (error) {
        console.warn('[Backend] 원본 라이브러리 변수 조회 실패:', id, error);
      }
    }
  }
  var appliedCount = 0;
  
  
  // 매핑 값에서 실제 토큰을 찾는 함수
  function findTokenFromMapping(mappingValue) {
    if (!mappingValue) return null;
    
    
    if (mappingValue.startsWith('REF:')) {
      var refString = mappingValue.replace('REF:', '');
      var refThemeName = theme.themeName;
      var step = NaN;

      if (/^\d+$/.test(refString)) {
        step = parseInt(refString, 10);
      } else {
        var matchDigits = refString.match(/(\d{1,3})$/);
        if (matchDigits) {
          step = parseInt(matchDigits[1], 10);
          var namePart = refString.slice(0, refString.length - matchDigits[1].length);
          if (namePart && namePart !== '') {
            refThemeName = namePart;
            if (refThemeName.endsWith('-')) {
              refThemeName = refThemeName.slice(0, -1);
            }
          }
        }
      }

      if (!isNaN(step)) {
        var scaleVarName = 'scale/' + refThemeName + '-' + step;
        var foundVar = normalizeVariableLookup(allVariables, collection.id, scaleVarName);
        if (!foundVar && refThemeName !== theme.themeName) {
          var fallbackVarName = 'scale/' + theme.themeName + '-' + step;
          foundVar = normalizeVariableLookup(allVariables, collection.id, fallbackVarName);
        }
        return foundVar || null;
      }
    } else if (mappingValue.startsWith('GRAY:')) {
      var grayStep = parseInt(mappingValue.replace('GRAY:', ''));
      var grayVarName = 'scale/gray-' + grayStep;
      return normalizeVariableLookup(allVariables, collection.id, grayVarName);
    } else if (mappingValue.startsWith('ALPHA:')) {
      var alphaStep = parseInt(mappingValue.replace('ALPHA:', '').replace(theme.themeName, ''));
      
      var alphaVarName = 'scale/' + theme.themeName + '-alpha-' + alphaStep;
      return normalizeVariableLookup(allVariables, collection.id, alphaVarName);
    } else if (mappingValue.startsWith('GRAY-ALPHA:')) {
      var grayAlphaStep = parseInt(mappingValue.replace('GRAY-ALPHA:', ''));
      var grayAlphaVarName = 'scale/gray-alpha-' + grayAlphaStep;
      return normalizeVariableLookup(allVariables, collection.id, grayAlphaVarName);
    } else if (mappingValue.startsWith('ON-COLOR-ALPHA:')) {
      var onColorStep = parseInt(mappingValue.replace('ON-COLOR-ALPHA:', ''));
      var onColorVarName = 'scale/on-color-alpha-' + onColorStep;
      return normalizeVariableLookup(allVariables, collection.id, onColorVarName);
    } else if (mappingValue.startsWith('STATIC-WHITE-ALPHA:')) {
      var staticWhiteStep = parseInt(mappingValue.replace('STATIC-WHITE-ALPHA:', ''));
      var staticWhiteVarName = 'static/static-white-alpha-' + staticWhiteStep;
      console.log('🔍 STATIC-WHITE-ALPHA Debug:', mappingValue, '→', staticWhiteVarName);
      var foundVar = normalizeVariableLookup(allVariables, collection.id, staticWhiteVarName);
      console.log('🔍 Found variable:', foundVar ? foundVar.name : 'NOT FOUND');
      return foundVar;
    } else if (mappingValue.startsWith('STATIC-BLACK-ALPHA:')) {
      var staticBlackStep = parseInt(mappingValue.replace('STATIC-BLACK-ALPHA:', ''));
      var staticBlackVarName = 'static/static-black-alpha-' + staticBlackStep;
      return normalizeVariableLookup(allVariables, collection.id, staticBlackVarName);
    } else if (mappingValue === 'CUSTOM_BACKGROUND') {
      if (!theme.customBackgroundColor) return null;
      var baseInfo = getCustomBackgroundScaleInfo(theme);
      if (!baseInfo.scaleColors || baseInfo.scaleColors.length === 0) return null;
      var nearest = findClosestStep(baseInfo.scaleColors, theme.customBackgroundColor);
      var varNameBg = 'scale/' + baseInfo.themeName + '-' + nearest;
      var bgVar = normalizeVariableLookup(allVariables, collection.id, varNameBg);
      if (!bgVar && baseInfo.themeName !== theme.themeName) {
        var fallbackName = 'scale/' + theme.themeName + '-' + nearest;
        bgVar = normalizeVariableLookup(allVariables, collection.id, fallbackName);
      }
      return bgVar;
    } else if (mappingValue.startsWith('CUSTOM_BACKGROUND_LOW')) {
      var lowInfo = resolveCustomBackgroundLowColor(theme, mappingValue);
      if (!lowInfo || lowInfo.step === null) return null;
      var lowThemeName = lowInfo.themeName || theme.themeName;
      var lowVarName = 'scale/' + lowThemeName + '-' + lowInfo.step;
      var lowVar = normalizeVariableLookup(allVariables, collection.id, lowVarName);
      if (!lowVar && lowThemeName !== theme.themeName) {
        var fallbackLow = 'scale/' + theme.themeName + '-' + lowInfo.step;
        lowVar = normalizeVariableLookup(allVariables, collection.id, fallbackLow);
      }
      return lowVar || null;
    } else if (mappingValue.startsWith('CUSTOM_BACKGROUND_ALPHA')) {
      return null;
    } else if (mappingValue === 'CUSTOM_SILENT' || mappingValue === 'CUSTOM_SILENT_HOVER' || mappingValue === 'CUSTOM_SILENT_PRESSED') {
      var silentInfo = resolveCustomSilentColor(theme, mappingValue);
      if (!silentInfo) return null;
      if (mappingValue === 'CUSTOM_SILENT') {
        return null;
      }
      if (silentInfo.step === null) return null;
      var silentThemeName = silentInfo.themeName || theme.themeName;
      var silentVarName = 'scale/' + silentThemeName + '-' + silentInfo.step;
      var silentVar = normalizeVariableLookup(allVariables, collection.id, silentVarName);
      if (!silentVar && silentThemeName !== theme.themeName) {
        var fallbackSilent = 'scale/' + theme.themeName + '-' + silentInfo.step;
        silentVar = normalizeVariableLookup(allVariables, collection.id, fallbackSilent);
      }
      return silentVar || null;
    }

    return null;
  }

  // fallback 색상 계산 함수
  function getFallbackColor(mappingValue) {
    if (!mappingValue) return { r: 1, g: 1, b: 1 };
    
    if (mappingValue.startsWith('REF:')) {
      var refString = mappingValue.replace('REF:', '');
      var step = parseInt(refString.startsWith(theme.themeName) ? 
                         refString.substring(theme.themeName.length) : refString);
      
      var colorData = theme.scaleColors.light.find(function(c) { 
        return c.step === step; 
      });
      
      if (colorData) {
        return hexToFigmaRGB(colorData.hex);
      }
    } else if (mappingValue.startsWith('GRAY:')) {
      var grayStep = parseInt(mappingValue.replace('GRAY:', ''));
      var grayVar = allVariables.find(function(v) {
        return v.name === 'scale/gray-' + grayStep && v.variableCollectionId === collection.id;
      });
      
      if (grayVar && grayVar.valuesByMode) {
        var lightMode = collection.modes.find(function(m) { return m.name === 'Light'; });
        if (lightMode && grayVar.valuesByMode[lightMode.modeId]) {
          var grayValue = grayVar.valuesByMode[lightMode.modeId];
          if (grayValue && typeof grayValue === 'object' && 'r' in grayValue) {
            // 알파 값 제거하고 RGB만 반환
            return {
              r: grayValue.r,
              g: grayValue.g, 
              b: grayValue.b
            };
          }
        }
      }
    } else if (mappingValue.startsWith('ALPHA:') || mappingValue.startsWith('GRAY-ALPHA:') || mappingValue.startsWith('ON-COLOR-ALPHA:')) {
      // 알파 타입들의 경우 기본 컬러 반환 (실제 알파값은 토큰에서 처리)
      return { r: 0.5, g: 0.5, b: 0.5 };
    } else if (mappingValue.startsWith('STATIC-WHITE-ALPHA:')) {
      // 정적 흰색 알파의 경우 흰색 기본값 반환
      return { r: 1, g: 1, b: 1 };
    } else if (mappingValue.startsWith('STATIC-BLACK-ALPHA:')) {
      // 정적 검은색 알파의 경우 검은색 기본값 반환
      return { r: 0, g: 0, b: 0 };
    } else if (mappingValue === 'CUSTOM_BACKGROUND' && theme.customBackgroundColor) {
      return hexToFigmaRGB(theme.customBackgroundColor);
    } else if (mappingValue.startsWith('CUSTOM_SILENT') && theme.customBackgroundColor) {
      var silentFallback = resolveCustomSilentColor(theme, mappingValue);
      var silentHex = (silentFallback && silentFallback.hex) ? silentFallback.hex : theme.customBackgroundColor;
      return hexToFigmaRGB(silentHex);
    } else if (mappingValue.startsWith('CUSTOM_BACKGROUND_LOW') && theme.customBackgroundColor) {
      var lowFallback = resolveCustomBackgroundLowColor(theme, mappingValue);
      var lowHex = (lowFallback && lowFallback.hex) ? lowFallback.hex : theme.customBackgroundColor;
      return hexToFigmaRGB(lowHex);
    } else if (mappingValue.startsWith('CUSTOM_BACKGROUND_ALPHA') && theme.customBackgroundColor) {
      var alphaFallback = resolveCustomBackgroundAlpha(theme, mappingValue);
      if (alphaFallback) {
        return {
          r: alphaFallback.color.r,
          g: alphaFallback.color.g,
          b: alphaFallback.color.b
        };
      }
      return hexToFigmaRGB(theme.customBackgroundColor);
    }
    
    // 기본 fallback 컬러
    return { r: 1, g: 1, b: 1 };
  }

  function getColorFromVariable(variable, depth) {
    if (!variable || !variable.valuesByMode) return null;
    if (depth === undefined) depth = 0;
    if (depth > 5) return null;

    var modeValue = null;
    var lightMode = collection.modes.find(function(m) { return m.name === 'Light'; });
    if (lightMode && variable.valuesByMode[lightMode.modeId]) {
      modeValue = variable.valuesByMode[lightMode.modeId];
    }
    if (!modeValue) {
      var firstKey = Object.keys(variable.valuesByMode)[0];
      if (firstKey) {
        modeValue = variable.valuesByMode[firstKey];
      }
    }

    if (!modeValue) return null;

    if (typeof modeValue === 'object') {
      if (modeValue.type === 'VARIABLE_ALIAS' && modeValue.id) {
        var targetVar = localVarById.get(modeValue.id) || allVarById.get(modeValue.id);
        if (targetVar) {
          return getColorFromVariable(targetVar, depth + 1);
        }
        return null;
      }
      if ('r' in modeValue && 'g' in modeValue && 'b' in modeValue) {
        return {
          r: modeValue.r,
          g: modeValue.g,
          b: modeValue.b,
          a: modeValue.a === undefined ? 1 : modeValue.a
        };
      }
    }

    return null;
  }

  // 노드의 모든 토큰을 재귀적으로 교체하는 함수
  function replaceTokensInNode(node, depth) {
    var indent = '';
    for (var d = 0; d < depth; d++) indent += '  ';
    
    
    // 현재 노드의 fills 처리
    if ('fills' in node && node.fills && node.fills.length > 0) {
      for (var f = 0; f < node.fills.length; f++) {
        var fill = node.fills[f];
        if (fill.boundVariables && fill.boundVariables.color && fill.boundVariables.color.id) {
          // 기존 바인딩된 변수 찾기
          var currentVar = allVarById.get(fill.boundVariables.color.id);

          if (currentVar && currentVar.name.startsWith('semantic/')) {

          if (currentVar.variableCollectionId !== collection.id) {
            var localReplacement = localVarByName.get(currentVar.name);
            if (localReplacement) {
              var migratedFills = node.fills.slice();
              var clonedFill = Object.assign({}, fill);
              if (!clonedFill.color && clonedFill.type === 'SOLID') {
                clonedFill.color = getColorFromVariable(localReplacement) || fill.color;
              }
              clonedFill.boundVariables = {
                color: {
                  type: 'VARIABLE_ALIAS',
                  id: localReplacement.id
                }
              };
              migratedFills[f] = clonedFill;
              node.fills = migratedFills;
              fill = node.fills[f];
              currentVar = localReplacement;
              appliedCount++;
            }
          }

            // 매핑에서 대응하는 토큰 찾기
            var mappedValue = mappings[currentVar.name];
            if (mappedValue) {
              if (mappedValue === 'CUSTOM_BACKGROUND' && theme.customBackgroundColor) {
                var directBgColor = hexToFigmaRGB(theme.customBackgroundColor);
                var updatedFills = node.fills.slice();
                updatedFills[f] = { type: 'SOLID', color: directBgColor };
                node.fills = updatedFills;
                appliedCount++;
                continue;
              }

              if (mappedValue.startsWith('CUSTOM_SILENT') && theme.customBackgroundColor) {
                var silentData = resolveCustomSilentColor(theme, mappedValue);
                var silentHex = (silentData && silentData.hex) ? silentData.hex : theme.customBackgroundColor;
                var silentRgb = hexToFigmaRGB(silentHex);
                var silentFills = node.fills.slice();
                silentFills[f] = { type: 'SOLID', color: silentRgb };
                node.fills = silentFills;
                appliedCount++;
                continue;
              }

              if (mappedValue.startsWith('CUSTOM_BACKGROUND_LOW') && theme.customBackgroundColor) {
                var lowData = resolveCustomBackgroundLowColor(theme, mappedValue);
                var lowHex = (lowData && lowData.hex) ? lowData.hex : theme.customBackgroundColor;
                var lowRgb = hexToFigmaRGB(lowHex);
                var lowFills = node.fills.slice();
                lowFills[f] = { type: 'SOLID', color: lowRgb };
                node.fills = lowFills;
                appliedCount++;
                continue;
              }

              if (mappedValue.startsWith('CUSTOM_BACKGROUND_ALPHA') && theme.customBackgroundColor) {
                var alphaInfo2 = resolveCustomBackgroundAlpha(theme, mappedValue);
                if (alphaInfo2) {
                  var nfAlpha2 = node.fills.slice();
                  nfAlpha2[f] = {
                    type: 'SOLID',
                    color: alphaInfo2.color,
                    opacity: alphaInfo2.opacity
                  };
                  node.fills = nfAlpha2;
                  appliedCount++;
                  continue;
                }
              }

              var newToken = findTokenFromMapping(mappedValue);

              if (newToken) {
                var fallbackColor = getFallbackColor(mappedValue);

                var newFills = node.fills.slice();
                newFills[f] = {
                  type: 'SOLID',
                  color: fallbackColor,
                  boundVariables: {
                    'color': {
                      type: 'VARIABLE_ALIAS',
                      id: newToken.id
                    }
                  }
                };
                node.fills = newFills;

                appliedCount++;
              } else {
              }
            } else {
            }
          }
        }
      }
    }
    
    // 현재 노드의 strokes 처리
    if ('strokes' in node && node.strokes && node.strokes.length > 0) {
      for (var s = 0; s < node.strokes.length; s++) {
        var stroke = node.strokes[s];
        if (stroke.boundVariables && stroke.boundVariables.color && stroke.boundVariables.color.id) {
          // 기존 바인딩된 변수 찾기
          var currentStrokeVar = allVarById.get(stroke.boundVariables.color.id);

          if (currentStrokeVar && currentStrokeVar.name.startsWith('semantic/')) {

            if (currentStrokeVar.variableCollectionId !== collection.id) {
              var localStrokeReplacement = localVarByName.get(currentStrokeVar.name);
              if (localStrokeReplacement) {
                var migratedStrokes = node.strokes.slice();
                var clonedStroke = Object.assign({}, stroke);
                if (!clonedStroke.color) {
                  clonedStroke.color = getColorFromVariable(localStrokeReplacement) || stroke.color;
                }
                clonedStroke.boundVariables = {
                  color: {
                    type: 'VARIABLE_ALIAS',
                    id: localStrokeReplacement.id
                  }
                };
                migratedStrokes[s] = clonedStroke;
                node.strokes = migratedStrokes;
                stroke = node.strokes[s];
                currentStrokeVar = localStrokeReplacement;
                appliedCount++;
              }
            }

            // 매핑에서 대응하는 토큰 찾기
            var strokeMappedValue = mappings[currentStrokeVar.name];
            if (strokeMappedValue) {
              var newStrokeToken = findTokenFromMapping(strokeMappedValue);
              if (newStrokeToken) {
                var strokeFallbackColor = getFallbackColor(strokeMappedValue);
                var newStrokes = node.strokes.slice();
                newStrokes[s] = {
                  type: 'SOLID',
                  color: strokeFallbackColor,
                  boundVariables: {
                    'color': {
                      type: 'VARIABLE_ALIAS',
                      id: newStrokeToken.id
                    }
                  }
                };
                node.strokes = newStrokes;

                appliedCount++;
              } else {
              }
            } else {
            }
          }
        }
      }
    }
    
    // effects (그림자 등) 처리
    if ('effects' in node && node.effects && node.effects.length > 0) {
      for (var e = 0; e < node.effects.length; e++) {
        var effect = node.effects[e];
        if (effect.boundVariables && effect.boundVariables.color && effect.boundVariables.color.id) {
          var currentEffectVar = allVarById.get(effect.boundVariables.color.id);

          if (currentEffectVar && currentEffectVar.name.startsWith('semantic/')) {

            if (currentEffectVar.variableCollectionId !== collection.id) {
              var localEffectReplacement = localVarByName.get(currentEffectVar.name);
              if (localEffectReplacement) {
                var migratedEffects = node.effects.slice();
                var clonedEffect = Object.assign({}, effect);
                clonedEffect = Object.assign({}, clonedEffect, {
                  boundVariables: {
                    color: {
                      type: 'VARIABLE_ALIAS',
                      id: localEffectReplacement.id
                    }
                  }
                });
                if (!clonedEffect.color) {
                  clonedEffect.color = getColorFromVariable(localEffectReplacement) || effect.color;
                }
                migratedEffects[e] = clonedEffect;
                node.effects = migratedEffects;
                effect = node.effects[e];
                currentEffectVar = localEffectReplacement;
                appliedCount++;
              }
            }

            var effectMappedValue = mappings[currentEffectVar.name];
            if (effectMappedValue) {
              var newEffectToken = findTokenFromMapping(effectMappedValue);
              if (newEffectToken) {
                // Effect 토큰 교체 - effects 배열 전체 복사 후 수정
                var newEffects = node.effects.slice();
                newEffects[e] = Object.assign({}, effect);
                newEffects[e].boundVariables = {
                  'color': {
                    type: 'VARIABLE_ALIAS',
                    id: newEffectToken.id
                  }
                };
                node.effects = newEffects;
                
                appliedCount++;
              }
            }
          }
        }
      }
    }
    
    // 자식 노드들 재귀 처리
    if ('children' in node && node.children) {
      for (var c = 0; c < node.children.length; c++) {
        replaceTokensInNode(node.children[c], depth + 1);
      }
    }
  }
  
  // 선택된 모든 노드에 토큰 교체 적용
  for (var i = 0; i < selection.length; i++) {
    var node = selection[i];
    replaceTokensInNode(node, 0);
  }
  
  figma.notify('테마 토큰이 ' + appliedCount + '개 요소에 적용되었어요!');
  try {
    figma.ui.postMessage({
      type: 'custom-mode-applied',
      success: true,
      count: appliedCount,
      cleared: 0,
      modeName: applicationMode
    });
  } catch (e) {}
}

// Semantic 토큰을 프레임에 적용하는 핸들러 - handleApplyThemeColorsToFrame과 동일한 방식 사용
async function handleApplySemanticToFrame(msg) {
  var selection = figma.currentPage.selection;
  
  if (selection.length === 0) {
    figma.notify('Frame을 선택해주세요');
    return;
  }
  
  var collections = await figma.variables.getLocalVariableCollectionsAsync();
  var collection = collections.find(function(c) { return c.name === 'ruler_v2'; });
  
  if (!collection) {
    throw new Error('ruler_v2 컬렉션을 찾을 수 없습니다');
  }
  
  // 테마 정보가 없으면 기본 semantic 토큰 적용
  if (!msg.theme) {
    var allVariables = await figma.variables.getLocalVariablesAsync('COLOR');
    var semanticVariables = allVariables.filter(function(v) {
      return v.name.startsWith('semantic/') && v.variableCollectionId === collection.id;
    });
    
    var backgroundTokenPriority = [
      'semantic/fill/surface-contents',
      'semantic/background/default',
      'semantic/fill/surface-floating'
    ];
    
    var targetVar = null;
    for (var p = 0; p < backgroundTokenPriority.length; p++) {
      targetVar = semanticVariables.find(function(v) {
        return v.name === backgroundTokenPriority[p];
      });
      if (targetVar) break;
    }
    
    var appliedCount = 0;
    
    for (var i = 0; i < selection.length; i++) {
      var node = selection[i];
      if (node.type === 'FRAME' || node.type === 'COMPONENT' || node.type === 'INSTANCE') {
        if (targetVar && 'fills' in node) {
          node.fills = [{
            type: 'SOLID',
            boundVariables: {
              'color': { type: 'VARIABLE_ALIAS', id: targetVar.id }
            }
          }];
          appliedCount++;
        }
      }
    }
    
    figma.notify((targetVar ? targetVar.name : 'none') + ' semantic 토큰이 ' + appliedCount + '개 Frame에 적용되었습니다');
    return;
  }
  
  // 테마 정보가 있으면 handleApplyThemeColorsToFrame과 동일한 방식 사용
  var theme = msg.theme;
  var applicationMode = theme.applicationMode || 'accent-on-bg-off';
  
  
  // 동적 매핑 계산
  var closestStep = findClosestStep(theme.scaleColors.light, theme.baseColor);
  var effectiveMode2 = (applicationMode === 'custom-background') ? 'accent-on-bg-off' : applicationMode;
  var mappings = getDynamicMappings(closestStep, theme.themeName, effectiveMode2, theme.baseColor);
  if (applicationMode !== 'custom-background' && theme.overrideRecommendedStep) {
    mappings['semantic/background/default'] = 'REF:' + theme.themeName + theme.overrideRecommendedStep;
    mappings['semantic/fill/silent'] = 'REF:' + theme.themeName + theme.overrideRecommendedStep;
    mappings['semantic/fill/silent-hover'] = 'REF:' + theme.themeName + adjustStep(theme.overrideRecommendedStep, -1);
    mappings['semantic/fill/silent-pressed'] = 'REF:' + theme.themeName + adjustStep(theme.overrideRecommendedStep, -1);
  }
  
  // 커스텀 배경 모드: 변수 생성 없이 배경만 특수 토큰으로 치환 (silent는 스킵)
  if (applicationMode === 'custom-background' && theme.customBackgroundColor) {
    mappings['semantic/background/default'] = 'CUSTOM_BACKGROUND';
    mappings['semantic/background/gradient-default'] = 'CUSTOM_BACKGROUND';
  }
  
  var importedLibraryVariables = await ensureLibraryVariablesForMappings(mappings, theme);
  
  // 모든 변수 가져오기
  var allVariables = await figma.variables.getLocalVariablesAsync('COLOR');
  if (importedLibraryVariables && importedLibraryVariables.length) {
    importedLibraryVariables.forEach(function(variable) {
      if (!variable) return;
      var exists = allVariables.some(function(v) { return v.id === variable.id; });
      if (!exists) {
        allVariables.push(variable);
      }
    });
  }
  var localVarByName = new Map();
  var localVarById = new Map();
  for (var lv = 0; lv < allVariables.length; lv++) {
    var variable = allVariables[lv];
    if (variable && variable.variableCollectionId === collection.id) {
      localVarByName.set(variable.name, variable);
      localVarById.set(variable.id, variable);
    }
  }
  var appliedCount = 0;
  
  
  // handleApplyThemeColorsToFrame과 동일한 findTokenFromMapping 함수
  function findTokenFromMapping(mappingValue) {
    if (!mappingValue) return null;
    
    if (mappingValue.startsWith('REF:')) {
      var refString = mappingValue.replace('REF:', '');
      var refThemeName2 = theme.themeName;
      var step2 = NaN;

      if (refString.startsWith(theme.themeName)) {
        var stepString2 = refString.substring(theme.themeName.length);
        step2 = parseInt(stepString2);
      } else {
        var matchDigits2 = refString.match(/(\d{1,3})$/);
        if (matchDigits2) {
          step2 = parseInt(matchDigits2[1], 10);
          var namePart2 = refString.slice(0, refString.length - matchDigits2[1].length);
          if (namePart2 && namePart2 !== '') {
            refThemeName2 = namePart2.endsWith('-') ? namePart2.slice(0, -1) : namePart2;
          }
        } else {
          step2 = parseInt(refString, 10);
        }
      }

      if (!isNaN(step2)) {
        var primaryName2 = 'scale/' + refThemeName2 + '-' + step2;
        var foundPrimary2 = normalizeVariableLookup(allVariables, collection.id, primaryName2);
        if (foundPrimary2) return foundPrimary2;

        if (refThemeName2 !== theme.themeName) {
          var fallbackName2 = 'scale/' + theme.themeName + '-' + step2;
          return normalizeVariableLookup(allVariables, collection.id, fallbackName2);
        }
      }
    } else if (mappingValue.startsWith('GRAY:')) {
      var grayStep = parseInt(mappingValue.replace('GRAY:', ''));
      var grayVarName = 'scale/gray-' + grayStep;
      return normalizeVariableLookup(allVariables, collection.id, grayVarName);
    } else if (mappingValue.startsWith('ALPHA:')) {
      var alphaStep = parseInt(mappingValue.replace('ALPHA:', '').replace(theme.themeName, ''));
      
      var alphaVarName = 'scale/' + theme.themeName + '-alpha-' + alphaStep;
      return normalizeVariableLookup(allVariables, collection.id, alphaVarName);
    } else if (mappingValue.startsWith('GRAY-ALPHA:')) {
      var grayAlphaStep = parseInt(mappingValue.replace('GRAY-ALPHA:', ''));
      var grayAlphaVarName = 'scale/gray-alpha-' + grayAlphaStep;
      return normalizeVariableLookup(allVariables, collection.id, grayAlphaVarName);
    } else if (mappingValue.startsWith('ON-COLOR-ALPHA:')) {
      var onColorStep = parseInt(mappingValue.replace('ON-COLOR-ALPHA:', ''));
      var onColorVarName = 'scale/on-color-alpha-' + onColorStep;
      return normalizeVariableLookup(allVariables, collection.id, onColorVarName);
    } else if (mappingValue.startsWith('STATIC-WHITE-ALPHA:')) {
      var staticWhiteStep = parseInt(mappingValue.replace('STATIC-WHITE-ALPHA:', ''));
      var staticWhiteVarName = 'static/static-white-alpha-' + staticWhiteStep;
      console.log('🔍 STATIC-WHITE-ALPHA Debug:', mappingValue, '→', staticWhiteVarName);
      var foundVar = normalizeVariableLookup(allVariables, collection.id, staticWhiteVarName);
      console.log('🔍 Found variable:', foundVar ? foundVar.name : 'NOT FOUND');
      return foundVar;
    } else if (mappingValue.startsWith('STATIC-BLACK-ALPHA:')) {
      var staticBlackStep = parseInt(mappingValue.replace('STATIC-BLACK-ALPHA:', ''));
      var staticBlackVarName = 'static/static-black-alpha-' + staticBlackStep;
      return normalizeVariableLookup(allVariables, collection.id, staticBlackVarName);
    } else if (mappingValue === 'CUSTOM_BACKGROUND') {
      if (!theme.customBackgroundColor) return null;
      var baseInfo2 = getCustomBackgroundScaleInfo(theme);
      if (!baseInfo2.scaleColors || baseInfo2.scaleColors.length === 0) return null;
      var nearestBg2 = findClosestStep(baseInfo2.scaleColors, theme.customBackgroundColor);
      var varNameBg2 = 'scale/' + baseInfo2.themeName + '-' + nearestBg2;
      var bgVar2 = normalizeVariableLookup(allVariables, collection.id, varNameBg2);
      if (!bgVar2 && baseInfo2.themeName !== theme.themeName) {
        var fallbackBg2 = 'scale/' + theme.themeName + '-' + nearestBg2;
        bgVar2 = normalizeVariableLookup(allVariables, collection.id, fallbackBg2);
      }
      return bgVar2;
    } else if (mappingValue.startsWith('CUSTOM_BACKGROUND_LOW')) {
      var lowInfo2 = resolveCustomBackgroundLowColor(theme, mappingValue);
      if (!lowInfo2 || lowInfo2.step === null) return null;
      var lowThemeName2 = lowInfo2.themeName || theme.themeName;
      var lowVarName2 = 'scale/' + lowThemeName2 + '-' + lowInfo2.step;
      var lowVar2 = normalizeVariableLookup(allVariables, collection.id, lowVarName2);
      if (!lowVar2 && lowThemeName2 !== theme.themeName) {
        var fallbackLow2 = 'scale/' + theme.themeName + '-' + lowInfo2.step;
        lowVar2 = normalizeVariableLookup(allVariables, collection.id, fallbackLow2);
      }
      return lowVar2 || null;
    } else if (mappingValue.startsWith('CUSTOM_BACKGROUND_ALPHA')) {
      return null;
    } else if (mappingValue === 'CUSTOM_SILENT' || mappingValue === 'CUSTOM_SILENT_HOVER' || mappingValue === 'CUSTOM_SILENT_PRESSED') {
      var silentInfo2 = resolveCustomSilentColor(theme, mappingValue);
      if (!silentInfo2) return null;
      if (mappingValue === 'CUSTOM_SILENT') {
        return null;
      }
      if (silentInfo2.step === null) return null;
      var silentThemeName2 = silentInfo2.themeName || theme.themeName;
      var silentVarName2 = 'scale/' + silentThemeName2 + '-' + silentInfo2.step;
      var silentVar2 = normalizeVariableLookup(allVariables, collection.id, silentVarName2);
      if (!silentVar2 && silentThemeName2 !== theme.themeName) {
        var fallbackSilent2 = 'scale/' + theme.themeName + '-' + silentInfo2.step;
        silentVar2 = normalizeVariableLookup(allVariables, collection.id, fallbackSilent2);
      }
      return silentVar2 || null;
    }
    
    return null;
  }
  
  // handleApplyThemeColorsToFrame과 동일한 재귀적 토큰 교체 로직
  function replaceTokensInNode(node, depth) {
    var indent = '';
    for (var d = 0; d < depth; d++) indent += '  ';
    
    
    // 현재 노드의 fills 처리
    if ('fills' in node && node.fills && node.fills.length > 0) {
      for (var f = 0; f < node.fills.length; f++) {
        var fill = node.fills[f];
        if (fill.boundVariables && fill.boundVariables.color && fill.boundVariables.color.id) {
          var currentVar = allVariables.find(function(v) {
            return v.id === fill.boundVariables.color.id;
          });
          
          if (currentVar && currentVar.name.startsWith('semantic/')) {
            
            var mappedValue = mappings[currentVar.name];
            if (mappedValue) {
              if (mappedValue === 'CUSTOM_BACKGROUND' && theme.customBackgroundColor) {
                var fillBgColor = hexToFigmaRGB(theme.customBackgroundColor);
                var nf = node.fills.slice();
                nf[f] = { type: 'SOLID', color: fillBgColor };
                node.fills = nf;
                appliedCount++;
                continue;
              }

              if (mappedValue.startsWith('CUSTOM_SILENT') && theme.customBackgroundColor) {
                var fillSilentInfo = resolveCustomSilentColor(theme, mappedValue);
                var fillSilentHex = (fillSilentInfo && fillSilentInfo.hex) ? fillSilentInfo.hex : theme.customBackgroundColor;
                var fillSilentRgb = hexToFigmaRGB(fillSilentHex);
                var nfSilent = node.fills.slice();
                nfSilent[f] = { type: 'SOLID', color: fillSilentRgb };
                node.fills = nfSilent;
                appliedCount++;
                continue;
              }

              if (mappedValue.startsWith('CUSTOM_BACKGROUND_LOW') && theme.customBackgroundColor) {
                var fillLowInfo = resolveCustomBackgroundLowColor(theme, mappedValue);
                var fillLowHex = (fillLowInfo && fillLowInfo.hex) ? fillLowInfo.hex : theme.customBackgroundColor;
                var fillLowRgb = hexToFigmaRGB(fillLowHex);
                var nfLow = node.fills.slice();
                nfLow[f] = { type: 'SOLID', color: fillLowRgb };
                node.fills = nfLow;
                appliedCount++;
                continue;
              }

              if (mappedValue.startsWith('CUSTOM_BACKGROUND_ALPHA') && theme.customBackgroundColor) {
                var alphaInfo = resolveCustomBackgroundAlpha(theme, mappedValue);
                if (alphaInfo) {
                  var nfAlpha = node.fills.slice();
                  nfAlpha[f] = {
                    type: 'SOLID',
                    color: alphaInfo.color,
                    opacity: alphaInfo.opacity
                  };
                  node.fills = nfAlpha;
                  appliedCount++;
                  continue;
                }
              }

              var newToken = findTokenFromMapping(mappedValue);
              if (newToken) {
                var newFills = node.fills.slice();
                newFills[f] = {
                  type: 'SOLID',
                  boundVariables: {
                    'color': {
                      type: 'VARIABLE_ALIAS',
                      id: newToken.id
                    }
                  }
                };
                node.fills = newFills;
                appliedCount++;
              } else {
              }
            } else {
            }
          }
        }
      }
    }
    
    // 자식 노드들도 재귀적으로 처리
    if ('children' in node) {
      for (var c = 0; c < node.children.length; c++) {
        replaceTokensInNode(node.children[c], depth + 1);
      }
    }
  }
  
  // 선택된 노드들을 재귀적으로 처리
  for (var i = 0; i < selection.length; i++) {
    replaceTokensInNode(selection[i], 0);
  }
  
  figma.notify('테마 토큰이 ' + appliedCount + '개 요소에 적용되었습니다');
}

// Custom Mode 적용 핸들러 - 최상위 프레임에만 적용, 자식은 상속
async function handleApplyCustomModeToFrame(msg) {
  var targetModeName = msg.modeName;
  var selection = figma.currentPage.selection;
  
  if (selection.length === 0) {
    figma.notify('Frame을 선택해주세요');
    return;
  }
  
  var collections = await figma.variables.getLocalVariableCollectionsAsync();
  var collection = collections.find(function(c) { return c.name === 'ruler_v2'; });
  
  if (!collection) {
    throw new Error('ruler_v2 컬렉션을 찾을 수 없습니다');
  }
  
  var customMode = collection.modes.find(function(m) { return m.name === targetModeName; });
  
  if (!customMode) {
    throw new Error('필요한 모드를 찾을 수 없습니다');
  }
  
  // 최상위 루트 노드만 추출 (다른 선택된 노드에 포함되지 않는 노드들)
  var rootNodes = [];
  for (var i = 0; i < selection.length; i++) {
    var isRoot = true;
    for (var j = 0; j < selection.length; j++) {
      if (i !== j && isAncestor(selection[j], selection[i])) {
        isRoot = false;
        break;
      }
    }
    if (isRoot) {
      rootNodes.push(selection[i]);
    }
  }
  
  var appliedCount = 0;
  var clearedCount = 0;
  
  // 노드가 다른 노드의 조상인지 확인
  function isAncestor(possibleAncestor, node) {
    var parent = node.parent;
    while (parent) {
      if (parent === possibleAncestor) {
        return true;
      }
      parent = parent.parent;
    }
    return false;
  }
  
  // 자식 노드들의 명시적 모드 설정 제거
  function clearChildrenModes(node) {
    if ('children' in node && node.children) {
      for (var i = 0; i < node.children.length; i++) {
        var child = node.children[i];
        
        // Frame 타입인 경우 명시적 모드 제거 (상속 상태로 변경)
        if (child.type === 'FRAME' || child.type === 'COMPONENT' || child.type === 'INSTANCE') {
          try {
            // 명시적 모드 제거 - null을 설정하면 상속 상태가 됨
            child.setExplicitVariableModeForCollection(collection, null);
            clearedCount++;
          } catch (e) {
            // 이미 상속 상태인 경우 무시
          }
        }
        
        // 재귀적으로 모든 자식 처리
        clearChildrenModes(child);
      }
    }
  }
  
  // 각 루트 노드 처리
  for (var i = 0; i < rootNodes.length; i++) {
    var rootNode = rootNodes[i];
    
    // 루트가 Frame 타입인지 확인
    if (rootNode.type === 'FRAME' || rootNode.type === 'COMPONENT' || rootNode.type === 'INSTANCE') {
      // 최상위 프레임에만 모드 적용
      rootNode.setExplicitVariableModeForCollection(collection, customMode.modeId);
      appliedCount++;
      
      // 모든 자식들의 명시적 모드 설정 제거
      clearChildrenModes(rootNode);
    } else {
      console.warn('선택된 노드가 Frame 타입이 아님:', rootNode.type);
    }
  }
  
  figma.ui.postMessage({
    type: 'custom-mode-applied',
    success: true,
    count: appliedCount,
    cleared: clearedCount,
    modeName: targetModeName
  });
  
  var message = targetModeName + ' 모드가 ' + appliedCount + '개 최상위 Frame에 적용되었습니다';
  if (clearedCount > 0) {
    message += ' (' + clearedCount + '개 자식 Frame 상속 처리)';
  }
  
  figma.notify(message);
}

// 톤 매칭 핸들러
async function handleToneMatching(msg) {
  var suggestions = generateToneMatchingSuggestions(msg.referenceColor, msg.inputColor);
  
  figma.ui.postMessage({
    type: 'tone-matching-complete',
    suggestions: suggestions,
    originalColor: msg.inputColor,
    referenceColor: msg.referenceColor
  });
}

// Mapping 정보 표시 핸들러 - 선택된 Frame 오른쪽에 mapping 정보 표시
async function handleAnnotationControl(msg) {
  
  var selection = figma.currentPage.selection;
  
  if (msg.action === 'show-mapping') {
    if (selection.length === 0) {
      figma.notify('Mapping 정보를 표시할 Frame을 선택해주세요');
      return;
    }
    
    var theme, applicationMode, mappings;
    
    if (!msg.theme) {
      // 테마 정보가 없을 때는 기본값으로 처리
      figma.notify('테마 정보가 없어 기본 매핑을 표시합니다');
      
      // 기본 매핑 생성 (예시)
      mappings = {
        'semantic/background/default': 'GRAY:50',
        'semantic/fill/surface-contents': 'ALPHA:theme150',
        'semantic/fill/primary': 'REF:theme500',
        'semantic/text/primary': 'GRAY:900',
        'semantic/border/divider': 'ON-COLOR-ALPHA:200'
      };
      applicationMode = 'default';
    } else {
      theme = msg.theme;
      applicationMode = theme.applicationMode || 'accent-on-bg-off';
      
      // 동적 매핑 계산
      var closestStep = findClosestStep(theme.scaleColors.light, theme.baseColor);
      mappings = getDynamicMappings(closestStep, theme.themeName, applicationMode, theme.baseColor);
    }
    
    var mappingInfoCount = 0;
    
    try {
      // 폰트 로드
      await figma.loadFontAsync({ family: 'Inter', style: 'Regular' });
    } catch (e) {
      await figma.loadFontAsync({ family: 'Roboto', style: 'Regular' });
    }
    
    for (var i = 0; i < selection.length; i++) {
      var selectedFrame = selection[i];
      
      if (selectedFrame.type === 'FRAME' || selectedFrame.type === 'COMPONENT' || selectedFrame.type === 'INSTANCE') {
        // Frame 오른쪽에 mapping 정보 표시할 위치 계산
        var infoX = selectedFrame.x + selectedFrame.width + 20;
        var infoY = selectedFrame.y;
        
        // 주요 mapping 정보들 수집
        var importantMappings = [
          'semantic/background/default',
          'semantic/fill/surface-contents',
          'semantic/fill/primary',
          'semantic/text/primary',
          'semantic/border/divider'
        ];
        
        var mappingText = 'Mapping Info (' + applicationMode + ')\n';
        if (theme) {
          mappingText += 'Theme: ' + theme.themeName + '\n';
          mappingText += 'Step: ' + closestStep + '\n';
        }
        mappingText += '\n';
        
        // handleApplyThemeColorsToFrame과 동일한 findTokenFromMapping 함수
        function findTokenFromMapping(mappingValue) {
          if (!mappingValue) return null;
          
          if (mappingValue.startsWith('REF:')) {
            var refString = mappingValue.replace('REF:', '');
            var step;
            
            if (theme && refString.startsWith(theme.themeName)) {
              var stepString = refString.substring(theme.themeName.length);
              step = parseInt(stepString);
            } else {
              step = parseInt(refString);
            }
            
            if (step && theme) {
              return 'scale/' + theme.themeName + '-' + step;
            }
            return 'scale/theme-' + step;
          } else if (mappingValue.startsWith('GRAY:')) {
            var grayStep = parseInt(mappingValue.replace('GRAY:', ''));
            return 'scale/gray-' + grayStep;
          } else if (mappingValue.startsWith('ALPHA:')) {
            if (theme) {
              var alphaStep = parseInt(mappingValue.replace('ALPHA:', '').replace(theme.themeName, ''));
              return 'scale/' + theme.themeName + '-alpha-' + alphaStep;
            }
            var alphaStep = parseInt(mappingValue.replace('ALPHA:theme', ''));
            return 'scale/theme-alpha-' + alphaStep;
          } else if (mappingValue.startsWith('GRAY-ALPHA:')) {
            var grayAlphaStep = parseInt(mappingValue.replace('GRAY-ALPHA:', ''));
            return 'scale/gray-alpha-' + grayAlphaStep;
          } else if (mappingValue.startsWith('ON-COLOR-ALPHA:')) {
            var onColorStep = parseInt(mappingValue.replace('ON-COLOR-ALPHA:', ''));
            return 'scale/on-color-alpha-' + onColorStep;
          } else if (mappingValue.startsWith('STATIC-WHITE-ALPHA:')) {
            var staticWhiteStep = parseInt(mappingValue.replace('STATIC-WHITE-ALPHA:', ''));
            return 'static/static-white-alpha-' + staticWhiteStep;
          } else if (mappingValue.startsWith('STATIC-BLACK-ALPHA:')) {
            var staticBlackStep = parseInt(mappingValue.replace('STATIC-BLACK-ALPHA:', ''));
            return 'static/static-black-alpha-' + staticBlackStep;
          }
          
          return mappingValue; // fallback
        }
        
        for (var m = 0; m < importantMappings.length; m++) {
          var tokenName = importantMappings[m];
          var mappingValue = mappings[tokenName];
          if (mappingValue) {
            // CSS 변수 형식으로 표시: --semantic-text/secondary: var(--scale-gray-700);
            var semanticVar = '--' + tokenName;
            var actualTokenName = findTokenFromMapping(mappingValue);
            var scaleVar = '--' + actualTokenName;
            mappingText += semanticVar + ': var(' + scaleVar + ');\n';
          }
        }
        
        // mapping 정보 텍스트 노드 생성
        var mappingInfoNode = figma.createText();
        mappingInfoNode.characters = mappingText;
        mappingInfoNode.fontSize = 10;
        mappingInfoNode.fills = [{ type: 'SOLID', color: { r: 0.2, g: 0.2, b: 0.2 } }];
        
        // Auto Layout 프레임 생성
        var backgroundFrame = figma.createFrame();
        backgroundFrame.name = 'Mapping Info - ' + selectedFrame.name;
        backgroundFrame.x = infoX;
        backgroundFrame.y = infoY;
        
        // Auto Layout 설정
        backgroundFrame.layoutMode = 'VERTICAL';
        backgroundFrame.paddingTop = 16;
        backgroundFrame.paddingBottom = 16;
        backgroundFrame.paddingLeft = 16;
        backgroundFrame.paddingRight = 16;
        backgroundFrame.itemSpacing = 8;
        backgroundFrame.primaryAxisSizingMode = 'AUTO';
        backgroundFrame.counterAxisSizingMode = 'AUTO';
        
        backgroundFrame.fills = [{ 
          type: 'SOLID', 
          color: { r: 1, g: 1, b: 0.9 }, // 연한 노란색 배경
          opacity: 0.9
        }];
        backgroundFrame.cornerRadius = 8;
        
        // 그림자 효과 추가
        backgroundFrame.effects = [{
          type: 'DROP_SHADOW',
          color: { r: 0, g: 0, b: 0, a: 0.1 },
          offset: { x: 0, y: 2 },
          radius: 4,
          visible: true,
          blendMode: 'NORMAL'
        }];
        
        // 같은 부모에 추가
        if (selectedFrame.parent && 'appendChild' in selectedFrame.parent) {
          selectedFrame.parent.appendChild(backgroundFrame);
          backgroundFrame.appendChild(mappingInfoNode);
        } else {
          figma.currentPage.appendChild(backgroundFrame);
          backgroundFrame.appendChild(mappingInfoNode);
        }
        
        mappingInfoCount++;
      }
    }
    
    figma.notify(mappingInfoCount + '개 Frame에 Mapping 정보가 표시되었습니다');
    
  }
  
  // UI로 응답 전송
  figma.ui.postMessage({
    type: 'annotation-control-response',
    success: true,
    action: msg.action
  });
}

// =====================================
// 메인 메시지 핸들러
// =====================================

figma.ui.onmessage = async function(msg) {
  
  try {
    if (msg.type === 'create-variables') {
      await handleCreateVariables(msg);
    } else if (msg.type === 'create-styles') {
      await handleCreateStyles(msg);
    } else if (msg.type === 'create-custom-theme') {
      await handleCreateCustomTheme(msg);
    } else if (msg.type === 'apply-custom-mode-to-frame') {
      await handleApplyCustomModeToFrame(msg);
    } else if (msg.type === 'apply-semantic-to-frame') {
      await handleApplySemanticToFrame(msg);
    } else if (msg.type === 'apply-theme-colors-to-frame') {
      await handleApplyThemeColorsToFrame(msg);
    } else if (msg.type === 'check-library-sync') {
      await handleCheckLibrarySync();
    } else if (msg.type === 'sync-library-variables') {
      await handleSyncLibraryVariables();
    } else if (msg.type === 'generate-tone-matching') {
      await handleToneMatching(msg);
    } else if (msg.type === 'annotation-control') {
      await handleAnnotationControl(msg);
    } else if (msg.type === 'check-frame-selection') {
      await handleCheckFrameSelection(msg);
    } else if (msg.type === 'activate-eyedropper') {
      if (typeof figma.pickColorAsync !== 'function') {
        figma.ui.postMessage({
          type: 'eyedropper-error',
          targetId: msg.targetId,
          message: 'pickColorAsync is not supported in this Figma version.'
        });
        return;
      }

      try {
        var pickedOptions = null;
        if (msg.currentColor && /^#[0-9A-F]{6}$/i.test(msg.currentColor)) {
          pickedOptions = {
            color: hexToFigmaRGB(msg.currentColor),
            mode: 'RGB'
          };
        }

        var pickResult = pickedOptions ? await figma.pickColorAsync(pickedOptions) : await figma.pickColorAsync();
        if (!pickResult) {
          figma.ui.postMessage({
            type: 'eyedropper-cancelled',
            targetId: msg.targetId
          });
          return;
        }

        var pickedColor = pickResult.color || pickResult;
        var opacity = typeof pickResult.opacity === 'number'
          ? pickResult.opacity
          : (typeof pickedColor.a === 'number' ? pickedColor.a : 1);

        figma.ui.postMessage({
          type: 'eyedropper-picked',
          targetId: msg.targetId,
          hex: figmaRGBToHex(pickedColor),
          rgba: {
            r: pickedColor.r,
            g: pickedColor.g,
            b: pickedColor.b,
            a: opacity
          }
        });
      } catch (error) {
        console.error('pickColorAsync error:', error);
        figma.ui.postMessage({
          type: 'eyedropper-error',
          targetId: msg.targetId,
          message: error && error.message ? error.message : String(error)
        });
      }
    }
  } catch (error) {
    console.error('Error handling message:', error);
    figma.notify('Error: ' + error.message, { error: true });
  }
};

// =====================================
// 초기화
// =====================================

// 초기화 메시지
setTimeout(function() {
  figma.ui.postMessage({ 
    type: 'plugin-ready', 
    message: 'Plugin initialized successfully',
    eyedropperSupported: typeof figma.pickColorAsync === 'function'
  });
}, 100);
