// Figma Plugin Backend Code - Version 12 (Complete Custom Theme Logic)
console.log('Backend script loading...');

// UI ÌëúÏãú
figma.showUI(__html__, { 
  width: 360, 
  height: 700,
  themeColors: true 
});

// =====================================
// ÏÉâÏÉÅ ÏïàÏ†Ñ Î†àÏùº Ìï®ÏàòÎì§ (ÎÑ§Ïò®/Í≥†Ï±ÑÎèÑ Ï≤òÎ¶¨)
// =====================================

// HSL Ï±ÑÎèÑ Ï°∞Ï†ï
function setSaturation(hex, targetSaturation) {
  var hsl = hexToHsl(hex);
  hsl[1] = Math.min(hsl[1], targetSaturation);
  return hslToHex(hsl[0], hsl[1], hsl[2]);
}

// ÎÑ§Ïò® ÏÉâÏÉÅ Í∞êÏßÄ
function isNeon(hex) {
  var hsl = hexToHsl(hex);
  var L = hsl[2];
  var S = hsl[1];
  
  // Îß§Ïö∞ Î∞ùÍ≥†(L‚â•85) Ï±ÑÎèÑÍ∞Ä ÎÜíÏùÄ(S‚â•60) Í≤ΩÏö∞ ÎÑ§Ïò®ÏúºÎ°ú Í∞ÑÏ£º
  if (L >= 85 && S >= 60) {
    return true;
  }
  
  // Ï∂îÍ∞Ä Ï°∞Í±¥: Îß§Ïö∞ Î∞ùÏùÄ ÎÖ∏Îûë/ÎÖπÏÉâ Í≥ÑÏó¥
  var H = hsl[0];
  if (L >= 80 && S >= 40 && (H >= 50 && H <= 150)) {
    return true;
  }
  
  return false;
}

// YÍ∞í Í≥ÑÏÇ∞ (sRGB relative luminance, 0~1)
function getYValue(hex) {
  var rgb = hexToRgb(hex);
  return relativeLuminance(rgb);
}

// =====================================
// WCAG ÎåÄÎπÑÎπÑÏú® Í≥ÑÏÇ∞ Ìï®ÏàòÎì§
// =====================================

// sRGBÎ•º ÏÑ†Ìòï RGBÎ°ú Î≥ÄÌôò
function srgbToLinear(n) {
  // nÏùÄ 0-1 Î≤îÏúÑ
  if (n <= 0.03928) {
    return n / 12.92;
  } else {
    return Math.pow((n + 0.055) / 1.055, 2.4);
  }
}

// ÏÉÅÎåÄ ÌúòÎèÑ Í≥ÑÏÇ∞
function relativeLuminance(rgb) {
  // rgbÎäî 0-255 Î≤îÏúÑ
  var r = srgbToLinear(rgb.r / 255);
  var g = srgbToLinear(rgb.g / 255);
  var b = srgbToLinear(rgb.b / 255);
  
  return 0.2126 * r + 0.7152 * g + 0.0722 * b;
}

// ÎåÄÎπÑÎπÑÏú® Í≥ÑÏÇ∞
function contrastRatio(hex1, hex2) {
  var rgb1 = hexToRgb(hex1);
  var rgb2 = hexToRgb(hex2);
  
  var l1 = relativeLuminance(rgb1);
  var l2 = relativeLuminance(rgb2);
  
  var lighter = Math.max(l1, l2);
  var darker = Math.min(l1, l2);
  
  return (lighter + 0.05) / (darker + 0.05);
}

// HEXÎ•º RGBÎ°ú Î≥ÄÌôò (Í∞ÑÎã®Ìïú Î≤ÑÏ†Ñ)
function hexToRgb(hex) {
  var cleanHex = hex.replace('#', '');
  
  // 3ÏûêÎ¶¨ HEX Ï≤òÎ¶¨
  if (cleanHex.length === 3) {
    cleanHex = cleanHex.split('').map(function(char) { 
      return char + char; 
    }).join('');
  }
  
  // 8ÏûêÎ¶¨ HEXÏù∏ Í≤ΩÏö∞ Ïïû 6ÏûêÎ¶¨Îßå ÏÇ¨Ïö©
  if (cleanHex.length === 8) {
    cleanHex = cleanHex.substring(0, 6);
  }
  
  var result = /^([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(cleanHex);
  if (!result) {
    return { r: 0, g: 0, b: 0 };
  }
  
  return {
    r: parseInt(result[1], 16),
    g: parseInt(result[2], 16),
    b: parseInt(result[3], 16)
  };
}

// =====================================
// Ïú†Ìã∏Î¶¨Ìã∞ Ìï®ÏàòÎì§
// =====================================

// Figma RGB Î≥ÄÌôò
function hexToFigmaRGB(hex) {
  var cleanHex = hex.replace('#', '');
  
  if (cleanHex.length === 3) {
    cleanHex = cleanHex.split('').map(function(char) { 
      return char + char; 
    }).join('');
  }
  
  var result = /^([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(cleanHex);
  if (!result) {
    return { r: 0, g: 0, b: 0 };
  }
  
  return {
    r: parseInt(result[1], 16) / 255,
    g: parseInt(result[2], 16) / 255,
    b: parseInt(result[3], 16) / 255
  };
}

// HSL Î≥ÄÌôò Ìï®ÏàòÎì§
function hexToHsl(hex) {
  var r = parseInt(hex.slice(1, 3), 16) / 255;
  var g = parseInt(hex.slice(3, 5), 16) / 255;
  var b = parseInt(hex.slice(5, 7), 16) / 255;

  var max = Math.max(r, g, b);
  var min = Math.min(r, g, b);
  var h, s, l = (max + min) / 2;

  if (max === min) {
    h = s = 0;
  } else {
    var d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r: h = (g - b) / d + (g < b ? 6 : 0); break;
      case g: h = (b - r) / d + 2; break;
      case b: h = (r - g) / d + 4; break;
    }
    h /= 6;
  }

  return [h * 360, s * 100, l * 100];
}

function hslToHex(h, s, l) {
  h = h % 360;
  if (h < 0) h += 360;
  s = Math.max(0, Math.min(100, s));
  l = Math.max(0, Math.min(100, l));
  
  h /= 360;
  s /= 100;
  l /= 100;
  
  var a = s * Math.min(l, 1 - l);
  var f = function(n) {
    var k = (n + h * 12) % 12;
    return l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
  };
  
  var r = Math.round(f(0) * 255);
  var g = Math.round(f(8) * 255);
  var b = Math.round(f(4) * 255);
  
  return "#" + [r, g, b].map(function(x) {
    var hex = x.toString(16);
    return hex.length === 1 ? "0" + hex : hex;
  }).join("");
}

// =====================================
// Figma Î≥ÄÏàò Í¥ÄÎ†® Ìï®ÏàòÎì§
// =====================================

// Î≥ÄÏàò Ï∞æÍ∏∞/ÏÉùÏÑ±
async function findOrCreateVariable(name, collection, type) {
  var existingVars = await figma.variables.getLocalVariablesAsync(type);
  var existing = existingVars.find(function(v) {
    return v.name === name && v.variableCollectionId === collection.id;
  });
  
  if (existing) {
    return existing;
  } else {
    return figma.variables.createVariable(name, collection, type);
  }
}

// Î™®Îìú Ï∞æÍ∏∞/ÏÉùÏÑ±
function findOrCreateMode(collection, modeName) {
  var existingMode = collection.modes.find(function(mode) { 
    return mode.name === modeName; 
  });
  if (existingMode) {
    return existingMode.modeId;
  } else {
    return collection.addMode(modeName);
  }
}

// Í∞ÄÏû• Í∞ÄÍπåÏö¥ step Ï∞æÍ∏∞ (Î™®ÎìúÎ≥Ñ ÎèÖÎ¶Ω Í≥ÑÏÇ∞)
function findClosestStep(scaleColors, inputHex) {
  var inputHsl = hexToHsl(inputHex);
  var inputLightness = inputHsl[2];
  var closestStep = 500;
  var minDifference = Infinity;
  
  for (var i = 0; i < scaleColors.length; i++) {
    var scaleHsl = hexToHsl(scaleColors[i].hex);
    var diff = Math.abs(scaleHsl[2] - inputLightness);
    if (diff < minDifference) {
      minDifference = diff;
      closestStep = scaleColors[i].step;
    }
  }
  
  console.log('[CLOSEST] Input L:', inputLightness.toFixed(2), '‚Üí Step:', closestStep, 'Diff:', minDifference.toFixed(2));
  return closestStep;
}

// =====================================
// ÎèôÏ†Å Îß§Ìïë Ìï®Ïàò
// =====================================

// Îã®Í≥Ñ Ï°∞Ï†ï Ìó¨Ìçº Ìï®Ïàò (¬±Îã®Í≥Ñ Ïù¥Îèô with ÌÅ¥Îû®Ìïë)
function adjustStep(currentStep, adjustment) {
  var steps = [50, 75, 100, 150, 200, 300, 400, 500, 600, 700, 800, 900, 950];
  var currentIndex = steps.indexOf(currentStep);
  
  if (currentIndex === -1) {
    // ÌòÑÏû¨ Îã®Í≥ÑÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏúºÎ©¥ Í∞ÄÏû• Í∞ÄÍπåÏö¥ Îã®Í≥Ñ Ï∞æÍ∏∞
    var minDiff = Infinity;
    for (var i = 0; i < steps.length; i++) {
      var diff = Math.abs(steps[i] - currentStep);
      if (diff < minDiff) {
        minDiff = diff;
        currentIndex = i;
      }
    }
  }
  
  var newIndex = currentIndex + adjustment;
  
  // ÌÅ¥Îû®Ìïë: 50-950 Î≤îÏúÑ ÎÇ¥Î°ú Ï†úÌïú
  if (newIndex < 0) {
    console.log('[STEP ADJUST] Clamped to minimum: 50');
    return steps[0]; // 50
  }
  if (newIndex >= steps.length) {
    console.log('[STEP ADJUST] Clamped to maximum: 950');
    return steps[steps.length - 1]; // 950
  }
  
  console.log('[STEP ADJUST] From', currentStep, 'to', steps[newIndex], '(' + (adjustment > 0 ? '+' : '') + adjustment + ' steps)');
  return steps[newIndex];
}

// =====================================
// Light Î™®Îìú ÎèôÏ†Å Îß§Ìïë (200/300 Í∏∞Ï§Ä)
// =====================================

function getDynamicMappingsLight(closestStepLight, themeName, applicationMode) {
  var mappings = {};
  
  // 200/300 Í∏∞Ï§ÄÏúºÎ°ú Î∂ÑÎ•ò
  var isLightRange = closestStepLight < 300;  // 300 ÎØ∏Îßå (50, 75, 100, 150, 200)
  var isMidRange = closestStepLight >= 300;   // 300 Ïù¥ÏÉÅ (300, 400, 500, 600, 700, 800, 900)
  
  console.log('üåü [LIGHT] Step:', closestStepLight, '‚Üí', isLightRange ? '300 ÎØ∏Îßå' : '300 Ïù¥ÏÉÅ');
  
  // =====================================
  // ÏòµÏÖò 1: Í∞ïÏ°∞ ÏöîÏÜå ON / Î∞∞Í≤Ω ÏöîÏÜå OFF
  // =====================================
  if (applicationMode === 'accent-on-bg-off') {
    if (isLightRange) {
      // 200 Ïù¥Ìïò
      mappings['semantic/text/primary'] = 'GRAY:50';
      mappings['semantic/text/secondary'] = 'GRAY:100';
      mappings['semantic/text/tertiary'] = 'GRAY:200';
      mappings['semantic/text/disabled'] = 'GRAY:600';
      mappings['semantic/text/on-color'] = 'GRAY:900';
      
      mappings['semantic/background/default'] = 'REF:' + themeName + '300';
      mappings['semantic/fill/silent'] = 'REF:' + themeName + '300';
      
      mappings['semantic/fill/primary'] = 'REF:' + themeName + closestStepLight;
      mappings['semantic/fill/primary-hover'] = 'REF:' + themeName + adjustStep(closestStepLight, 1);
      mappings['semantic/fill/primary-pressed'] = 'REF:' + themeName + adjustStep(closestStepLight, 1);
      
      mappings['semantic/border/divider-strong'] = 'REF:' + themeName + closestStepLight;
      mappings['semantic/border/line-selected'] = 'REF:' + themeName + closestStepLight;
      mappings['semantic/border/divider'] = 'REF:' + themeName + '100';
      mappings['semantic/border/line'] = 'REF:' + themeName + '200';
      mappings['semantic/border/line-disabled'] = 'REF:' + themeName + '200';
      
      mappings['semantic/common/attention'] = 'REF:' + themeName + '700';
      mappings['semantic/common/attention-pressed'] = 'REF:' + themeName + '600';
      mappings['semantic/common/attention-hover'] = 'REF:' + themeName + '600';
      
    } else if (isMidRange) {
      // 300 Ïù¥ÏÉÅ
      mappings['semantic/text/primary'] = 'GRAY:900';
      mappings['semantic/text/secondary'] = 'GRAY-ALPHA:700';
      mappings['semantic/text/tertiary'] = 'GRAY-ALPHA:600';
      mappings['semantic/text/disabled'] = 'GRAY-ALPHA:400';
      mappings['semantic/text/on-color'] = 'GRAY:50';
      
      mappings['semantic/background/default'] = 'REF:' + themeName + '50';
      mappings['semantic/fill/silent'] = 'REF:' + themeName + '50';
      
      mappings['semantic/fill/primary'] = 'REF:' + themeName + closestStepLight;
      mappings['semantic/fill/primary-hover'] = 'REF:' + themeName + adjustStep(closestStepLight, -1);
      mappings['semantic/fill/primary-pressed'] = 'REF:' + themeName + adjustStep(closestStepLight, -1);
      
      mappings['semantic/border/divider-strong'] = 'REF:' + themeName + closestStepLight;
      mappings['semantic/border/line-selected'] = 'REF:' + themeName + closestStepLight;
      mappings['semantic/border/divider'] = 'REF:' + themeName + '100';
      mappings['semantic/border/line'] = 'REF:' + themeName + '200';
      mappings['semantic/border/line-disabled'] = 'REF:' + themeName + '100';
      
      mappings['semantic/common/attention'] = 'REF:' + themeName + adjustStep(closestStepLight, +2);
      mappings['semantic/common/attention-pressed'] = 'REF:' + themeName + adjustStep(closestStepLight, +1);
      mappings['semantic/common/attention-hover'] = 'REF:' + themeName + adjustStep(closestStepLight, +1);
    }
    
  // =====================================
  // ÏòµÏÖò 2: Í∞ïÏ°∞ ÏöîÏÜå ON / Î∞∞Í≤Ω Í≥†Ï†ï (gray50)
  // =====================================
  } else if (applicationMode === 'accent-on-bg-fixed') {
    if (isLightRange) {
      // 200 Ïù¥Ìïò
      mappings['semantic/text/primary'] = 'GRAY:900';
      mappings['semantic/text/secondary'] = 'GRAY:700';
      mappings['semantic/text/tertiary'] = 'GRAY:600';
      mappings['semantic/text/disabled'] = 'GRAY:400';
      mappings['semantic/text/on-color'] = 'GRAY:900';
      
      mappings['semantic/fill/primary'] = 'REF:' + themeName + closestStepLight;
      mappings['semantic/fill/primary-hover'] = 'REF:' + themeName + adjustStep(closestStepLight, 1);
      mappings['semantic/fill/primary-pressed'] = 'REF:' + themeName + adjustStep(closestStepLight, 1);
      
      mappings['semantic/common/attention'] = 'REF:' + themeName + closestStepLight;
      mappings['semantic/common/attention-pressed'] = 'REF:' + themeName + adjustStep(closestStepLight, 1);
      mappings['semantic/common/attention-hover'] = 'REF:' + themeName + adjustStep(closestStepLight, 1);
      
      mappings['semantic/border/divider'] = 'REF:' + themeName + '100';
      mappings['semantic/border/line'] = 'REF:' + themeName + '200';
      mappings['semantic/border/line-disabled'] = 'REF:' + themeName + '100';
      
    } else if (isMidRange) {
      // 300 Ïù¥ÏÉÅ (Ïä§ÌéôÏóêÏÑúÎäî 400Ïù¥ÏÉÅÏù¥ÏßÄÎßå Light Î™®ÎìúÎäî 300 Í∏∞Ï§Ä)
      mappings['semantic/text/primary'] = 'GRAY:900';
      mappings['semantic/text/secondary'] = 'GRAY:700';
      mappings['semantic/text/tertiary'] = 'GRAY:600';
      mappings['semantic/text/disabled'] = 'GRAY:400';
      mappings['semantic/text/on-color'] = 'GRAY:50';
      
      mappings['semantic/fill/primary'] = 'REF:' + themeName + closestStepLight;
      mappings['semantic/fill/primary-hover'] = 'REF:' + themeName + adjustStep(closestStepLight, -1);
      mappings['semantic/fill/primary-pressed'] = 'REF:' + themeName + adjustStep(closestStepLight, -1);
      
      mappings['semantic/common/attention'] = 'REF:' + themeName + closestStepLight;
      mappings['semantic/common/attention-pressed'] = 'REF:' + themeName + adjustStep(closestStepLight, -1);
      mappings['semantic/common/attention-hover'] = 'REF:' + themeName + adjustStep(closestStepLight, -1);
      
      mappings['semantic/border/divider'] = 'GRAY-ALPHA:100';
      mappings['semantic/border/line'] = 'GRAY:200';
      mappings['semantic/border/line-disabled'] = 'GRAY-ALPHA:200';
    }
    
    // Í≥µÌÜµ (gray50 Í≥†Ï†ï)
    mappings['semantic/background/default'] = 'GRAY:50';
    mappings['semantic/fill/silent'] = 'GRAY:50';
    mappings['semantic/border/divider-strong'] = 'REF:' + themeName + closestStepLight;
    mappings['semantic/border/line-selected'] = 'REF:' + themeName + closestStepLight;
    
  // =====================================
  // ÏòµÏÖò 3: Í∞ïÏ°∞ ÏöîÏÜå OFF / Î∞∞Í≤Ω ÏöîÏÜå ON
  // =====================================
  } else if (applicationMode === 'accent-off-bg-on') {
    if (isLightRange) {
      // 200 Ïù¥Ìïò
      mappings['semantic/text/primary'] = 'GRAY:900';
      mappings['semantic/text/secondary'] = 'GRAY-ALPHA:700';
      mappings['semantic/text/tertiary'] = 'GRAY-ALPHA:600';
      mappings['semantic/text/disabled'] = 'GRAY-ALPHA:400';
      mappings['semantic/text/on-color'] = 'GRAY:50';
      
      mappings['semantic/background/default'] = 'REF:' + themeName + closestStepLight;
      mappings['semantic/fill/silent'] = 'REF:' + themeName + closestStepLight;
      
      mappings['semantic/fill/primary'] = 'REF:' + themeName + '400';
      mappings['semantic/fill/primary-hover'] = 'REF:' + themeName + '500';
      mappings['semantic/fill/primary-pressed'] = 'REF:' + themeName + '500';
      
      mappings['semantic/border/divider-strong'] = 'REF:' + themeName + '400';
      mappings['semantic/border/line-selected'] = 'REF:' + themeName + '400';
      mappings['semantic/border/divider'] = 'GRAY-ALPHA:200';
      mappings['semantic/border/line'] = 'GRAY-ALPHA:300';
      mappings['semantic/border/line-disabled'] = 'GRAY-ALPHA:200';
      
      mappings['semantic/common/attention'] = 'REF:' + themeName + '500';
      mappings['semantic/common/attention-pressed'] = 'REF:' + themeName + '600';
      mappings['semantic/common/attention-hover'] = 'REF:' + themeName + '600';
      
    } else if (isMidRange) {
      // 300 Ïù¥ÏÉÅ
      mappings['semantic/text/primary'] = 'GRAY:50';
      mappings['semantic/text/secondary'] = 'GRAY:100';
      mappings['semantic/text/tertiary'] = 'GRAY:200';
      mappings['semantic/text/disabled'] = 'GRAY:600';
      mappings['semantic/text/on-color'] = 'GRAY:900';
      
      mappings['semantic/background/default'] = 'REF:' + themeName + closestStepLight;
      mappings['semantic/fill/silent'] = 'REF:' + themeName + closestStepLight;
      
      mappings['semantic/fill/primary'] = 'REF:' + themeName + '50';
      mappings['semantic/fill/primary-hover'] = 'REF:' + themeName + '100';
      mappings['semantic/fill/primary-pressed'] = 'REF:' + themeName + '100';
      
      mappings['semantic/border/divider-strong'] = 'REF:' + themeName + '50';
      mappings['semantic/border/line-selected'] = 'REF:' + themeName + '50';
      mappings['semantic/border/divider'] = 'ON-COLOR-ALPHA:200';
      mappings['semantic/border/line'] = 'ON-COLOR-ALPHA:300';
      mappings['semantic/border/line-disabled'] = 'ON-COLOR-ALPHA:200';
      
      mappings['semantic/common/attention'] = 'REF:' + themeName + '100';
      mappings['semantic/common/attention-pressed'] = 'REF:' + themeName + '200';
      mappings['semantic/common/attention-hover'] = 'REF:' + themeName + '200';
    }
  }
  
  // Í≥µÌÜµ ÏïåÌåå Îß§Ìïë (Î™®Îì† ÏòµÏÖò Í≥µÌÜµ)
  mappings['semantic/fill/tertiary'] = 'ALPHA:' + themeName + '100';
  mappings['semantic/fill/tertiary-hover'] = 'ALPHA:' + themeName + '200';
  mappings['semantic/fill/tertiary-pressed'] = 'ALPHA:' + themeName + '200';
  mappings['semantic/fill/disabled'] = 'ALPHA:' + themeName + '100';
  mappings['semantic/fill/surface-contents'] = 'ALPHA:' + themeName + '100';
  mappings['semantic/overlay/dimmed'] = 'STATIC:black-700';
  
  return mappings;
}
// =====================================
// Dark Î™®Îìú ÎèôÏ†Å Îß§Ìïë (300/400 Í∏∞Ï§Ä) - ÏµúÏ¢Ö ÏàòÏ†ï Î≤ÑÏ†Ñ
// =====================================

function getDynamicMappingsDark(closestStepDark, themeName, applicationMode) {
  var mappings = {};
  
  // 300/400 Í∏∞Ï§ÄÏúºÎ°ú Î∂ÑÎ•ò
  var isLightRange = closestStepDark <= 300;
  var isMidRange = closestStepDark >= 400;
  
  console.log('üåô [DARK] Step:', closestStepDark, '‚Üí', isLightRange ? '300 Ïù¥Ìïò' : isMidRange ? '400 Ïù¥ÏÉÅ' : 'Ï§ëÍ∞ÑÍ∞í');

  // =====================================
  // ÏòµÏÖò 1: Í∞ïÏ°∞ ÏöîÏÜå ON / Î∞∞Í≤Ω ÏöîÏÜå OFF
  // =====================================
  if (applicationMode === 'accent-on-bg-off') {
    if (isLightRange) {
      // 300 Ïù¥Ìïò
      mappings['semantic/text/primary'] = 'GRAY:900';
      mappings['semantic/text/secondary'] = 'GRAY:700';
      mappings['semantic/text/tertiary'] = 'GRAY:600';
      mappings['semantic/text/disabled'] = 'GRAY:400';
      mappings['semantic/text/on-color'] = 'GRAY:50';
      
      mappings['semantic/background/default'] = 'REF:' + themeName + '50';
      mappings['semantic/fill/silent'] = 'REF:' + themeName + '50';
      
      mappings['semantic/fill/primary'] = 'REF:' + themeName + closestStepDark;
      mappings['semantic/fill/primary-hover'] = 'REF:' + themeName + adjustStep(closestStepDark, 1);
      mappings['semantic/fill/primary-pressed'] = 'REF:' + themeName + adjustStep(closestStepDark, 1);
      
      mappings['semantic/border/divider-strong'] = 'REF:' + themeName + closestStepDark;
      mappings['semantic/border/line-selected'] = 'REF:' + themeName + closestStepDark;
      mappings['semantic/border/divider'] = 'GRAY-ALPHA:100';
      mappings['semantic/border/line'] = 'GRAY-ALPHA:200';
      mappings['semantic/border/line-disabled'] = 'GRAY-ALPHA:100';
      
      mappings['semantic/common/attention'] = 'REF:' + themeName + '100';
      mappings['semantic/common/attention-pressed'] = 'REF:' + themeName + '200';
      mappings['semantic/common/attention-hover'] = 'REF:' + themeName + '200';
      
    } else if (isMidRange) {
      // 400 Ïù¥ÏÉÅ
      mappings['semantic/text/primary'] = 'GRAY:900';
      mappings['semantic/text/secondary'] = 'GRAY:700';
      mappings['semantic/text/tertiary'] = 'GRAY:600';
      mappings['semantic/text/disabled'] = 'GRAY:400';
      mappings['semantic/text/on-color'] = 'GRAY:50';
      
      mappings['semantic/background/default'] = 'REF:' + themeName + '50';
      mappings['semantic/fill/silent'] = 'REF:' + themeName + '50';
      
      mappings['semantic/fill/primary'] = 'REF:' + themeName + closestStepDark;
      mappings['semantic/fill/primary-hover'] = 'REF:' + themeName + adjustStep(closestStepDark, -1);
      mappings['semantic/fill/primary-pressed'] = 'REF:' + themeName + adjustStep(closestStepDark, -1);
      
      mappings['semantic/border/divider-strong'] = 'REF:' + themeName + closestStepDark;
      mappings['semantic/border/line-selected'] = 'REF:' + themeName + closestStepDark;
      mappings['semantic/border/divider'] = 'GRAY-ALPHA:100';
      mappings['semantic/border/line'] = 'GRAY-ALPHA:200';
      mappings['semantic/border/line-disabled'] = 'GRAY-ALPHA:100';
      
      mappings['semantic/common/attention'] = 'REF:' + themeName + closestStepDark;
      mappings['semantic/common/attention-pressed'] = 'REF:' + themeName + adjustStep(closestStepDark, -1);
      mappings['semantic/common/attention-hover'] = 'REF:' + themeName + adjustStep(closestStepDark, -1);
    }
    
  // =====================================
  // ÏòµÏÖò 2: Í∞ïÏ°∞ ÏöîÏÜå ON / Î∞∞Í≤Ω Í≥†Ï†ï (gray50)
  // =====================================
  } else if (applicationMode === 'accent-on-bg-fixed') {
    if (isLightRange) {
      // 300 Ïù¥Ìïò
      mappings['semantic/text/primary'] = 'GRAY:900';
      mappings['semantic/text/secondary'] = 'GRAY:700';
      mappings['semantic/text/tertiary'] = 'GRAY:600';
      mappings['semantic/text/disabled'] = 'GRAY:400';
      mappings['semantic/text/on-color'] = 'GRAY:50';
      
      mappings['semantic/fill/primary'] = 'REF:' + themeName + closestStepDark;
      mappings['semantic/fill/primary-hover'] = 'REF:' + themeName + adjustStep(closestStepDark, 1);
      mappings['semantic/fill/primary-pressed'] = 'REF:' + themeName + adjustStep(closestStepDark, 1);
      
      mappings['semantic/common/attention'] = 'REF:' + themeName + closestStepDark;
      mappings['semantic/common/attention-pressed'] = 'REF:' + themeName + adjustStep(closestStepDark, 1);
      mappings['semantic/common/attention-hover'] = 'REF:' + themeName + adjustStep(closestStepDark, 1);
      
      mappings['semantic/border/divider'] = 'REF:' + themeName + '100';
      mappings['semantic/border/line'] = 'REF:' + themeName + '200';
      mappings['semantic/border/line-disabled'] = 'REF:' + themeName + '100';
      
    } else if (isMidRange) {
      // 400 Ïù¥ÏÉÅ
      mappings['semantic/text/primary'] = 'GRAY:900';
      mappings['semantic/text/secondary'] = 'GRAY:700';
      mappings['semantic/text/tertiary'] = 'GRAY:600';
      mappings['semantic/text/disabled'] = 'GRAY:400';
      mappings['semantic/text/on-color'] = 'GRAY:50';
      
      mappings['semantic/fill/primary'] = 'REF:' + themeName + closestStepDark;
      mappings['semantic/fill/primary-hover'] = 'REF:' + themeName + adjustStep(closestStepDark, -1);
      mappings['semantic/fill/primary-pressed'] = 'REF:' + themeName + adjustStep(closestStepDark, -1);
      
      mappings['semantic/common/attention'] = 'REF:' + themeName + closestStepDark;
      mappings['semantic/common/attention-pressed'] = 'REF:' + themeName + adjustStep(closestStepDark, -1);
      mappings['semantic/common/attention-hover'] = 'REF:' + themeName + adjustStep(closestStepDark, -1);
      
      mappings['semantic/border/divider'] = 'GRAY-ALPHA:150';
      mappings['semantic/border/line'] = 'GRAY:200';
      mappings['semantic/border/line-disabled'] = 'GRAY-ALPHA:100';
    }
    
    // Í≥µÌÜµ (gray50 Í≥†Ï†ï)
    mappings['semantic/background/default'] = 'GRAY:50';
    mappings['semantic/fill/silent'] = 'GRAY:50';
    mappings['semantic/border/divider-strong'] = 'REF:' + themeName + closestStepDark;
    mappings['semantic/border/line-selected'] = 'REF:' + themeName + closestStepDark;
    
  // =====================================
  // ÏòµÏÖò 3: Í∞ïÏ°∞ ÏöîÏÜå OFF / Î∞∞Í≤Ω ÏöîÏÜå ON
  // =====================================
  } else if (applicationMode === 'accent-off-bg-on') {
    if (isLightRange) {
      // 300 Ïù¥Ìïò
      mappings['semantic/text/primary'] = 'GRAY:900';
      mappings['semantic/text/secondary'] = 'GRAY-ALPHA:700';
      mappings['semantic/text/tertiary'] = 'GRAY-ALPHA:600';
      mappings['semantic/text/disabled'] = 'GRAY-ALPHA:400';
      mappings['semantic/text/on-color'] = 'GRAY:900';
      
      mappings['semantic/background/default'] = 'REF:' + themeName + '50';
      mappings['semantic/fill/silent'] = 'REF:' + themeName + closestStepDark;
      
      mappings['semantic/fill/primary'] = 'REF:' + themeName + '300';
      mappings['semantic/fill/primary-hover'] = 'REF:' + themeName + '400';
      mappings['semantic/fill/primary-pressed'] = 'REF:' + themeName + '400';
      
      mappings['semantic/border/divider-strong'] = 'REF:' + themeName + '50';
      mappings['semantic/border/line-selected'] = 'REF:' + themeName + '50';
      mappings['semantic/border/divider'] = 'ALPHA:' + themeName + '200';
      mappings['semantic/border/line'] = 'ALPHA:' + themeName + '300';
      mappings['semantic/border/line-disabled'] = 'ALPHA:' + themeName + '200';
      
      mappings['semantic/common/attention'] = 'REF:' + themeName + '400';
      mappings['semantic/common/attention-pressed'] = 'REF:' + themeName + '500';
      mappings['semantic/common/attention-hover'] = 'REF:' + themeName + '500';
      
    } else if (isMidRange) {
      // 400 Ïù¥ÏÉÅ
      mappings['semantic/text/primary'] = 'GRAY:900';
      mappings['semantic/text/secondary'] = 'GRAY-ALPHA:700';
      mappings['semantic/text/tertiary'] = 'GRAY-ALPHA:600';
      mappings['semantic/text/disabled'] = 'GRAY-ALPHA:400';
      mappings['semantic/text/on-color'] = 'GRAY:900';
      
      // background/defaultÎäî ÏûÖÎ†• ÏÉâÏÉÅÏóêÏÑú +2Îã®Í≥Ñ ÏúÑ
      mappings['semantic/background/default'] = 'REF:' + themeName + adjustStep(closestStepDark, 2);
      mappings['semantic/fill/silent'] = 'REF:' + themeName + closestStepDark;
      
      mappings['semantic/fill/primary'] = 'REF:' + themeName + '50';
      mappings['semantic/fill/primary-hover'] = 'REF:' + themeName + '100';
      mappings['semantic/fill/primary-pressed'] = 'REF:' + themeName + '100';
      
      mappings['semantic/border/divider-strong'] = 'REF:' + themeName + '50';
      mappings['semantic/border/line-selected'] = 'REF:' + themeName + '50';
      mappings['semantic/border/divider'] = 'ALPHA:' + themeName + '200';
      mappings['semantic/border/line'] = 'ALPHA:' + themeName + '300';
      mappings['semantic/border/line-disabled'] = 'ALPHA:' + themeName + '200';
      
      mappings['semantic/common/attention'] = 'REF:' + themeName + '400';
      mappings['semantic/common/attention-pressed'] = 'REF:' + themeName + '300';
      mappings['semantic/common/attention-hover'] = 'REF:' + themeName + '300';
      
    } else {
      // 300 Ïù¥ÏÉÅ (Í∏∞Î≥∏Í∞íÏúºÎ°ú 300 Ïù¥ÏÉÅ Ï≤òÎ¶¨)
      mappings['semantic/text/primary'] = 'GRAY:900';
      mappings['semantic/text/secondary'] = 'GRAY-ALPHA:700';
      mappings['semantic/text/tertiary'] = 'GRAY-ALPHA:600';
      mappings['semantic/text/disabled'] = 'GRAY-ALPHA:400';
      mappings['semantic/text/on-color'] = 'GRAY:900';
      
      // background/defaultÎäî ÏûÖÎ†• ÏÉâÏÉÅÏóêÏÑú +2Îã®Í≥Ñ ÏúÑ
      mappings['semantic/background/default'] = 'REF:' + themeName + adjustStep(closestStepDark, 2);
      mappings['semantic/fill/silent'] = 'REF:' + themeName + closestStepDark;
      
      mappings['semantic/fill/primary'] = 'REF:' + themeName + '50';
      mappings['semantic/fill/primary-hover'] = 'REF:' + themeName + '100';
      mappings['semantic/fill/primary-pressed'] = 'REF:' + themeName + '100';
      
      mappings['semantic/border/divider-strong'] = 'REF:' + themeName + '50';
      mappings['semantic/border/line-selected'] = 'REF:' + themeName + '50';
      mappings['semantic/border/divider'] = 'ALPHA:' + themeName + '200';
      mappings['semantic/border/line'] = 'ALPHA:' + themeName + '300';
      mappings['semantic/border/line-disabled'] = 'ALPHA:' + themeName + '200';
      
      mappings['semantic/common/attention'] = 'REF:' + themeName + '400';
      mappings['semantic/common/attention-pressed'] = 'REF:' + themeName + '300';
      mappings['semantic/common/attention-hover'] = 'REF:' + themeName + '300';
    }
  }
  
  // Í≥µÌÜµ ÏïåÌåå Îß§Ìïë (Î™®Îì† ÏòµÏÖò Í≥µÌÜµ)
  mappings['semantic/fill/tertiary'] = 'ALPHA:' + themeName + '100';
  mappings['semantic/fill/tertiary-hover'] = 'ALPHA:' + themeName + '200';
  mappings['semantic/fill/tertiary-pressed'] = 'ALPHA:' + themeName + '200';
  mappings['semantic/fill/disabled'] = 'ALPHA:' + themeName + '100';
  mappings['semantic/fill/surface-contents'] = 'ALPHA:' + themeName + '100';
  mappings['semantic/overlay/dimmed'] = 'STATIC:black-700';
  
  console.log('[DARK FINAL] border/divider:', mappings['semantic/border/divider']);
  return mappings;
}

// =====================================
// ÌÜ§ Îß§Ïπ≠ Ìï®Ïàò
// =====================================

function generateToneMatchingSuggestions(referenceHex, inputHex) {
  var refHsl = hexToHsl(referenceHex);
  var inputHsl = hexToHsl(inputHex);
  var suggestions = [];
  
  suggestions.push({
    type: 'Saturation Match',
    hex: hslToHex(inputHsl[0], refHsl[1], inputHsl[2]),
    explanation: 'Ï±ÑÎèÑÎ•º ' + Math.round(refHsl[1]) + '%Î°ú Ï°∞Ï†ï'
  });
  
  suggestions.push({
    type: 'Lightness Match', 
    hex: hslToHex(inputHsl[0], inputHsl[1], refHsl[2]),
    explanation: 'Î™ÖÎèÑÎ•º ' + Math.round(refHsl[2]) + '%Î°ú Ï°∞Ï†ï'
  });
  
  return suggestions;
}

// =====================================
// ÏÉÅÏàò Ï†ïÏùò
// =====================================

// Í∏∞Ï°¥ Í∞í Ïú†ÏßÄÌï¥Ïïº Ìï† ÌÜ†ÌÅ∞ Î™©Î°ù
var preserveTokens = [
  'semantic/fill/surface-floating',
  'semantic/fill/surface-dialog', 
  'semantic/fill/surface-sheet',
  'semantic/fill/surface-black',
  'semantic/background/black',
  'semantic/common/on-white',
  'semantic/common/on-white-hover',
  'semantic/common/on-white-pressed',
  'semantic/common/on-black',
  'semantic/common/on-black-hover',
  'semantic/common/on-black-pressed',
  'semantic/overlay/dimmed'
];

// =====================================
// Scale ÌÜ†ÌÅ∞ Î≥µÏÇ¨ Ìï®Ïàò
// =====================================
async function copyScaleTokensFromCollection(sourceCollection, targetCollection) {
  var sourceVariables = await figma.variables.getLocalVariablesAsync('COLOR');
  var sourceScaleVariables = sourceVariables.filter(function(v) {
    return v.variableCollectionId === sourceCollection.id && 
           (v.name.startsWith('scale/') || v.name.startsWith('primitive/') || v.name.startsWith('semantic/') || v.name.startsWith('static/'));
  }).sort(function(a, b) {
    // Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ Ïö∞ÏÑ†ÏàúÏúÑ Ï†ïÏùò (FigmaÏóêÏÑú Î≥¥Ïù¥Îäî ÏàúÏÑúÎåÄÎ°ú)
    var categoryOrder = ['static/', 'scale/', 'primitive/', 'semantic/'];
    
    var aCat = categoryOrder.findIndex(function(cat) { return a.name.startsWith(cat); });
    var bCat = categoryOrder.findIndex(function(cat) { return b.name.startsWith(cat); });
    
    if (aCat !== bCat) {
      return aCat - bCat; // Ïπ¥ÌÖåÍ≥†Î¶¨ Ïö∞ÏÑ†ÏàúÏúÑÎ°ú Ï†ïÎ†¨
    }
    
    // Í∞ôÏùÄ Ïπ¥ÌÖåÍ≥†Î¶¨ ÎÇ¥ÏóêÏÑúÎäî ÏÑ∏Î∂Ä Ï†ïÎ†¨
    if (a.name.startsWith('semantic/')) {
      // semantic ÌÜ†ÌÅ∞Ïùò Í≤ΩÏö∞ ÌïòÏúÑ Ïπ¥ÌÖåÍ≥†Î¶¨Î≥ÑÎ°ú Ï†ïÎ†¨
      var semanticOrder = [
        'semantic/text/', 
        'semantic/fill/', 
        'semantic/border/', 
        'semantic/background/', 
        'semantic/overlay/', 
        'semantic/common/'
      ];
      
      var aSemanticCat = semanticOrder.findIndex(function(cat) { return a.name.startsWith(cat); });
      var bSemanticCat = semanticOrder.findIndex(function(cat) { return b.name.startsWith(cat); });
      
      if (aSemanticCat !== bSemanticCat && aSemanticCat !== -1 && bSemanticCat !== -1) {
        return aSemanticCat - bSemanticCat;
      }
    }
    
    // Í∞ôÏùÄ ÌïòÏúÑ Ïπ¥ÌÖåÍ≥†Î¶¨ ÎÇ¥ÏóêÏÑúÎäî Ïù¥Î¶ÑÏàú Ï†ïÎ†¨
    return a.name.localeCompare(b.name);
  });
  
  console.log('Found', sourceScaleVariables.length, 'variables to copy (including semantic)');
  
  // Source collectionÏùò Î™®ÎìúÎì§
  var sourceLightMode = sourceCollection.modes.find(function(m) { return m.name === 'Light'; });
  var sourceDarkMode = sourceCollection.modes.find(function(m) { return m.name === 'Dark'; });
  
  if (!sourceLightMode || !sourceDarkMode) {
    console.log('Source collection missing Light/Dark modes');
    return;
  }
  
  // Target collectionÏùò Í∏∞Î≥∏ Î™®Îìú Ïù¥Î¶Ñ Î≥ÄÍ≤Ω Î∞è Dark Î™®Îìú ÏÉùÏÑ±
  var targetLightModeId;
  var targetDarkModeId;
  
  if (targetCollection.modes.length === 1 && targetCollection.modes[0].name === 'Mode 1') {
    // Í∏∞Î≥∏ Î™®Îìú Ïù¥Î¶ÑÏùÑ LightÎ°ú Î≥ÄÍ≤Ω
    targetCollection.renameMode(targetCollection.modes[0].modeId, 'Light');
    targetLightModeId = targetCollection.modes[0].modeId;
    
    // Dark Î™®Îìú ÏÉàÎ°ú ÏÉùÏÑ±
    targetDarkModeId = targetCollection.addMode('Dark');
  } else {
    // Í∏∞Ï°¥ Light/Dark Î™®Îìú Ï∞æÍ∏∞
    targetLightModeId = findOrCreateMode(targetCollection, 'Light');
    targetDarkModeId = findOrCreateMode(targetCollection, 'Dark');
  }
  
  // Î≥ÄÏàò ID Îß§Ìïë ÌÖåÏù¥Î∏î (Alias Ï∞∏Ï°∞Ïö©)
  var variableIdMap = {};
  
  // 1Îã®Í≥Ñ: Î™®Îì† Î≥ÄÏàò ÏÉùÏÑ±
  var newVariables = [];
  for (var i = 0; i < sourceScaleVariables.length; i++) {
    var sourceVar = sourceScaleVariables[i];
    var newVariable = figma.variables.createVariable(sourceVar.name, targetCollection, 'COLOR');
    variableIdMap[sourceVar.id] = newVariable.id;
    newVariables.push({
      source: sourceVar,
      target: newVariable
    });
    console.log('Created variable:', sourceVar.name);
  }
  
  // 2Îã®Í≥Ñ: Í∞í Î≥µÏÇ¨ (Alias Ï∞∏Ï°∞ Ìï¥Í≤∞)
  for (var i = 0; i < newVariables.length; i++) {
    var sourceVar = newVariables[i].source;
    var newVariable = newVariables[i].target;
    
    // Light Î™®Îìú Í∞í Î≥µÏÇ¨
    var sourceLightValue = sourceVar.valuesByMode[sourceLightMode.modeId];
    if (sourceLightValue) {
      if (sourceLightValue.type === 'VARIABLE_ALIAS') {
        // AliasÏù∏ Í≤ΩÏö∞ ÏÉàÎ°úÏö¥ Î≥ÄÏàò IDÎ°ú Îß§Ìïë
        var targetId = variableIdMap[sourceLightValue.id];
        if (targetId) {
          newVariable.setValueForMode(targetLightModeId, {
            type: 'VARIABLE_ALIAS',
            id: targetId
          });
        }
      } else {
        // ÏßÅÏ†ë ÏÉâÏÉÅ Í∞íÏù∏ Í≤ΩÏö∞ Í∑∏ÎåÄÎ°ú Î≥µÏÇ¨
        newVariable.setValueForMode(targetLightModeId, sourceLightValue);
      }
    }
    
    // Dark Î™®Îìú Í∞í Î≥µÏÇ¨
    var sourceDarkValue = sourceVar.valuesByMode[sourceDarkMode.modeId];
    if (sourceDarkValue) {
      if (sourceDarkValue.type === 'VARIABLE_ALIAS') {
        // AliasÏù∏ Í≤ΩÏö∞ ÏÉàÎ°úÏö¥ Î≥ÄÏàò IDÎ°ú Îß§Ìïë
        var targetId = variableIdMap[sourceDarkValue.id];
        if (targetId) {
          newVariable.setValueForMode(targetDarkModeId, {
            type: 'VARIABLE_ALIAS',
            id: targetId
          });
        }
      } else {
        // ÏßÅÏ†ë ÏÉâÏÉÅ Í∞íÏù∏ Í≤ΩÏö∞ Í∑∏ÎåÄÎ°ú Î≥µÏÇ¨
        newVariable.setValueForMode(targetDarkModeId, sourceDarkValue);
      }
    }
    
    console.log('Set values for variable:', sourceVar.name);
  }
  
  console.log('Scale token copying complete');
}

// =====================================
// Frame Î≥ÄÏàò ÍµêÏ≤¥ Ìï®Ïàò
// =====================================
async function replaceFrameVariablesWithCollection(selection, targetCollection, targetMode) {
  var allVariables = await figma.variables.getLocalVariablesAsync('COLOR');
  var targetVariables = allVariables.filter(function(v) {
    return v.variableCollectionId === targetCollection.id;
  });
  
  console.log('Found', targetVariables.length, 'variables in target collection:', targetCollection.name);
  console.log('Target variable names:', targetVariables.map(function(v) { return v.name; }).slice(0, 10));
  
  // Î™®Îì† ÌÉÄÍ≤ü Î≥ÄÏàò Ïù¥Î¶Ñ Ï∂úÎ†• (ÎîîÎ≤ÑÍπÖÏö©)
  console.log('All target variables:', targetVariables.map(function(v) { return v.name; }));
  
  var replacedCount = 0;
  
  for (var i = 0; i < selection.length; i++) {
    var node = selection[i];
    console.log('Processing node:', node.name, 'type:', node.type);
    replacedCount += await replaceNodeVariables(node, targetVariables);
    
    // FrameÏùò Í≤ΩÏö∞ Î™®Îì† ÏûêÏãù ÎÖ∏ÎìúÎèÑ Ï≤òÎ¶¨
    if (node.type === 'FRAME' || node.type === 'GROUP' || node.type === 'COMPONENT' || node.type === 'INSTANCE') {
      console.log('Processing all descendants of:', node.name);
      replacedCount += await processAllDescendants(node, targetVariables);
    }
  }
  
  console.log('Replaced variables in', replacedCount, 'operations total');
}

async function processAllDescendants(parentNode, targetVariables) {
  var totalReplaced = 0;
  
  function traverse(node) {
    return new Promise(async function(resolve) {
      var localReplaced = 0;
      
      // ÌòÑÏû¨ ÎÖ∏Îìú Ï≤òÎ¶¨ (Ïù¥ÎØ∏ replaceNodeVariablesÏóêÏÑú Ï≤òÎ¶¨ÌñàÏúºÎØÄÎ°ú ÏûêÏãùÎßå)
      if ('children' in node) {
        for (var i = 0; i < node.children.length; i++) {
          var child = node.children[i];
          localReplaced += await replaceNodeVariables(child, targetVariables);
          
          // Ïû¨Í∑ÄÏ†ÅÏúºÎ°ú ÏûêÏãùÏùò ÏûêÏãùÎì§ÎèÑ Ï≤òÎ¶¨
          if ('children' in child) {
            localReplaced += await traverse(child);
          }
        }
      }
      
      resolve(localReplaced);
    });
  }
  
  totalReplaced = await traverse(parentNode);
  console.log('Processed', totalReplaced, 'variables in descendants of', parentNode.name);
  return totalReplaced;
}

async function replaceNodeVariables(node, targetVariables) {
  var replacedCount = 0;
  
  // ÌòÑÏû¨ ÎÖ∏ÎìúÏùò Î∞îÏù∏Îî©Îêú Î≥ÄÏàòÎì§ ÌôïÏù∏ Î∞è ÍµêÏ≤¥
  if (node.boundVariables) {
    console.log('Node has boundVariables:', node.name, Object.keys(node.boundVariables));
    console.log('Node fills:', node.fills ? node.fills.length : 'none');
    console.log('Node strokes:', node.strokes ? node.strokes.length : 'none');
    if (node.fills && node.fills.length > 0) {
      console.log('First fill:', node.fills[0]);
    }
    if (node.strokes && node.strokes.length > 0) {
      console.log('First stroke:', node.strokes[0]);
    }
    for (var prop in node.boundVariables) {
      var boundVar = node.boundVariables[prop];
      console.log('Processing prop:', prop, 'boundVar:', boundVar);
      
      // fillsÎäî Î∞∞Ïó¥Ïùº Ïàò ÏûàÏùå
      if (prop === 'fills' && Array.isArray(boundVar)) {
        console.log('Processing fills array with', boundVar.length, 'items');
        for (var i = 0; i < boundVar.length; i++) {
          var fillBinding = boundVar[i];
          console.log('Fill binding [' + i + ']:', fillBinding);
          
          // fillBinding ÏûêÏ≤¥Í∞Ä VARIABLE_ALIASÏùº Ïàò ÏûàÏùå
          if (fillBinding && fillBinding.type === 'VARIABLE_ALIAS' && fillBinding.id) {
            var colorVar = await figma.variables.getVariableByIdAsync(fillBinding.id);
            if (colorVar && colorVar.resolvedType === 'COLOR') {
              console.log('Found color variable in fills[' + i + ']:', colorVar.name);
              
              var newColorVar = targetVariables.find(function(v) { 
                return v.name === colorVar.name; 
              });
              
              if (newColorVar) {
                console.log('Replacing color variable in fills:', colorVar.name, 'with', newColorVar.name);
                // fills Î∞∞Ïó¥Ïùò boundVariables ÍµêÏ≤¥
                var newFills = node.fills.slice();
                if (newFills[i] && newFills[i].boundVariables && newFills[i].boundVariables.color) {
                  var existingFill = newFills[i];
                  var newBoundVars = {};
                  
                  // Í∏∞Ï°¥ boundVariablesÏùò Îã§Î•∏ ÏÜçÏÑ±Îì§ Î≥µÏÇ¨
                  for (var key in existingFill.boundVariables) {
                    if (key === 'color') {
                      newBoundVars[key] = { type: 'VARIABLE_ALIAS', id: newColorVar.id };
                    } else {
                      newBoundVars[key] = existingFill.boundVariables[key];
                    }
                  }
                  
                  newFills[i] = {
                    type: existingFill.type,
                    visible: existingFill.visible,
                    opacity: existingFill.opacity,
                    blendMode: existingFill.blendMode,
                    color: existingFill.color,
                    boundVariables: newBoundVars
                  };
                  
                  // Îã§Î•∏ ÏÜçÏÑ±Îì§ÎèÑ Î≥µÏÇ¨
                  if (existingFill.gradientTransform) newFills[i].gradientTransform = existingFill.gradientTransform;
                  if (existingFill.gradientStops) newFills[i].gradientStops = existingFill.gradientStops;
                  if (existingFill.scaleMode) newFills[i].scaleMode = existingFill.scaleMode;
                  node.fills = newFills;
                  console.log('Successfully replaced fills color variable');
                  replacedCount++;
                } else {
                  console.log('Fill does not have boundVariables.color, trying direct replacement');
                  // boundVariablesÍ∞Ä ÏóÜÏúºÎ©¥ ÏßÅÏ†ë setBoundVariable ÏÇ¨Ïö©
                  try {
                    node.setBoundVariable('fills', newColorVar);
                    console.log('Direct setBoundVariable successful');
                    replacedCount++;
                  } catch (e) {
                    console.log('Direct setBoundVariable failed:', e.message);
                  }
                }
              } else {
                console.log('No matching variable found for:', colorVar.name, 'in target collection');
                console.log('Available target variables:', targetVariables.map(function(v) { return v.name; }).filter(function(name) { 
                  return name.indexOf(colorVar.name.split('/').pop()) !== -1; 
                }));
                // Î∞îÏù∏Îî© Ìï¥Ï†ú
                try {
                  node.setBoundVariable('fills', null);
                  console.log('Unbound fills variable');
                  replacedCount++;
                } catch (e) {
                  console.log('Failed to unbind fills:', e.message);
                }
              }
            }
          }
        }
        continue;
      }
      
      // strokesÎèÑ Î∞∞Ïó¥Ïùº Ïàò ÏûàÏùå (fillsÏôÄ ÎèôÏùºÌïú Î°úÏßÅ)
      if (prop === 'strokes' && Array.isArray(boundVar)) {
        console.log('Processing strokes array with', boundVar.length, 'items');
        for (var i = 0; i < boundVar.length; i++) {
          var strokeBinding = boundVar[i];
          console.log('Stroke binding [' + i + ']:', strokeBinding);
          
          if (strokeBinding && strokeBinding.type === 'VARIABLE_ALIAS' && strokeBinding.id) {
            var strokeVar = await figma.variables.getVariableByIdAsync(strokeBinding.id);
            if (strokeVar && strokeVar.resolvedType === 'COLOR') {
              console.log('Found stroke color variable:', strokeVar.name);
              
              var newStrokeVar = targetVariables.find(function(v) { 
                return v.name === strokeVar.name; 
              });
              
              if (newStrokeVar) {
                console.log('Replacing stroke variable:', strokeVar.name, 'with', newStrokeVar.name);
                try {
                  node.setBoundVariable('strokes', newStrokeVar);
                  console.log('Successfully replaced stroke variable');
                  replacedCount++;
                } catch (e) {
                  console.log('Failed to replace stroke variable:', e.message);
                }
              } else {
                console.log('No matching stroke variable found for:', strokeVar.name);
                try {
                  node.setBoundVariable('strokes', null);
                  console.log('Unbound stroke variable');
                  replacedCount++;
                } catch (e) {
                  console.log('Failed to unbind stroke:', e.message);
                }
              }
            }
          }
        }
        continue;
      }
      
      if (boundVar && boundVar.id) {
        var oldVariable = await figma.variables.getVariableByIdAsync(boundVar.id);
        if (oldVariable) {
          console.log('Old variable:', oldVariable.name, 'from collection:', oldVariable.variableCollectionId, 'prop:', prop);
          
          if (oldVariable.resolvedType === 'COLOR') {
            // ÏÉâÏÉÅ Î≥ÄÏàòÎäî ÏÉà Ïª¨Î†âÏÖòÏóêÏÑú Ï∞æÏïÑÏÑú ÍµêÏ≤¥
            var newVariable = targetVariables.find(function(v) { 
              return v.name === oldVariable.name; 
            });
            
            if (newVariable) {
              console.log('Found matching color variable:', newVariable.name, 'replacing for prop:', prop);
              try {
                node.setBoundVariable(prop, newVariable);
                console.log('Successfully replaced color variable', oldVariable.name, 'with', newVariable.name, 'for', node.name, 'prop:', prop);
                replacedCount++;
              } catch (e) {
                console.log('Failed to replace color variable:', e.message);
                // strokesÏùò Í≤ΩÏö∞ Îã§Î•∏ Î∞©ÏãùÏúºÎ°ú ÏãúÎèÑ
                if (prop === 'strokes') {
                  console.log('Trying alternative stroke replacement method');
                  try {
                    var newStrokes = node.strokes.slice();
                    if (newStrokes.length > 0 && newStrokes[0].boundVariables) {
                      newStrokes[0].boundVariables.color = { type: 'VARIABLE_ALIAS', id: newVariable.id };
                      node.strokes = newStrokes;
                      console.log('Alternative stroke replacement successful');
                      replacedCount++;
                    }
                  } catch (e2) {
                    console.log('Alternative stroke replacement also failed:', e2.message);
                  }
                }
              }
            } else {
              console.log('No matching color variable found for:', oldVariable.name, 'unbinding...');
              console.log('Searching in target variables:', targetVariables.map(function(v) { return v.name; }).filter(function(name) { 
                return name.indexOf(oldVariable.name.split('/').pop()) !== -1; 
              }));
              try {
                node.setBoundVariable(prop, null); // Î∞îÏù∏Îî© Ìï¥Ï†ú
                console.log('Unbound color variable for prop:', prop);
                replacedCount++;
              } catch (e) {
                console.log('Failed to unbind color variable:', e.message);
              }
            }
          } else {
            // ÏÉâÏÉÅÏù¥ ÏïÑÎãå Î≥ÄÏàòÎäî Î∞îÏù∏Îî© Ìï¥Ï†ú (Í≥†Ï†ïÍ∞íÏúºÎ°ú Î≥ÄÌôò)
            console.log('Unbinding non-color variable:', oldVariable.name, 'type:', oldVariable.resolvedType);
            try {
              node.setBoundVariable(prop, null);
              replacedCount++;
            } catch (e) {
              console.log('Failed to unbind non-color variable:', e.message);
            }
          }
        }
      }
    }
  }
  
  // ÏûêÏãù ÎÖ∏ÎìúÎì§ÎèÑ Ïû¨Í∑ÄÏ†ÅÏúºÎ°ú Ï≤òÎ¶¨
  if ('children' in node) {
    for (var i = 0; i < node.children.length; i++) {
      var child = node.children[i];
      replacedCount += await replaceNodeVariables(child, targetVariables);
    }
  }
  
  return replacedCount;
}

// =====================================
// Î©îÏãúÏßÄ Ìï∏Îì§Îü¨Îì§
// =====================================

// Í∏∞Î≥∏ Î≥ÄÏàò ÏÉùÏÑ± Ìï∏Îì§Îü¨
async function handleCreateVariables(msg) {
  var collections = await figma.variables.getLocalVariableCollectionsAsync();
  var collection = collections.find(function(c) { 
    return c.name === 'ruler_v2'; 
  });
  
  if (!collection) {
    collection = figma.variables.createVariableCollection('ruler_v2');
  }
  
  var createdCount = 0;
  
  // ÎìÄÏñº Î™®Îìú Ï≤òÎ¶¨
  if (msg.dualMode) {
    // Light/Dark Î™®Îìú ÌôïÏù∏ Î∞è ÏÉùÏÑ±
    var lightMode = collection.modes.find(function(m) { return m.name === 'Light'; });
    var darkMode = collection.modes.find(function(m) { return m.name === 'Dark'; });
    
    if (!lightMode) {
      if (collection.modes.length === 1 && collection.modes[0].name === 'Mode 1') {
        // Í∏∞Î≥∏ Î™®Îìú Ïù¥Î¶Ñ Î≥ÄÍ≤Ω
        collection.renameMode(collection.modes[0].modeId, 'Light');
        lightMode = collection.modes[0];
      } else {
        lightMode = collection.addMode('Light');
      }
    }
    
    if (!darkMode) {
      darkMode = collection.addMode('Dark');
    }
    
    // Light/Dark ÏÉâÏÉÅ Î™®Îëê ÏÉùÏÑ±
    for (var i = 0; i < msg.lightColors.length; i++) {
      var lightColor = msg.lightColors[i];
      var darkColor = msg.darkColors[i];
      
      if (!lightColor || !lightColor.hex || !darkColor || !darkColor.hex) continue;
      
      var variableName = 'scale/' + msg.variableName + '-' + lightColor.step;
      var variable = await findOrCreateVariable(variableName, collection, 'COLOR');
      
      // Light Î™®Îìú Í∞í ÏÑ§Ï†ï
      variable.setValueForMode(lightMode.modeId, hexToFigmaRGB(lightColor.hex));
      // Dark Î™®Îìú Í∞í ÏÑ§Ï†ï  
      variable.setValueForMode(darkMode.modeId, hexToFigmaRGB(darkColor.hex));
      
      createdCount++;
    }
    
    figma.notify('Created ' + createdCount + ' dual-mode variables');
  } else {
    // Îã®Ïùº Î™®Îìú Ï≤òÎ¶¨ (Í∏∞Ï°¥ ÏΩîÎìú)
    var modeId = collection.modes[0].modeId;
    
    for (var i = 0; i < msg.colors.length; i++) {
      var color = msg.colors[i];
      if (!color || !color.hex) continue;
      
      var variableName = 'scale/' + msg.variableName + '-' + color.step;
      var variable = await findOrCreateVariable(variableName, collection, 'COLOR');
      variable.setValueForMode(modeId, hexToFigmaRGB(color.hex));
      createdCount++;
    }
    
    figma.notify('Created ' + createdCount + ' variables');
  }
  
  figma.ui.postMessage({ 
    type: 'variable-created',
    success: true,
    count: createdCount,
    dualMode: msg.dualMode
  });
}

// Ïä§ÌÉÄÏùº ÏÉùÏÑ± Ìï∏Îì§Îü¨ Ï∂îÍ∞Ä
async function handleCreateStyles(msg) {
  var createdCount = 0;
  var paintStyles = [];
  
  for (var i = 0; i < msg.colors.length; i++) {
    var color = msg.colors[i];
    if (!color || !color.hex) continue;
    
    var styleName = msg.styleName + '/' + color.step;
    
    // Í∏∞Ï°¥ Ïä§ÌÉÄÏùº Ï∞æÍ∏∞
    var existingStyle = figma.getLocalPaintStyles().find(function(style) {
      return style.name === styleName;
    });
    
    var style;
    if (existingStyle) {
      style = existingStyle;
    } else {
      style = figma.createPaintStyle();
      style.name = styleName;
    }
    
    // ÏÉâÏÉÅ ÏÑ§Ï†ï
    var rgb = hexToFigmaRGB(color.hex);
    style.paints = [{
      type: 'SOLID',
      color: rgb
    }];
    
    paintStyles.push(style);
    createdCount++;
  }
  
  figma.ui.postMessage({
    type: 'style-created',
    success: true,
    count: createdCount
  });
  
  figma.notify('Created ' + createdCount + ' color styles');
}

// Auto Apply Í∏∞Îä• Ìï∏Îì§Îü¨ Ï∂îÍ∞Ä
async function handleApplyColorsToLayers(msg) {
  var selection = figma.currentPage.selection;
  
  if (selection.length === 0) {
    figma.notify('Please select layers to apply colors');
    return;
  }
  
  var appliedCount = 0;
  var layerMappings = msg.layerMappings;
  
  // ÏÑ†ÌÉùÎêú ÎÖ∏ÎìúÎì§Ïóê ÏÉâÏÉÅ Ï†ÅÏö©
  for (var i = 0; i < selection.length; i++) {
    var node = selection[i];
    
    // Î†àÏù¥Ïñ¥ Ïù¥Î¶ÑÏóêÏÑú Îß§Ïπ≠ÎêòÎäî ÌÇ§ÏõåÎìú Ï∞æÍ∏∞
    var layerName = node.name.toLowerCase();
    var matchedColor = null;
    
    for (var keyword in layerMappings) {
      if (layerName.includes(keyword)) {
        matchedColor = layerMappings[keyword];
        break;
      }
    }
    
    if (matchedColor && 'fills' in node) {
      var rgb = hexToFigmaRGB(matchedColor.hex);
      
      if (msg.previewMode) {
        // ÌîÑÎ¶¨Î∑∞ Î™®Îìú: Î∞òÌà¨Î™ÖÏúºÎ°ú Ï†ÅÏö©
        node.fills = [{
          type: 'SOLID',
          color: rgb,
          opacity: 0.5
        }];
      } else {
        // Ïã§Ï†ú Ï†ÅÏö©
        node.fills = [{
          type: 'SOLID',
          color: rgb
        }];
      }
      
      appliedCount++;
    }
  }
  
  var message = msg.previewMode ? 
    'Preview applied to ' + appliedCount + ' layers' :
    'Colors applied to ' + appliedCount + ' layers';
    
  figma.notify(message);
  
  figma.ui.postMessage({
    type: 'colors-applied',
    success: true,
    count: appliedCount,
    previewMode: msg.previewMode
  });
}

// Î©îÏãúÏßÄ Ìï∏Îì§Îü¨Ïóê ÏÉà ÏºÄÏù¥Ïä§ Ï∂îÍ∞Ä
figma.ui.onmessage = async function(msg) {
  console.log('Received message:', msg.type);
  
  try {
    if (msg.type === 'create-variables') {
      await handleCreateVariables(msg);
    } else if (msg.type === 'create-styles') {
      await handleCreateStyles(msg);
    } else if (msg.type === 'apply-colors-to-layers') {
      await handleApplyColorsToLayers(msg);
    } else if (msg.type === 'create-custom-theme') {
      await handleCreateCustomTheme(msg);
    } else if (msg.type === 'apply-custom-mode-to-frame') {
      await handleApplyCustomModeToFrame(msg);
    } else if (msg.type === 'generate-tone-matching') {
      await handleToneMatching(msg);
    }
  } catch (error) {
    console.error('Error handling message:', error);
    figma.notify('Error: ' + error.message, { error: true });
  }
};

// Custom Theme ÏÉùÏÑ± Ìï∏Îì§Îü¨ (ÏàòÏ†ïÎêú Application Mode ÏßÄÏõê)
async function handleCreateCustomTheme(msg) {
  var theme = msg.theme;
  var applicationMode = theme.applicationMode || 'accent-on-bg-off';
  
  console.log('Creating theme with application mode:', applicationMode);
  
  // ruler_v2 collection ÏÇ¨Ïö© (modeÎßå Ï∂îÍ∞Ä)
  var collections = await figma.variables.getLocalVariableCollectionsAsync();
  var collection = collections.find(function(c) { 
    return c.name === 'ruler_v2'; 
  });
  
  if (!collection) {
    throw new Error('ruler_v2 collection not found');
  }
  
  // =====================================
  // STEP 1: Î™®Îìú ÌôïÏù∏ Î∞è ÏÉùÏÑ±
  // =====================================
  
  var baseLightMode = collection.modes.find(function(m) { return m.name === 'Light'; });
  var baseDarkMode = collection.modes.find(function(m) { return m.name === 'Dark'; });
  
  // Î≥µÏÇ¨Îêú Ïª¨Î†âÏÖòÏùò Í≤ΩÏö∞ Ïù¥ÎØ∏ Light/Dark Î™®ÎìúÍ∞Ä ÏûàÏùÑ Í≤ÉÏûÑ
  if (!baseLightMode && !baseDarkMode && collection.modes.length >= 2) {
    baseLightMode = collection.modes.find(function(m) { return m.name === 'Light'; });
    baseDarkMode = collection.modes.find(function(m) { return m.name === 'Dark'; });
  }
  
  var customLightModeId = findOrCreateMode(collection, 'CustomLight');
  var customDarkModeId = findOrCreateMode(collection, 'CustomDark');
  
  var createdCount = 0;
  var skippedCount = 0;
  
  // =====================================
  // STEP 2: Scale ÏÉâÏÉÅ ÏÉùÏÑ± (scale/{themeName}{step})
  // =====================================
  
  console.log('=== Creating Scale Variables ===');
  
  for (var i = 0; i < theme.scaleColors.light.length; i++) {
    var lightColor = theme.scaleColors.light[i];
    var darkColor = theme.scaleColors.dark[i];
    var variableName = 'scale/' + theme.themeName + '-' + lightColor.step;
    
    console.log('[SCALE] Creating:', variableName);
    
    var variable = await findOrCreateVariable(variableName, collection, 'COLOR');
    
    // Î™®Îì† 4Í∞ú Î™®ÎìúÏóê Í∞í ÏÑ§Ï†ï
    variable.setValueForMode(baseLightMode.modeId, hexToFigmaRGB(lightColor.hex));
    variable.setValueForMode(baseDarkMode.modeId, hexToFigmaRGB(darkColor.hex));
    variable.setValueForMode(customLightModeId, hexToFigmaRGB(lightColor.hex));
    variable.setValueForMode(customDarkModeId, hexToFigmaRGB(darkColor.hex));
    
    createdCount++;
  }
  
  // =====================================
  // STEP 3: Alpha ÏÉâÏÉÅ ÏÉùÏÑ± (scale/{themeName}-alpha-{step})
  // =====================================

console.log('=== Creating Alpha Variables ===');

// ÏûÖÎ†• ÏÉâÏÉÅÍ≥º Í∞ÄÏû• Í∞ÄÍπåÏö¥ step Ï∞æÍ∏∞
var closestStepForAlpha = findClosestStep(theme.scaleColors.light, theme.baseColor);
console.log('[ALPHA BASE] Using closest step for alpha:', closestStepForAlpha);

// Í∞ÄÏû• Í∞ÄÍπåÏö¥ stepÏùò ÏÉâÏÉÅÏùÑ base RGBÎ°ú ÏÇ¨Ïö©
var baseColorLight = theme.scaleColors.light.find(function(c) { 
  return c.step === closestStepForAlpha; 
});
var baseColorDark = theme.scaleColors.dark.find(function(c) { 
  return c.step === closestStepForAlpha; 
});

if (!baseColorLight || !baseColorDark) {
  // Fallback: ÏûÖÎ†• ÏÉâÏÉÅ ÏßÅÏ†ë ÏÇ¨Ïö©
  console.log('[ALPHA BASE] Using input color as fallback');
  baseColorLight = { hex: theme.baseColor };
  baseColorDark = { hex: theme.baseColor };
}

console.log('[ALPHA BASE] Light base:', baseColorLight.hex);
console.log('[ALPHA BASE] Dark base:', baseColorDark.hex);

var baseRgbLight = hexToFigmaRGB(baseColorLight.hex);
var baseRgbDark = hexToFigmaRGB(baseColorDark.hex);

// Í≥†Ï†ïÎêú ÏïåÌåå Îß§Ìïë ÌÖåÏù¥Î∏î
var alphaMapping = {
  0: 0.00, 50: 0.05, 75: 0.08, 100: 0.10, 150: 0.15,
  200: 0.20, 300: 0.30, 400: 0.40, 500: 0.50,
  600: 0.60, 700: 0.70, 800: 0.80, 900: 0.90, 950: 0.95
};

// alpha-00 Î®ºÏ†Ä ÏÉùÏÑ±
var transparentVariableName = 'scale/' + theme.themeName + '-alpha-00';
console.log('[ALPHA] Creating:', transparentVariableName, 'with base step:', closestStepForAlpha);

var transparentVariable = await findOrCreateVariable(transparentVariableName, collection, 'COLOR');

transparentVariable.setValueForMode(baseLightMode.modeId, { 
  r: baseRgbLight.r, g: baseRgbLight.g, b: baseRgbLight.b, a: 0 
});
transparentVariable.setValueForMode(baseDarkMode.modeId, { 
  r: baseRgbDark.r, g: baseRgbDark.g, b: baseRgbDark.b, a: 0 
});
transparentVariable.setValueForMode(customLightModeId, { 
  r: baseRgbLight.r, g: baseRgbLight.g, b: baseRgbLight.b, a: 0 
});
transparentVariable.setValueForMode(customDarkModeId, { 
  r: baseRgbDark.r, g: baseRgbDark.g, b: baseRgbDark.b, a: 0 
});

createdCount++;

// Í∞Å Îã®Í≥ÑÎ≥Ñ alpha ÌÜ†ÌÅ∞ ÏÉùÏÑ±
for (var i = 0; i < theme.scaleColors.light.length; i++) {
  var step = theme.scaleColors.light[i].step;
  var alphaValue = alphaMapping[step];
  
  if (alphaValue === undefined) continue;
  
  var alphaVariableName = 'scale/' + theme.themeName + '-alpha-' + step;
  console.log('[ALPHA] Creating:', alphaVariableName, 'alpha:', alphaValue, 'base from step:', closestStepForAlpha);
  
  var alphaVariable = await findOrCreateVariable(alphaVariableName, collection, 'COLOR');
  
  // Î™®Îì† 4Í∞ú Î™®ÎìúÏóê Í∞í ÏÑ§Ï†ï - Í∞ÄÏû• Í∞ÄÍπåÏö¥ step ÏÉâÏÉÅ Í∏∞Ï§Ä
  alphaVariable.setValueForMode(baseLightMode.modeId, { 
    r: baseRgbLight.r, g: baseRgbLight.g, b: baseRgbLight.b, a: alphaValue 
  });
  alphaVariable.setValueForMode(baseDarkMode.modeId, { 
    r: baseRgbDark.r, g: baseRgbDark.g, b: baseRgbDark.b, a: alphaValue 
  });
  alphaVariable.setValueForMode(customLightModeId, { 
    r: baseRgbLight.r, g: baseRgbLight.g, b: baseRgbLight.b, a: alphaValue 
  });
  alphaVariable.setValueForMode(customDarkModeId, { 
    r: baseRgbDark.r, g: baseRgbDark.g, b: baseRgbDark.b, a: alphaValue 
  });
  
  createdCount++;
}

  // =====================================
  // STEP 4: Í∏∞Ï°¥ Î≥ÄÏàò Î≥µÏÇ¨ (gray Îì± ÎπÑÏãúÎß®Ìã±)
  // =====================================
  
  console.log('=== Copying Non-Semantic Variables ===');
  
  var allVariables = await figma.variables.getLocalVariablesAsync('COLOR');
  
  for (var i = 0; i < allVariables.length; i++) {
    var v = allVariables[i];
    if (v.variableCollectionId === collection.id && 
        !v.name.startsWith('semantic/') && 
        !v.name.startsWith('scale/' + theme.themeName)) {
      
      if (baseLightMode && v.valuesByMode[baseLightMode.modeId]) {
        v.setValueForMode(customLightModeId, v.valuesByMode[baseLightMode.modeId]);
      }
      if (baseDarkMode && v.valuesByMode[baseDarkMode.modeId]) {
        v.setValueForMode(customDarkModeId, v.valuesByMode[baseDarkMode.modeId]);
      }
      
      console.log('[COPY] Non-semantic variable:', v.name);
    }
  }
  
  // =====================================
  // STEP 5: ÎèôÏ†Å Îß§Ìïë Í≥ÑÏÇ∞ (Light/Dark Î™®ÎìúÎ≥Ñ ÎèÖÎ¶Ω Í≥ÑÏÇ∞)
  // =====================================
  
console.log('=== Finding closest step for Light mode ===');
var closestStepLight = findClosestStep(theme.scaleColors.light, theme.baseColor);

console.log('=== Finding closest step for Dark mode ===');
var closestStepDark = findClosestStep(theme.scaleColors.dark, theme.baseColor);

console.log('Closest steps - Light:', closestStepLight, 'Dark:', closestStepDark);

// LightÏôÄ Dark Îß§ÌïëÏùÑ Í∞ÅÍ∞Å Í∞ÄÏ†∏Ïò§Í∏∞
console.log('=== Calling Light Mappings ===');
var lightMappings = getDynamicMappingsLight(closestStepLight, theme.themeName, applicationMode);
console.log('=== Calling Dark Mappings ===');
var darkMappings = getDynamicMappingsDark(closestStepDark, theme.themeName, applicationMode);
console.log('=== Mappings Retrieved ===');

// Îëê Îß§ÌïëÏùÑ Ìï©ÏπòÍ∏∞
var dynamicMappings = {};
for (var key in lightMappings) {
  if (key.startsWith('semantic/fill/tertiary') || key.startsWith('semantic/fill/disabled') || key.startsWith('semantic/fill/surface-contents')) {
    // ÏïåÌåå ÌÜ†ÌÅ∞ÏùÄ light/dark ÎèôÏùº
    dynamicMappings[key] = { light: lightMappings[key], dark: darkMappings[key] };
  } else {
    dynamicMappings[key] = { 
      light: lightMappings[key], 
      dark: darkMappings[key] 
    };
  }
}

console.log('=== Dynamic Mappings Debug ===');
console.log('Light background/default:', lightMappings['semantic/background/default']);
console.log('Dark background/default:', darkMappings['semantic/background/default']);
console.log('Combined background/default:', dynamicMappings['semantic/background/default']);
console.log('Light border/divider:', lightMappings['semantic/border/divider']);
console.log('Dark border/divider:', darkMappings['semantic/border/divider']);
console.log('Combined border/divider:', dynamicMappings['semantic/border/divider']);
console.log('Total dynamic mappings:', Object.keys(dynamicMappings).length);
  // =====================================
  // STEP 6: Semantic ÌÜ†ÌÅ∞ ÏÉùÏÑ± Î∞è Îß§Ìïë
  // =====================================


console.log('=== Applying Semantic Mappings ===');

// Î≥¥Ï°¥Ìï¥Ïïº Ìï† ÌÜ†ÌÅ∞ Î™©Î°ù (Light/Dark Í∞íÏùÑ Í∑∏ÎåÄÎ°ú Î≥µÏ†ú)
var preserveTokens = [
  'semantic/fill/surface-floating',
  'semantic/fill/surface-dialog', 
  'semantic/fill/surface-sheet',
  'semantic/fill/surface-black',
  'semantic/background/black',
  'semantic/common/on-white',
  'semantic/common/on-white-hover',
  'semantic/common/on-white-pressed',
  'semantic/common/on-black',
  'semantic/common/on-black-hover',
  'semantic/common/on-black-pressed',
  'semantic/common/informative',
  'semantic/common/informative-hover',
  'semantic/common/informative-pressed',
  'semantic/common/informative-low'
];

// Î™®Îì† Î≥ÄÏàò Îã§Ïãú Î°úÎìú (ÏÉàÎ°ú ÏÉùÏÑ±Îêú Í≤É Ìè¨Ìï®)
allVariables = await figma.variables.getLocalVariablesAsync('COLOR');

// preserve ÌÜ†ÌÅ∞Îì§Ïùò ÏõêÎ≥∏ Í∞íÏùÑ ÎØ∏Î¶¨ Ï†ÄÏû•
var preserveOriginalValues = {};
for (var k = 0; k < preserveTokens.length; k++) {
  var preserveTokenName = preserveTokens[k];
  var preserveVar = allVariables.find(function(v) {
    return v.name === preserveTokenName && v.variableCollectionId === collection.id;
  });
  
  if (preserveVar) {
    preserveOriginalValues[preserveTokenName] = {
      light: preserveVar.valuesByMode[baseLightMode.modeId],
      dark: preserveVar.valuesByMode[baseDarkMode.modeId]
    };
    // console.log('[PRESERVE BACKUP]', preserveTokenName);
  }
}

// Îß§ÌïëÎêú ÌÜ†ÌÅ∞ + preserveTokens Î™®Îëê Ï≤òÎ¶¨
var mappingKeys = Object.keys(dynamicMappings);
var allTokensToProcess = mappingKeys.slice(); // Îß§ÌïëÎêú ÌÜ†ÌÅ∞Îì§ Î≥µÏÇ¨

// preserveTokens Ï§ë Îß§ÌïëÏóê ÏóÜÎäî Í≤ÉÎì§ Ï∂îÍ∞Ä
for (var j = 0; j < preserveTokens.length; j++) {
  if (mappingKeys.indexOf(preserveTokens[j]) === -1) {
    allTokensToProcess.push(preserveTokens[j]);
  }
}

console.log('Processing', allTokensToProcess.length, 'tokens total');
console.log('Mapped tokens:', mappingKeys.length);
console.log('Preserve tokens:', preserveTokens.length);

for (var i = 0; i < allTokensToProcess.length; i++) {
  var tokenName = allTokensToProcess[i];
  var mappedValue = dynamicMappings[tokenName]; // preserve ÌÜ†ÌÅ∞ÏùÄ undefinedÏùº Ïàò ÏûàÏùå
  
  console.log('[MAPPING]', tokenName, '‚Üí', mappedValue);
  
  // Ïù¥ÎØ∏ Î≥µÏÇ¨Îêú Î≥ÄÏàòÍ∞Ä ÏûàÎäîÏßÄ ÌôïÏù∏
  var existingVariable = allVariables.find(function(v) {
    return v.name === tokenName && v.variableCollectionId === collection.id;
  });
  
  var variable = existingVariable || await findOrCreateVariable(tokenName, collection, 'COLOR');
  
  if (tokenName.includes('border/divider') || tokenName.includes('border/line')) {
    console.log('[BORDER DEBUG]', tokenName, 'mappedValue.light:', mappedValue ? mappedValue.light : 'undefined');
    console.log('[BORDER DEBUG]', tokenName, 'mappedValue.dark:', mappedValue ? mappedValue.dark : 'undefined');
  }
  
  if (mappedValue) {
    // GRAY: ÌîÑÎ¶¨ÌîΩÏä§ Ï≤òÎ¶¨
    if (mappedValue.light && mappedValue.light.startsWith('GRAY:')) {
      var grayStep = parseInt(mappedValue.light.replace('GRAY:', ''));
      var grayVariableName = 'scale/gray-' + grayStep;
      
      var grayVar = allVariables.find(function(v) {
        return v.name === grayVariableName && v.variableCollectionId === collection.id;
      });
      
      if (grayVar) {
        variable.setValueForMode(customLightModeId, {
          type: 'VARIABLE_ALIAS',
          id: grayVar.id
        });
      } else {
        console.log('[SKIP]', tokenName, 'missing-gray-variable', grayVariableName);
        skippedCount++;
      }
    }
    
    // GRAY-ALPHA: ÌîÑÎ¶¨ÌîΩÏä§ Ï≤òÎ¶¨
    if (mappedValue.light && mappedValue.light.startsWith('GRAY-ALPHA:')) {
      var grayAlphaStep = parseInt(mappedValue.light.replace('GRAY-ALPHA:', ''));
      var grayAlphaVariableName = 'scale/gray-alpha-' + grayAlphaStep;
      
      var grayAlphaVar = allVariables.find(function(v) {
        return v.name === grayAlphaVariableName && v.variableCollectionId === collection.id;
      });
      
      if (grayAlphaVar) {
        variable.setValueForMode(customLightModeId, {
          type: 'VARIABLE_ALIAS',
          id: grayAlphaVar.id
        });
      } else {
        console.log('[SKIP]', tokenName, 'missing-gray-alpha-variable', grayAlphaVariableName);
        skippedCount++;
      }
    }
    
    if (mappedValue.dark && mappedValue.dark.startsWith('GRAY:')) {
      var grayStepDark = parseInt(mappedValue.dark.replace('GRAY:', ''));
      var grayVariableNameDark = 'scale/gray-' + grayStepDark;
      
      var grayVarDark = allVariables.find(function(v) {
        return v.name === grayVariableNameDark && v.variableCollectionId === collection.id;
      });
      
      if (grayVarDark) {
        variable.setValueForMode(customDarkModeId, {
          type: 'VARIABLE_ALIAS',
          id: grayVarDark.id
        });
      } else {
        console.log('[SKIP]', tokenName, 'missing-gray-variable-dark', grayVariableNameDark);
        skippedCount++;
      }
    }
    
    // GRAY-ALPHA: ÌîÑÎ¶¨ÌîΩÏä§ Ï≤òÎ¶¨ Dark
    if (mappedValue.dark && mappedValue.dark.startsWith('GRAY-ALPHA:')) {
      var grayAlphaStepDark = parseInt(mappedValue.dark.replace('GRAY-ALPHA:', ''));
      var grayAlphaVariableNameDark = 'scale/gray-alpha-' + grayAlphaStepDark;
      
      var grayAlphaVarDark = allVariables.find(function(v) {
        return v.name === grayAlphaVariableNameDark && v.variableCollectionId === collection.id;
      });
      
      if (grayAlphaVarDark) {
        variable.setValueForMode(customDarkModeId, {
          type: 'VARIABLE_ALIAS',
          id: grayAlphaVarDark.id
        });
      } else {
        console.log('[SKIP]', tokenName, 'missing-gray-alpha-variable-dark', grayAlphaVariableNameDark);
        skippedCount++;
      }
    }
    
    // STATIC: ÌîÑÎ¶¨ÌîΩÏä§ Ï≤òÎ¶¨
    if (mappedValue.light && mappedValue.light.startsWith('STATIC:')) {
      var staticName = mappedValue.light.replace('STATIC:', '');
      var staticVariableName = 'static/' + staticName;
      
      var staticVar = allVariables.find(function(v) {
        return v.name === staticVariableName && v.variableCollectionId === collection.id;
      });
      
      if (staticVar) {
        variable.setValueForMode(customLightModeId, {
          type: 'VARIABLE_ALIAS',
          id: staticVar.id
        });
        variable.setValueForMode(customDarkModeId, {
          type: 'VARIABLE_ALIAS',
          id: staticVar.id
        });
        console.log('[SEM]', tokenName, 'CustomLight/Dark', 'STATIC', staticName);
        createdCount++;
        continue; // Îã§Ïùå ÌÜ†ÌÅ∞ÏúºÎ°ú
      } else {
        console.log('[SKIP]', tokenName, 'missing-static-variable', staticVariableName);
        skippedCount++;
      }
    }
    
    // REF: ÌîÑÎ¶¨ÌîΩÏä§ Ï≤òÎ¶¨ - alias Î∞©ÏãùÏúºÎ°ú Î≥ÄÍ≤Ω
    if (mappedValue.light && mappedValue.light.startsWith('REF:')) {
      var lightRefInfo = mappedValue.light.replace('REF:', '');
      var lightStep = parseInt(lightRefInfo.match(/\d+$/)[0]);
      
      // scale Î≥ÄÏàò Ï∞æÏïÑÏÑú aliasÎ°ú Ïó∞Í≤∞
      var lightScaleVarName = 'scale/' + theme.themeName + '-' + lightStep;
      var lightScaleVar = allVariables.find(function(v) {
        return v.name === lightScaleVarName && v.variableCollectionId === collection.id;
      });
      
      if (lightScaleVar) {
        variable.setValueForMode(customLightModeId, {
          type: 'VARIABLE_ALIAS',
          id: lightScaleVar.id
        });
      } else {
        console.log('[SKIP]', tokenName, 'missing-scale-color-light', lightStep);
        skippedCount++;
      }
    }
    
    if (mappedValue.dark && mappedValue.dark.startsWith('REF:')) {
      var darkRefInfo = mappedValue.dark.replace('REF:', '');
      var darkStep = parseInt(darkRefInfo.match(/\d+$/)[0]);
      
      var darkScaleVarName = 'scale/' + theme.themeName + '-' + darkStep;
      var darkScaleVar = allVariables.find(function(v) {
        return v.name === darkScaleVarName && v.variableCollectionId === collection.id;
      });
      
      if (darkScaleVar) {
        variable.setValueForMode(customDarkModeId, {
          type: 'VARIABLE_ALIAS',
          id: darkScaleVar.id
        });
      } else {
        console.log('[SKIP]', tokenName, 'missing-scale-color-dark', darkStep);
        skippedCount++;
      }
    }
    
    // ALPHA: ÌîÑÎ¶¨ÌîΩÏä§ Ï≤òÎ¶¨
    if (mappedValue.light && mappedValue.light.startsWith('ALPHA:')) {
      var alphaInfo = mappedValue.light.replace('ALPHA:', '');
      var step = parseInt(alphaInfo.match(/\d+$/)[0]);
      var alphaVariableName = 'scale/' + theme.themeName + '-alpha-' + step;
      console.log('[ALPHA DEBUG Light]', tokenName, 'wants step', step, 'looking for', alphaVariableName);
      
      var alphaVar = allVariables.find(function(v) {
        return v.name === alphaVariableName && v.variableCollectionId === collection.id;
      });
      
      if (alphaVar) {
        variable.setValueForMode(customLightModeId, {
          type: 'VARIABLE_ALIAS',
          id: alphaVar.id
        });
        variable.setValueForMode(customDarkModeId, {
          type: 'VARIABLE_ALIAS',
          id: alphaVar.id
        });
        console.log('[SEM]', tokenName, 'CustomLight/Dark', 'ALPHA', step);
        createdCount++;
        continue; // Îã§Ïùå ÌÜ†ÌÅ∞ÏúºÎ°ú
      } else {
        console.log('[SKIP]', tokenName, 'missing-alpha-variable', alphaVariableName);
        skippedCount++;
      }
    }
    
    // ALPHA: ÌîÑÎ¶¨ÌîΩÏä§ Ï≤òÎ¶¨ Dark
    if (mappedValue.dark && mappedValue.dark.startsWith('ALPHA:')) {
      var alphaInfo = mappedValue.dark.replace('ALPHA:', '');
      var step = parseInt(alphaInfo.match(/\d+$/)[0]);
      var alphaVariableName = 'scale/' + theme.themeName + '-alpha-' + step;
      console.log('[ALPHA DEBUG Dark]', tokenName, 'wants step', step, 'looking for', alphaVariableName);
      
      var alphaVar = allVariables.find(function(v) {
        return v.name === alphaVariableName && v.variableCollectionId === collection.id;
      });
      
      if (alphaVar) {
        variable.setValueForMode(customDarkModeId, {
          type: 'VARIABLE_ALIAS',
          id: alphaVar.id
        });
        console.log('[SEM]', tokenName, 'CustomDark', 'ALPHA', step);
        createdCount++;
        continue; // Îã§Ïùå ÌÜ†ÌÅ∞ÏúºÎ°ú
      } else {
        console.log('[SKIP]', tokenName, 'missing-alpha-variable-dark', alphaVariableName);
        skippedCount++;
      }
    }
    
    // ON-COLOR-ALPHA: ÌîÑÎ¶¨ÌîΩÏä§ Ï≤òÎ¶¨
    if (mappedValue.light && mappedValue.light.startsWith('ON-COLOR-ALPHA:')) {
      var onColorAlphaStep = parseInt(mappedValue.light.replace('ON-COLOR-ALPHA:', ''));
      var onColorAlphaVariableName = 'scale/on-color-alpha-' + onColorAlphaStep;
      
      var onColorAlphaVar = allVariables.find(function(v) {
        return v.name === onColorAlphaVariableName && v.variableCollectionId === collection.id;
      });
      
      if (onColorAlphaVar) {
        variable.setValueForMode(customLightModeId, {
          type: 'VARIABLE_ALIAS',
          id: onColorAlphaVar.id
        });
        console.log('[SEM]', tokenName, 'CustomLight', 'ON-COLOR-ALPHA', onColorAlphaStep);
        createdCount++;
        continue; // Îã§Ïùå ÌÜ†ÌÅ∞ÏúºÎ°ú
      } else {
        console.log('[SKIP]', tokenName, 'missing-on-color-alpha-variable', onColorAlphaVariableName);
        skippedCount++;
      }
    }

    // ON-COLOR-ALPHA: ÌîÑÎ¶¨ÌîΩÏä§ Ï≤òÎ¶¨ Dark
    if (mappedValue.dark && mappedValue.dark.startsWith('ON-COLOR-ALPHA:')) {
      var onColorAlphaStepDark = parseInt(mappedValue.dark.replace('ON-COLOR-ALPHA:', ''));
      var onColorAlphaVariableNameDark = 'scale/on-color-alpha-' + onColorAlphaStepDark;
      
      var onColorAlphaVarDark = allVariables.find(function(v) {
        return v.name === onColorAlphaVariableNameDark && v.variableCollectionId === collection.id;
      });
      
      if (onColorAlphaVarDark) {
        variable.setValueForMode(customDarkModeId, {
          type: 'VARIABLE_ALIAS',
          id: onColorAlphaVarDark.id
        });
        console.log('[SEM]', tokenName, 'CustomDark', 'ON-COLOR-ALPHA', onColorAlphaStepDark);
        createdCount++;
        continue; // Îã§Ïùå ÌÜ†ÌÅ∞ÏúºÎ°ú
      } else {
        console.log('[SKIP]', tokenName, 'missing-on-color-alpha-variable-dark', onColorAlphaVariableNameDark);
        skippedCount++;
      }
    }
    
    createdCount++;
    continue; // Îã§Ïùå ÌÜ†ÌÅ∞ÏúºÎ°ú
  }
  
  
  // preserveTokens Ï≤òÎ¶¨ - ÏõêÎ≥∏ Î∞±ÏóÖ Í∞íÏùÑ CustomLight/CustomDarkÎ°ú Î≥µÏ†ú
  if (preserveTokens.indexOf(tokenName) !== -1) {
    // console.log('[PRESERVE]', tokenName, 'Using original backed up values');
    
    var originalValues = preserveOriginalValues[tokenName];
    if (originalValues) {
      // Light ‚Üí CustomLight Î≥µÏ†ú (Î∞±ÏóÖÎêú ÏõêÎ≥∏ Í∞í ÏÇ¨Ïö©)
      if (originalValues.light) {
        variable.setValueForMode(customLightModeId, originalValues.light);
      }
      
      // Dark ‚Üí CustomDark Î≥µÏ†ú (Î∞±ÏóÖÎêú ÏõêÎ≥∏ Í∞í ÏÇ¨Ïö©)
      if (originalValues.dark) {
        variable.setValueForMode(customDarkModeId, originalValues.dark);
      }
    }
    
    createdCount++;
    continue;
  }
  
  // Îß§ÌïëÏù¥ ÏóÜÎäî ÌÜ†ÌÅ∞ÏùÄ Í∏∞Î≥∏Ï†ÅÏúºÎ°ú Light‚ÜíCustomLight, Dark‚ÜíCustomDark Î≥µÏÇ¨
  console.log('[DEFAULT]', tokenName, 'No mapping found, copying Light‚ÜíCustomLight, Dark‚ÜíCustomDark');
  
  // Light ‚Üí CustomLight Î≥µÏ†ú
  if (baseLightMode && variable.valuesByMode[baseLightMode.modeId]) {
    var lightValue = variable.valuesByMode[baseLightMode.modeId];
    variable.setValueForMode(customLightModeId, lightValue);
  }
  
  // Dark ‚Üí CustomDark Î≥µÏ†ú
  if (baseDarkMode && variable.valuesByMode[baseDarkMode.modeId]) {
    var darkValue = variable.valuesByMode[baseDarkMode.modeId];
    variable.setValueForMode(customDarkModeId, darkValue);
  }
  
  createdCount++;
}
  // =====================================
  // STEP 7: Í≤∞Í≥º Î≥¥Í≥†
  // =====================================
  
  console.log('=== Theme Creation Complete ===');
  console.log('Created:', createdCount, 'Skipped:', skippedCount);
  
  figma.ui.postMessage({ 
    type: 'custom-theme-created',
    success: true,
    count: createdCount,
    skipped: skippedCount,
    themeName: theme.themeName
  });
  
  figma.notify('Created ' + createdCount + ' variables for ' + theme.themeName);
}

// Custom Mode Ï†ÅÏö© Ìï∏Îì§Îü¨ - ÏµúÏÉÅÏúÑ ÌîÑÎ†àÏûÑÏóêÎßå Ï†ÅÏö©, ÏûêÏãùÏùÄ ÏÉÅÏÜç
async function handleApplyCustomModeToFrame(msg) {
  try {
    var targetModeName = msg.modeName;
    var selection = figma.currentPage.selection;
    
    if (selection.length === 0) {
      figma.notify('FrameÏùÑ ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî');
      return;
    }
  
  var collections = await figma.variables.getLocalVariableCollectionsAsync();
  
  // FrameÏóê Ïã§Ï†úÎ°ú Ï†ÅÏö©Îêú Î≥ÄÏàòÎì§Ïù¥ ÏÇ¨Ïö©ÌïòÎäî Ïª¨Î†âÏÖò Ï∞æÍ∏∞
  var usedCollections = new Set();
  
  // ÏÑ†ÌÉùÎêú ÎÖ∏ÎìúÎì§ÏóêÏÑú ÏÇ¨Ïö©Îêú Î≥ÄÏàòÎì§Ïùò Ïª¨Î†âÏÖò ÏàòÏßë
  for (var i = 0; i < selection.length; i++) {
    var node = selection[i];
    if (node.boundVariables) {
      for (var prop in node.boundVariables) {
        var boundVar = node.boundVariables[prop];
        // boundVarÍ∞Ä Î∞∞Ïó¥Ïù∏ Í≤ΩÏö∞ÏôÄ Îã®Ïùº Í∞ùÏ≤¥Ïù∏ Í≤ΩÏö∞ Î™®Îëê Ï≤òÎ¶¨
        var boundVars = Array.isArray(boundVar) ? boundVar : [boundVar];
        
        for (var j = 0; j < boundVars.length; j++) {
          var singleBoundVar = boundVars[j];
          if (singleBoundVar && singleBoundVar.id) {
            try {
              var variable = await figma.variables.getVariableByIdAsync(singleBoundVar.id);
              if (variable) {
                var collection = collections.find(function(c) { return c.id === variable.variableCollectionId; });
                if (collection) {
                  usedCollections.add(collection.name);
                }
              }
            } catch (error) {
              console.log('Error getting variable:', singleBoundVar.id, error);
            }
          }
        }
      }
    }
  }
  
  console.log('Frame uses collections:', Array.from(usedCollections));
  
  // ruler_v2 collectionÏóêÏÑú Ìï¥Îãπ Î™®Îìú Ï∞æÍ∏∞
  var collection = collections.find(function(c) { return c.name === 'ruler_v2'; });
  var customMode = null;
  
  if (collection) {
    customMode = collection.modes.find(function(m) { return m.name === targetModeName; });
  }
  
  if (!collection || !customMode) {
    throw new Error('ÌïÑÏöîÌïú Î™®Îìú "' + targetModeName + '"Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§');
  }
  
  console.log('Using collection:', collection.name, 'for mode:', targetModeName);
  
  // FrameÏùÑ Ìï¥Îãπ Î™®ÎìúÎ°ú Ï†ÑÌôò
  for (var i = 0; i < selection.length; i++) {
    var node = selection[i];
    if (node.type === 'FRAME' || node.type === 'GROUP' || node.type === 'COMPONENT' || node.type === 'INSTANCE') {
      try {
        // FigmaÏùò ÎÇ¥Ïû• Í∏∞Îä•ÏúºÎ°ú Ï†ÑÏ≤¥ FrameÏùÑ Ìï¥Îãπ Î™®ÎìúÎ°ú Ï†ÑÌôò
        if (!node.explicitVariableModes) {
          node.explicitVariableModes = {};
        }
        node.explicitVariableModes[collection.id] = customMode.modeId;
        console.log('Switched', node.name, 'to mode:', targetModeName);
      } catch (error) {
        console.log('Error switching mode for node:', node.name, error);
        figma.notify('Î™®Îìú Ï†ÑÌôò Ï§ë Ïò§Î•ò: ' + node.name);
      }
    }
  }
  
  // ÏµúÏÉÅÏúÑ Î£®Ìä∏ ÎÖ∏ÎìúÎßå Ï∂îÏ∂ú (Îã§Î•∏ ÏÑ†ÌÉùÎêú ÎÖ∏ÎìúÏóê Ìè¨Ìï®ÎêòÏßÄ ÏïäÎäî ÎÖ∏ÎìúÎì§)
  var rootNodes = [];
  for (var i = 0; i < selection.length; i++) {
    var isRoot = true;
    for (var j = 0; j < selection.length; j++) {
      if (i !== j && isAncestor(selection[j], selection[i])) {
        isRoot = false;
        break;
      }
    }
    if (isRoot) {
      rootNodes.push(selection[i]);
    }
  }
  
  var appliedCount = 0;
  var clearedCount = 0;
  
  // ÎÖ∏ÎìúÍ∞Ä Îã§Î•∏ ÎÖ∏ÎìúÏùò Ï°∞ÏÉÅÏù∏ÏßÄ ÌôïÏù∏
  function isAncestor(possibleAncestor, node) {
    var parent = node.parent;
    while (parent) {
      if (parent === possibleAncestor) {
        return true;
      }
      parent = parent.parent;
    }
    return false;
  }
  
  // ÏûêÏãù ÎÖ∏ÎìúÎì§Ïùò Î™ÖÏãúÏ†Å Î™®Îìú ÏÑ§Ï†ï Ï†úÍ±∞
  function clearChildrenModes(node) {
    if ('children' in node && node.children) {
      for (var i = 0; i < node.children.length; i++) {
        var child = node.children[i];
        
        // Frame ÌÉÄÏûÖÏù∏ Í≤ΩÏö∞ Î™ÖÏãúÏ†Å Î™®Îìú Ï†úÍ±∞ (ÏÉÅÏÜç ÏÉÅÌÉúÎ°ú Î≥ÄÍ≤Ω)
        if (child.type === 'FRAME' || child.type === 'COMPONENT' || child.type === 'INSTANCE') {
          try {
            // Î™ÖÏãúÏ†Å Î™®Îìú Ï†úÍ±∞ - nullÏùÑ ÏÑ§Ï†ïÌïòÎ©¥ ÏÉÅÏÜç ÏÉÅÌÉúÍ∞Ä Îê®
            child.setExplicitVariableModeForCollection(collection, null);
            clearedCount++;
          } catch (e) {
            // Ïù¥ÎØ∏ ÏÉÅÏÜç ÏÉÅÌÉúÏù∏ Í≤ΩÏö∞ Î¨¥Ïãú
          }
        }
        
        // Ïû¨Í∑ÄÏ†ÅÏúºÎ°ú Î™®Îì† ÏûêÏãù Ï≤òÎ¶¨
        clearChildrenModes(child);
      }
    }
  }
  
  // Í∞Å Î£®Ìä∏ ÎÖ∏Îìú Ï≤òÎ¶¨
  for (var i = 0; i < rootNodes.length; i++) {
    var rootNode = rootNodes[i];
    
    // Î£®Ìä∏Í∞Ä Frame ÌÉÄÏûÖÏù∏ÏßÄ ÌôïÏù∏
    if (rootNode.type === 'FRAME' || rootNode.type === 'COMPONENT' || rootNode.type === 'INSTANCE') {
      // ÏµúÏÉÅÏúÑ ÌîÑÎ†àÏûÑÏóêÎßå Î™®Îìú Ï†ÅÏö©
      rootNode.setExplicitVariableModeForCollection(collection, customMode.modeId);
      appliedCount++;
      
      // Î™®Îì† ÏûêÏãùÎì§Ïùò Î™ÖÏãúÏ†Å Î™®Îìú ÏÑ§Ï†ï Ï†úÍ±∞
      clearChildrenModes(rootNode);
    } else {
      console.warn('ÏÑ†ÌÉùÎêú ÎÖ∏ÎìúÍ∞Ä Frame ÌÉÄÏûÖÏù¥ ÏïÑÎãò:', rootNode.type);
    }
  }
  
  figma.ui.postMessage({
    type: 'custom-mode-applied',
    success: true,
    count: appliedCount,
    cleared: clearedCount,
    modeName: targetModeName
  });
  
  var message = targetModeName + ' Î™®ÎìúÍ∞Ä ' + appliedCount + 'Í∞ú ÏµúÏÉÅÏúÑ FrameÏóê Ï†ÅÏö©ÎêòÏóàÏäµÎãàÎã§';
  if (clearedCount > 0) {
    message += ' (' + clearedCount + 'Í∞ú ÏûêÏãù Frame ÏÉÅÏÜç Ï≤òÎ¶¨)';
  }
  
  figma.notify(message);
  
  } catch (error) {
    console.log('Error in handleApplyCustomModeToFrame:', error);
    figma.notify('Î™®Îìú Ï†ÅÏö© Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ' + error.message);
  }
}

// ÌÜ§ Îß§Ïπ≠ Ìï∏Îì§Îü¨
async function handleToneMatching(msg) {
  var suggestions = generateToneMatchingSuggestions(msg.referenceColor, msg.inputColor);
  
  figma.ui.postMessage({
    type: 'tone-matching-complete',
    suggestions: suggestions,
    originalColor: msg.inputColor,
    referenceColor: msg.referenceColor
  });
}

// =====================================
// Î©îÏù∏ Î©îÏãúÏßÄ Ìï∏Îì§Îü¨
// =====================================

figma.ui.onmessage = async function(msg) {
  console.log('Received message:', msg.type);
  
  try {
    if (msg.type === 'create-variables') {
      await handleCreateVariables(msg);
    } else if (msg.type === 'create-custom-theme') {
      await handleCreateCustomTheme(msg);
    } else if (msg.type === 'apply-custom-mode-to-frame') {
      await handleApplyCustomModeToFrame(msg);
    } else if (msg.type === 'generate-tone-matching') {
      await handleToneMatching(msg);
    }
  } catch (error) {
    console.error('Error handling message:', error);
    figma.notify('Error: ' + error.message, { error: true });
  }
};

// =====================================
// Ï¥àÍ∏∞Ìôî
// =====================================

// Ï¥àÍ∏∞Ìôî Î©îÏãúÏßÄ
setTimeout(function() {
  figma.ui.postMessage({ 
    type: 'plugin-ready', 
    message: 'Plugin initialized successfully' 
  });
  console.log('Ready message sent');
}, 100);

console.log('Backend script loaded successfully');